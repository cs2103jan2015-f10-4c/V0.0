#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <inttypes.h>
#include <fcntl.h>
#include <sys/stat.h>

/* Maximum number of events to be handled */
#define MAX 100

/* ======================================================================= */
/* ======================================================================= */

/* Convert Date & Time from String to time_t */
/* Source from: http://stackoverflow.com/questions/11213326/how-to-convert-a-string-variable-containing-time-to-time-t-type-in-c */
/* Edited to apply in COMP2432 Project */
time_t strToDateTime(char yyyymmdd[], char hhnn[]) {

    char yyyy[4];                               /* YEAR */
    char mm[2];                                 /* MONTH */
    char dd[2];                                 /* DAY */
    char hh[2];                                 /* HOUR */
    char nn[2];                                 /* MINUTE */
    
    char mmdd[5];
    struct tm when = {0};
    time_t result;                              /* Result of Convertion */

    /* Break down String */
    sscanf(yyyymmdd, "%[^-]-%s", yyyy, mmdd);
    sscanf(mmdd, "%[^-]-%s", mm, dd);
    sscanf(hhnn, "%[^:]:%s", hh, nn);

    /* Convertion */
    when.tm_year = atoi(yyyy) - 1900;
    when.tm_mon = atoi(mm) - 1;
    when.tm_mday = atoi(dd);
    when.tm_hour = atoi(hh);
    when.tm_min = atoi(nn);
    when.tm_sec = 0;
    result = mktime(&when);
    
    return result;
}
/* Referenced part ends */

/* ======================================================================= */
/* ======================================================================= */

/* Convert Date & Time from time_t to String */
/* and Display DateTime */
/* Source from: http://stackoverflow.com/questions/3053999/c-convert-time-t-to-string-with-format-yyyy-mm-dd-hhmmss */
/* Edited to apply in COMP2432 Project */
void strFromDateTime(time_t datetime) {
    struct tm * tempTime;
    char result[20];
    
    tempTime = localtime(&datetime);
    strftime(result, 20, "%Y-%b-%d %H:%M", tempTime);
    printf("%s", result);
}
/* Referenced part ends */

/* ======================================================================= */
/* ======================================================================= */

/* Return Valid Beginning Date & Time */
/* Handle assumption 1 & 2 in project description */
time_t validBegDateTime(time_t begDateTime, time_t calDateTime) { 
    int temp;
    
    /* Handle Assumption 2 */
    if (calDateTime > begDateTime) {
            begDateTime = calDateTime;
    }
    
    /* Handle Assumption 1 */
    temp = begDateTime % 3600;
    if (temp > 0) {
        begDateTime -= temp;
    }
    
    return begDateTime;
}

/* ======================================================================= */
/* ======================================================================= */

/* Return Valid Ending Date & Time */
/* Handle assumption 1 & 2 in project description */
time_t validEndDateTime(time_t endDateTime, time_t calDateTime) {
    int temp;
    
    /* Handle Assumption 2 */
    if (calDateTime < endDateTime) {
            endDateTime = calDateTime;
    }
    
    /* Handle Assumption 1 */
    temp = endDateTime % 3600;
    if (temp > 0) {
        temp = 3600 - temp;
        endDateTime += temp;
    }
    
    return endDateTime;
}

/* ======================================================================= */
/* ======================================================================= */

/* Calculate duration of calender period */
int addPeriod(time_t beg, time_t end) {
    double result;
    int interval;

    result = difftime(end, beg);
    interval = result / 60 / 60;

    return interval;
}

/* ======================================================================= */
/* ======================================================================= */

/* Display Calender */
void displayCal(int size, char cal[size][2][255], 
                time_t beg, time_t end) {
    int i;
    char curStr[255];
    char evtStr[255];
    time_t cur;

    printf("------------------------ Timetable ------------------------ \n");
    printf("----------------- From  ");
    strFromDateTime(beg);
    printf(" ----------------- \n");
    printf("-----------------   To  ");
    strFromDateTime(end);
    printf(" ----------------- \n");
    printf("-------------------- Generated by ASKS -------------------- \n");
    
    for(i=0; i<size; i++) {
        strcpy(curStr, cal[i][0]);
        strFromDateTime(atoi(curStr));
        printf("\n");
        strcpy(evtStr, cal[i][1]);
        printf("           Event: %s \n", evtStr);
        printf("------------------------------------------------------------ \n");
        
        cur += 3600;
    }
    
    printf("--------------------- End of Schedule --------------------- \n");
    printf("-------------------- ");
    strFromDateTime(end);
    printf(" -------------------- \n");
}

/* ======================================================================= */
/* ======================================================================= */

/* Output Calender to file */
/* Source from COMP2432 Lab5C */
/* Link: http://www4.comp.polyu.edu.hk/~cshleong/COMP2432/lab5C.c */
/* Edited to apply in COMP2432 Project */
void outputCal(char location[255], int size, char cal[size][2][255], 
               time_t beg, time_t end) {
    int outfd;

    printf("Output processing... \n");   
    outfd = open(location, O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);
    if (outfd < 0) {
        fprintf(stderr, "Error in writing file. \n");
        exit(1);
    }
    dup2(outfd,1);

    displayCal(size, cal, beg, end);
    
    close(outfd);
    fprintf(stderr, "Output Successful. \n");
}
/* Referenced part ends */

/* ======================================================================= */
/* ======================================================================= */

int main()
{   
    int pid[MAX];                                                   /* Store Child Process */
    int ctr = 0;                                                    /* Count number of Child Process */
    int end = 0;

    char buf[255], buf2[255];
    int fd[MAX][2];                                                 /* Pipe between parent and child */
    int fd2[MAX][2];                                                /* Pipe between parent and child */

    char tempStr[255];
    char input[MAX][255];                                           /* Store input of Strings */
    
    /* Components of input string */
    char inType[20];
    char alType[20];
    char eventName[255];
    char begDate[10];
    char begTime[5];
    char endDate[10];
    char endTime[5];
    char strDUR[16];
    char strPR[16];
    int duration = 0;
    
    time_t begDateTime;                                             /* Begin Date & Time in time_t */
    time_t endDateTime;                                             /* Ending Date & Time in time_t */

    int a, b, c, d, i, j, x, y, z;                                     /* Iteration counter */

/* ======================================================================= */
    
    /* Get input from user */
    while ((end >= 0) && (ctr < MAX)) {
        printf("Please Enter: \n");
        gets(tempStr);

        /* Read input statement */
        sscanf(tempStr, "%s", inType);                            /* Identify type of statement */
        
        /* output method */
        if (strcmp(inType, "runASKS") == 0) {
            sscanf(tempStr, "%s%s", inType, alType);
            end = -1;                                               /* End input */
        }
        /* Declear length of Period */
        else if (strcmp(inType, "addPeriod") == 0) {
            sscanf(tempStr, "%s%s%s%s%s", inType, begDate, begTime, endDate, endTime);
            begDateTime = strToDateTime(begDate, begTime);
            begDateTime = validBegDateTime(begDateTime, begDateTime);
            endDateTime = strToDateTime(endDate, endTime);
            endDateTime = validEndDateTime(endDateTime, endDateTime);
            duration = addPeriod(begDateTime, endDateTime);
            duration = addPeriod(begDateTime, endDateTime);
        }
        /* Input of Event */
        else if ((strcmp(inType, "addClass") == 0) ||
                 (strcmp(inType, "addAssignment") == 0) ||
                 (strcmp(inType, "addProject") == 0) ||
                 (strcmp(inType, "addActivity") == 0)) {
            strcpy(input[ctr], tempStr);                            /* Store string in array */
            ctr++;                                                  /* Count number of event added */
        }
        else {
            printf("Input Error. Please try again. \n");
        }
    }

/* ======================================================================= */

    /* Declear and Initialise Calendar */
    if (duration <= 0) { 
        printf("Period of schedule is not clarified. \n");
        exit(1);
    }
    
    char cal[duration][2][255];
    char tempStrDateTime[20];
    long int tempDateTime = begDateTime;
    for(j=0; j<duration; j++) {
        snprintf (tempStrDateTime, 20, "%d", tempDateTime); 
        strcpy(cal[j][0], tempStrDateTime);
        strcpy(cal[j][1], "AVAILABLE");
        tempDateTime += 3600;
    }

/* ======================================================================= */
/* ======================================================================= */
/* ======================================================================= */

    /* Create Child and Pass Information */
    for(i=0; i<ctr; i++) {

    /* Create pipe fd */
    if(pipe(fd[i]) < 0) {                                           /* Pipe Creation ERROR */
        printf("Pipe creation error. \n");
        exit(1);
    }

    /* Create pipe fd2 */
    if(pipe(fd2[i]) < 0) {                                          /* Pipe Creation ERROR */
        printf("Pipe creation error. \n");
        exit(1);
    }

    pid[i] = fork();                                                /* Fork child */

    /* Fork ERROR */
    if (pid[i] < 0) {
        printf("Fail when creating child. \n");
        abort();
    }
        
/* ======================================================================= */

    /* Child Process */
    else if (pid[i] == 0) {
        close(fd[i][1]);                                            /* Close write descriptor of fd */
        close(fd2[i][0]);                                           /* Close read descriptor of fd2 */

        char tempDate[20];
        char tempTime[5];
        time_t tempDateTime;
        int tempDUR;
        
        /* Get info from Parent */
        read(fd[i][0], &buf, sizeof(buf));
        /* Read Input and Initialize variable */
        sscanf(buf, "%s", inType);
        if (strcmp(inType, "addClass") == 0) {
            sscanf(buf, "%s%s%s%s%s%s", 
                   inType, eventName, begDate, begTime, strDUR, strPR);
            begDateTime = strToDateTime(begDate, begTime);
            tempDUR = atoi(strDUR) * 60 * 60;
            endDateTime = begDateTime + tempDUR;
        }
        else if (strcmp(inType, "addAssignment") == 0) {
            sscanf(buf, "%s%s%s%s%s%s%s%s", 
                   inType, eventName, begDate, begTime, endDate, endTime, strDUR, strPR);
            begDateTime = strToDateTime(begDate, begTime);
            endDateTime = strToDateTime(endDate, endTime);
        }
        else if (strcmp(inType, "addProject") == 0) {
            sscanf(buf, "%s%s%s%s%s%s%s%s", 
                   inType, eventName, begDate, begTime, endDate, endTime, strDUR, strPR);
            begDateTime = strToDateTime(begDate, begTime);
            endDateTime = strToDateTime(endDate, endTime);
        }
        else if (strcmp(inType, "addActivity") == 0) {
            sscanf(buf, "%s%s%s%s%s%s", 
                   inType, eventName, begDate, begTime, strDUR, strPR);
            begDateTime = strToDateTime(begDate, begTime);
            tempDUR = atoi(strDUR) * 60 * 60;
            endDateTime = begDateTime + tempDUR;
        }
        else {
            printf("ERROR. Please restart. \n");
            abort();
        }

        int length = atof(strDUR) + 0.9;
        int priority = atoi(strPR);
        int remain = length;
        
        /* Check validity of beginning date and time */
        read(fd[i][0], &buf, sizeof(buf));
        strcpy(tempDate, buf);
        read(fd[i][0], &buf, sizeof(buf));
        strcpy(tempTime, buf);
        tempDateTime = strToDateTime(tempDate, tempTime);
        begDateTime = validBegDateTime(begDateTime, tempDateTime);
        
        /* Check validity of ending date and time */
        read(fd[i][0], &buf, sizeof(buf));
        strcpy(tempDate, buf);
        read(fd[i][0], &buf, sizeof(buf));
        strcpy(tempTime, buf);
        tempDateTime = strToDateTime(tempDate, tempTime);
        endDateTime = validEndDateTime(endDateTime, tempDateTime);
        
        /* The following do communication with scheduling algorithm */
        int run = 0;
        int turnaround = 0;
        char status[20];
        
        read(fd[i][0], &buf, sizeof(buf));
        strcpy(alType, buf);
        
        for(a=0; a<duration; a++) {
            /* Read time from parent */
            read(fd[i][0], &buf, sizeof(buf));
            tempDateTime = atoi(buf);
            
            /* Send status to parent */
            if (run == 1) {
            /* Child already in Queue */
                strcpy(status, "RUNNING");
            } else if (tempDateTime == begDateTime) {
            /* At start time, Child want to enter Queue */
                strcpy(status, "BEGIN");
                run = 1;
            } else if (tempDateTime == endDateTime || run == -1 || remain == 0) {
            /* At start time, Child want to enter Queue */
                strcpy(status, "ENDED");
                run = -1;
            } else if (run == 0) {
            /* Start time not yet arrive */
                strcpy(status, "WAITING");
            }
            strcpy(buf2, status);
            write(fd2[i][1], &buf2, sizeof(buf2));
            
            if ((strcmp(alType, "-SRT") == 0)) {
                snprintf (buf2, 255, "%d", remain);
                write(fd2[i][1], &buf2, sizeof(buf2));
            } else if ((strcmp(alType, "-PR") == 0)) {
                snprintf (buf2, 255, "%d", priority);
                write(fd2[i][1], &buf2, sizeof(buf2));
            } else {
                snprintf (buf2, 255, "%d", length);
                write(fd2[i][1], &buf2, sizeof(buf2));
            }
            
            /* No. of time handled */
            read(fd[i][0], &buf, sizeof(buf));
            if (atoi(buf) == 1) {
                remain--;
                turnaround++;
                strcpy(buf2, eventName);
                write(fd2[i][1], &buf2, sizeof(buf2));
            } else if (atoi(buf) == 0){
                if (remain > 0) {
                    turnaround++;
                }
            }
            
            /* Send remaining time to parent */
            snprintf (buf2, 255, "%d", remain);
            write(fd2[i][1], &buf2, sizeof(buf2));
            
        }
        
        /* Send info to parent */
        strcpy(buf2, eventName);
        write(fd2[i][1], &buf2, sizeof(buf2));
        snprintf (buf2, 255, "%d", begDateTime);
        write(fd2[i][1], &buf2, sizeof(buf2));
        snprintf (buf2, 255, "%d", remain);
        write(fd2[i][1], &buf2, sizeof(buf2));
        snprintf (buf2, 255, "%d", turnaround);
        write(fd2[i][1], &buf2, sizeof(buf2));
        snprintf (buf2, 255, "%d", length);
        write(fd2[i][1], &buf2, sizeof(buf2));
    
        strcpy(buf2, eventName);
        write(fd2[i][1], &buf2, sizeof(buf2));
        snprintf (buf2, 255, "%d", remain);
        write(fd2[i][1], &buf2, sizeof(buf2));
        
        close(fd[i][0]);                                            /* Close read descriptor of fd */
        close(fd2[i][1]);                                           /* Close write descriptor of fd2 */
        exit(0);
    }
        
/* ======================================================================= */

    /* Parent Process */
    else {
        close(fd[i][0]);                                            /* Close write descriptor of fd */
        close(fd2[i][1]);                                           /* Close read descriptor of fd2 */
        strcpy(buf, input[i]);
        write(fd[i][1], &buf, sizeof(buf));
        
        strcpy(buf, begDate);
        write(fd[i][1], &buf, sizeof(buf));
        strcpy(buf, begTime);
        write(fd[i][1], &buf, sizeof(buf));
        strcpy(buf, endDate);
        write(fd[i][1], &buf, sizeof(buf));
        strcpy(buf, endTime);
        write(fd[i][1], &buf, sizeof(buf));
        strcpy(buf, alType);
        write(fd[i][1], &buf, sizeof(buf));
    }

    /* for loop end */
    }
    
/* ======================================================================= */
/* ======================================================================= */
/* ======================================================================= */
    
    /* Scheduling with specific algorithm */
    
    /* Read statement */
    char arg1[10];
    char arg2[10];
    char arg3[10];
    char arg4[10];
    char arg5[20];
    char arg6[10];
    char arg7[255];
    int algorithm;
    
    /* Read info from Child */
    char status[20];
    
    /* Create Queue */
    int queue[MAX][2];                                              /* the Queue */
    int queCtr = 0;                                                 /* Queue Counter */
    int quePtr = 0;                                                 /* Queue Pointer */

    int eventEnd;
    

/* ======================================================================= */
    if (strcmp(alType, "-FCFS") == 0) {
        /* runASKS -FCFS | printReport > ASKS_report.dat */
        sscanf(tempStr, "%s%s%s%s%s%s", 
               arg1, arg2, arg4, arg5, arg6, arg7);
        algorithm = 1;    
        printf("Output Method = %s \n", alType);
    }
/* ======================================================================= */
    else if (strcmp(alType, "-SJF") == 0) {
        /* runASKS -SJF | printReport > ASKS_report.dat */
        sscanf(tempStr, "%s%s%s%s%s%s", 
               arg1, arg2, arg4, arg5, arg6, arg7);
        algorithm = 2;    
        printf("Output Method = %s \n", alType);
    }
/* ======================================================================= */
    else if (strcmp(alType, "-SRT") == 0) {
        /* runASKS -SRT | printReport > ASKS_report.dat */
        sscanf(tempStr, "%s%s%s%s%s%s", 
               arg1, arg2, arg4, arg5, arg6, arg7);
        algorithm = 3;    
        printf("Output Method = %s \n", alType);
    }
/* ======================================================================= */
    else if (strcmp(alType, "-PR") == 0) {
        /* runASKS -PR p | printReport > ASKS_report.dat */
        sscanf(tempStr, "%s%s%s%s%s%s%s", 
               arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    
        if (strcmp(arg3, "n") == 0) {
            algorithm = 2;    
            printf("Output Method = %s %s \n", alType, arg3);
        } else {
            algorithm = 3;
            printf("Output Method = %s %s \n", alType, arg3);
        }
    }
/* ======================================================================= */
    else if (strcmp(alType, "-RR") == 0) {
        /* runASKS -RR 4 | printReport > ASKS_report.dat */
        sscanf(tempStr, "%s%s%s%s%s%s%s", 
               arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        algorithm = 4;    
        printf("Output Method = %s \n", alType);
    }
/* ======================================================================= */
    
    else {
        printf("ERROR. Please restart. \n");
        exit(1);
    }
    
/* ======================================================================= */
    
    /* First Come First Serve */
    
    if (algorithm == 1) {
        
        for(a=0; a<duration; a++) {
            
            eventEnd = 0;
            
            /* Pass time to child */
            strcpy(buf, cal[a][0]);
            for(b=0; b<ctr; b++) {
                write(fd[b][1], &buf, sizeof(buf));
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get status from child */
                strcpy(status, buf2);
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get length from child */
                
                /* Child want to enter queue */
                if (strcmp(status, "BEGIN") == 0) {
                    queue[queCtr % MAX][0] = b;
                    queCtr++;
                }
            }
            
            if (quePtr < queCtr) {
            /* Choose event from queue to do */
            for(b=0; b<ctr; b++) {
                if (b == queue[quePtr % MAX][0]) {
                /* this is the event to do */
                    snprintf (buf, 255, "%d", 1);
                    write(fd[b][1], &buf, sizeof(buf));             /* Handled 1 hour */
                    
                    /* Declear event to time interval */
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get eventName from child */
                    strcpy(cal[a][1], buf2);
                    
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get remain from child */
                    /* Remain = 0, Event is finished */
                    if (atoi(buf2) == 0) {
                        eventEnd = 1;
                    }
                } else {
                /* this event is waiting */
                    snprintf (buf, 255, "%d", 0);
                    write(fd[b][1], &buf, sizeof(buf));             /* Handled 0 hour */
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get remain from child */
                }
            }
            } else {
                for(b=0; b<ctr; b++) {
                snprintf (buf, 255, "%d", -1);
                write(fd[b][1], &buf, sizeof(buf));                 /* Handled 0 hour */
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get remain from child */
                }
            }
            
            /* Current event ended */
            if (eventEnd == 1) {
                quePtr++;
            }
        }
        
    }
/* ======================================================================= */
    
    /* Shortest Job First */
    /* Non-Preemeptive Priority */
    
    else if (algorithm == 2) {
        
        for(a=0; a<duration; a++) {
            
            eventEnd = 0;
            
            /* Pass time to child */
            strcpy(buf, cal[a][0]);
            for(b=0; b<ctr; b++) {
                write(fd[b][1], &buf, sizeof(buf));
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get status from child */
                strcpy(status, buf2);
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get length from child */
                
                /* Child want to enter queue */
                if (strcmp(status, "BEGIN") == 0) {
                    queue[queCtr % MAX][0] = b;
                    queue[queCtr % MAX][1] = atoi(buf2);
                    
                    if (quePtr%MAX < queCtr%MAX) {
                    /* Sort Queue */
                    for(c=(queCtr%MAX); c>quePtr%MAX; c--) {
                        for(d=quePtr%MAX+1; d<c; d++) {
                            if (queue[d][1] > queue[d+1][1]) {
                            /* If recently added event is shorter, SWAP */
                                int temp0 = queue[d][0];
                                int temp1 = queue[d][1];
                                queue[d][0] = queue[d+1][0];
                                queue[d][1] = queue[d+1][1];
                                queue[d+1][0] = temp0;
                                queue[d+1][1] = temp1;
                            }
                        }
                    }
                    }
                    
                    queCtr++;
                }
            }
            
            if (quePtr < queCtr) {
            /* Choose event from queue to do */
            for(b=0; b<ctr; b++) {
                if (b == queue[quePtr % MAX][0]) {
                /* this is the event to do */
                    snprintf (buf, 255, "%d", 1);
                    write(fd[b][1], &buf, sizeof(buf));             /* Handled 1 hour */
                    
                    /* Declear event to time interval */
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get eventName from child */
                    strcpy(cal[a][1], buf2);
                    
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get remain from child */
                    /* Remain = 0, Event is finished */
                    if (atoi(buf2) == 0) {
                        eventEnd = 1;
                    }
                } else {
                /* this event is waiting */
                    snprintf (buf, 255, "%d", 0);
                    write(fd[b][1], &buf, sizeof(buf));             /* Handled 0 hour */
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get remain from child */
                }
            }
            } else {
                for(b=0; b<ctr; b++) {
                snprintf (buf, 255, "%d", -1);
                write(fd[b][1], &buf, sizeof(buf));                 /* Handled 0 hour */
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get remain from child */
                }
            }
            
            /* Current event ended */
            if (eventEnd == 1) {
                quePtr++;
            }
        }

    }
/* ======================================================================= */
    
    /* Shortest Remaining Time */
    /* Preemeptive Priority */
    
    else if (algorithm == 3) {
        
        for(a=0; a<duration; a++) {
            
            eventEnd = 0;
            queCtr = 0;
            quePtr = 0;
            
            /* Pass time to child */
            strcpy(buf, cal[a][0]);
            for(b=0; b<ctr; b++) {
                write(fd[b][1], &buf, sizeof(buf));
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get status from child */
                strcpy(status, buf2);
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get remain from child */
                
                /* Child want to enter queue */
                if (strcmp(status, "BEGIN") == 0 || (strcmp(status, "RUNNING") == 0)) {
                    if(atoi(buf2) > 0) {
                        queue[queCtr][0] = b;
                        queue[queCtr][1] = atoi(buf2);                         
                        queCtr++;
                    }
                }
            }
            
            /* Sort Queue */
            for(c=queCtr-1; c>0; c--) {
                for(d=0; d<c; d++) {
                     if (queue[d][1] > queue[(d+1)][1]) {
                         int temp0 = queue[d][0];
                         int temp1 = queue[d][1];
                         queue[d][0] = queue[(d+1)][0];
                         queue[d][1] = queue[(d+1)][1];
                         queue[(d+1)][0] = temp0;
                         queue[(d+1)][1] = temp1;
                     }
                }
            }
            
            if (quePtr < queCtr) {
            /* Choose event from queue to do */
            for(b=0; b<ctr; b++) {
                if (b == queue[quePtr % MAX][0]) {
                /* this is the event to do */
                    snprintf (buf, 255, "%d", 1);
                    write(fd[b][1], &buf, sizeof(buf));             /* Handled 1 hour */
                    
                    /* Declear event to time interval */
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get eventName from child */
                    strcpy(cal[a][1], buf2);
                    
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get remain from child */
                    /* Remain = 0, Event is finished */
                    if (atoi(buf2) == 0) {
                        eventEnd = 1;
                    }
                } else {
                /* this event is waiting */
                    snprintf (buf, 255, "%d", 0);
                    write(fd[b][1], &buf, sizeof(buf));             /* Handled 0 hour */
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get remain from child */
                }
            }
            } else {
                for(b=0; b<ctr; b++) {
                snprintf (buf, 255, "%d", -1);
                write(fd[b][1], &buf, sizeof(buf));                 /* Handled 0 hour */
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get remain from child */
                }
            }
            
            /* Current event ended */
            if (eventEnd == 1) {
                quePtr++;
            }
        }

    }
/* ======================================================================= */
    
    else if (algorithm == 4) {
        
        int robConst = atoi(arg3);
        int robCount = robConst;
        
        for(a=0; a<duration; a++) {
            
            eventEnd = 0;
            
            /* Pass time to child */
            strcpy(buf, cal[a][0]);
            for(b=0; b<ctr; b++) {
                write(fd[b][1], &buf, sizeof(buf));
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get status from child */
                strcpy(status, buf2);
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get length from child */
                
                /* Child want to enter queue */
                if (strcmp(status, "BEGIN") == 0) {
                    queue[queCtr % MAX][0] = b;
                    queue[queCtr % MAX][1] = atoi(buf2);
                    queCtr++;
                }
            }
            
            if (quePtr < queCtr) {
            /* Choose event from queue to do */
            for(b=0; b<ctr; b++) {
                if (b == queue[quePtr % MAX][0]) {
                /* this is the event to do */
                    snprintf (buf, 255, "%d", 1);
                    write(fd[b][1], &buf, sizeof(buf));             /* Handled 1 hour */
                    
                    /* Declear event to time interval */
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get eventName from child */
                    strcpy(cal[a][1], buf2);
                    
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get remain from child */
                    /* Remain = 0, Event is finished */
                    if (atoi(buf2) == 0) {
                        eventEnd = 1;
                    }
                } else {
                /* this event is waiting */
                    snprintf (buf, 255, "%d", 0);
                    write(fd[b][1], &buf, sizeof(buf));             /* Handled 0 hour */
                    read(fd2[b][0], &buf2, sizeof(buf2));           /* Get remain from child */
                }
            }
            } else {
                for(b=0; b<ctr; b++) {
                snprintf (buf, 255, "%d", -1);
                write(fd[b][1], &buf, sizeof(buf));                 /* Handled 0 hour */
                read(fd2[b][0], &buf2, sizeof(buf2));               /* Get remain from child */
                }
            }
            
            robCount--;
            if ((robCount == 0) && (eventEnd == 0)) {
                queue[queCtr % MAX][0] = queue[quePtr % MAX][0];
                queue[queCtr % MAX][1] = queue[quePtr % MAX][1];
                queCtr++;
                quePtr++;
                
                robCount = robConst;
            }
            
            /* Current event ended */
            if (eventEnd == 1) {
                quePtr++;
                robCount = robConst;   
            }
        }
    }
/* ======================================================================= */
    else {
        printf("ERROR. Please restart. \n");
        exit(1);
    }

/* ======================================================================= */
/* ======================================================================= */
/* ======================================================================= */
    
    /* Output */
    
    /* Read info from child */
    char evtName[255];
    char evtDateTime[10];
    char evtRemain[10];
    char evtTurnaround[10];
    char evtLength[10];
    
    int totalEvent = ctr;
    int sumTurnaround = 0;
    int sumWaiting = 0;
    
    /* Print Calender */
    printf("Period of Calender: ");
    strFromDateTime(begDateTime);
    printf(" to ");
    strFromDateTime(endDateTime);
    printf(" \n");
    outputCal(arg7, duration, cal, begDateTime, endDateTime);
    
    /* Print Performance Report */
    /* Output will be displayed in FILE */
    
    printf("\n");
    printf("\n");
    printf("\n");
    printf("\n");
    printf("\n");
    printf("SUMMARY: \n");
    printf("----------------------------------------------------------- \n");
    printf("\n");
    printf("START                 END                   TURNAROUND TIME \n");
    printf("----------------------------------------------------------- \n");
    
    for(x=0; x<ctr; x++) {
        read(fd2[x][0], &buf2, sizeof(buf2));                       /* Get eventName from child */
        strcpy(evtName, buf2);
        read(fd2[x][0], &buf2, sizeof(buf2));                       /* Get begDateTime from child */
        strcpy(evtDateTime, buf2);
        read(fd2[x][0], &buf2, sizeof(buf2));                       /* Get remain from child */
        strcpy(evtRemain, buf2);
        read(fd2[x][0], &buf2, sizeof(buf2));                       /* Get turnaround from child */
        strcpy(evtTurnaround, buf2);
        read(fd2[x][0], &buf2, sizeof(buf2));                       /* Get length from child */
        strcpy(evtLength, buf2);
        
        if (atoi(evtRemain) == 0) {
            printf("%s \n", evtName);
        
            strFromDateTime(atoi(evtDateTime));
            printf("     ");
            strFromDateTime(atoi(evtDateTime)+(atoi(evtTurnaround)*3600));
            printf("     ");
            printf("%s \n", evtTurnaround);
            printf("----------------------------------------------------------- \n");
            
            sumTurnaround += atoi(evtTurnaround);
            sumWaiting += (atoi(evtTurnaround) - atoi(evtLength));
        } else {
            totalEvent--;
        }
    }
    printf("\n");
    printf("%d events is handled. \n", totalEvent);
    double avgTurnaround = sumTurnaround/totalEvent;
    printf("Average Turnaround Time = %f Hours\n", avgTurnaround);
    double avgWaiting = sumWaiting/totalEvent;
    printf("Average Waiting Time = %f Hours\n", avgWaiting);
    
    
    printf("\n");
    printf("\n");
    printf("%d events is rejected. \n", ctr-totalEvent);
    
    for(x=0; x<ctr; x++) {
        read(fd2[x][0], &buf2, sizeof(buf2));                       /* Get eventName from child */
        strcpy(evtName, buf2);
        read(fd2[x][0], &buf2, sizeof(buf2));                       /* Get remain from child */
        strcpy(evtRemain, buf2);
        
        if (atoi(evtRemain) > 0) {
            printf("%s \n", evtName);
        }
    }
    
/* ======================================================================= */
    
    /* Close all pipe */
    for(y=0; y<ctr; y++) {
        close(fd[y][1]);                                            /* Close write descriptor of fd */
        close(fd2[y][0]);                                           /* Close read descriptor of fd2 */
    }

/* ======================================================================= */
    
    /* The following code WAIT all child process to finish */
    /* Source from: http://stackoverflow.com/questions/876605/multiple-child-process */
    /* Edited to apply in COMP2432 Project */
    int cst;
    pid_t cid;
    z = ctr;
    while (z > 0) {                                                 /* From hop down to 0 */
        cid = wait(&cst);
        --z;
    }
    /* Referenced part ends */
    
    fprintf(stderr, "PROGRAM TERMINATES \n");
}

/* ======================================================================= */
/* ======================================================================= */