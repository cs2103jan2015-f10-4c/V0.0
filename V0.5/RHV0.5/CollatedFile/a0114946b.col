//@author: a0114946b



	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\IntegratedTest.cpp
	 */


#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;
const string DEFAULT_TYPE_ONE = "timed";
const string DEFAULT_TYPE_TWO = "deadline";
const string DEFAULT_TYPE_THREE = "floating";


namespace sysTest
{		
	TEST_CLASS(IntegrationTest)
	{
	public:
		
		TEST_METHOD(test_add1)
		{
			Logic* logic = new Logic();
			string userCommand;
			
			//test for timed task
			userCommand = "add;tutorial;01-01-2015 0900;01-01-2015 1000";
			logic->executeUserCommand(userCommand);
			string taskName = "tutorial";
			string startTime = "01-01-2015 09:00";
			string endTime = "01-01-2015 10:00";
			string type = DEFAULT_TYPE_ONE;
			Assert::IsTrue(logic->taskList[0].taskName == taskName);
			Assert::IsTrue(logic->taskList[0].startingTime == startTime);
			Assert::IsTrue(logic->taskList[0].endingTime == endTime);
			Assert::IsTrue(logic->taskList[0].type == type);

			string output = logic->tellGUIResponse();
			string expectedOutput = "The task is added successfully.";
			Assert::AreEqual(output, expectedOutput);

			//test for deadline task
			userCommand = "add;assignment;02-02-2015 2359";
			logic->executeUserCommand(userCommand);
			taskName = "assignment";
			startTime = "";
			endTime = "02-02-2015 23:59";
			type = DEFAULT_TYPE_TWO;
			Assert::IsTrue(logic->taskList[1].taskName == taskName);
			Assert::IsTrue(logic->taskList[1].startingTime == startTime);
			Assert::IsTrue(logic->taskList[1].endingTime == endTime);
			Assert::IsTrue(logic->taskList[1].type == type);

			output = logic->tellGUIResponse();
			expectedOutput = "The task is added successfully.";
			Assert::AreEqual(output, expectedOutput);

			//test for floating task
			userCommand = "add;meeting";
			logic->executeUserCommand(userCommand);
			taskName = "meeting";
			startTime = "";
			endTime = "";
			type = DEFAULT_TYPE_THREE;
			Assert::IsTrue(logic->taskList[2].taskName == taskName);
			Assert::IsTrue(logic->taskList[2].startingTime == startTime);
			Assert::IsTrue(logic->taskList[2].endingTime == endTime);
			Assert::IsTrue(logic->taskList[2].type == type);

			output = logic->tellGUIResponse();
			expectedOutput = "The task is added successfully.";
			Assert::AreEqual(output, expectedOutput);
		}

		TEST_METHOD(test_add2)
		{
			Logic testLogic;
			string userCommand;

			//add command invalid
			userCommand = "add2";
			testLogic.executeUserCommand(userCommand);
			int size = testLogic.taskList.size();
			int expectedSize = 0;

			Assert::AreEqual(size, expectedSize);
			string output = testLogic.tellGUIResponse();
			string expectedOutput = "Command invalid, please re-enter.";
			Assert::AreEqual(output, expectedOutput);

			//add format invalid
			userCommand = "add;";
			testLogic.executeUserCommand(userCommand);
			size = testLogic.taskList.size();
			expectedSize = 0;

			Assert::AreEqual(size, expectedSize);
			output = testLogic.tellGUIResponse();
			expectedOutput = "Failed to add task. Please enter in the correct format.";
			Assert::AreEqual(output, expectedOutput);

			//add timing invalid
			userCommand = "add;meeting;11may;10may";
			testLogic.executeUserCommand(userCommand);
			size = testLogic.taskList.size();
			expectedSize = 0;
			Assert::AreEqual(size, expectedSize);

			output = testLogic.tellGUIResponse();
			expectedOutput = "Failed to add task. Starting time is later than ending time.";
			Assert::AreEqual(output, expectedOutput);

			
		}

		TEST_METHOD(test_delete1)
		{
			Logic testLogic;
			string task1 = "add;assignment;11may2015 23:59";
			string task2 = "add;reply email";
			string task3 = "add;lecture;10may2015 1030am;10may2015 1130am";

			testLogic.executeUserCommand(task1);
			testLogic.executeUserCommand(task2);
			testLogic.executeUserCommand(task3);

			//delete index is out of range
			string userCommand = "delete;10";
			testLogic.executeUserCommand(userCommand);
			
			int size = testLogic.taskList.size();
			int expectedSize = 3;
			Assert::AreEqual(size, expectedSize);

			string output = testLogic.tellGUIResponse();
			string expectedOutput = "Failed to delete the task. Task \"10\" is not in the list.";
			Assert::AreEqual(output, expectedOutput);
			
			//delete deadline task
			userCommand = "delete;1";
			testLogic.executeUserCommand(userCommand);

			size = testLogic.taskList.size();
			expectedSize = 2;
			Assert::AreEqual(size, expectedSize);

			Assert::IsTrue(testLogic.taskList[0].taskName == "reply email");
			Assert::IsTrue(testLogic.taskList[0].type == DEFAULT_TYPE_THREE);

			Assert::IsTrue(testLogic.taskList[1].taskName == "lecture");
			Assert::IsTrue(testLogic.taskList[1].startingTime == "10-05-2015 10:30");
			Assert::IsTrue(testLogic.taskList[1].endingTime == "10-05-2015 11:30");
			Assert::IsTrue(testLogic.taskList[1].type == DEFAULT_TYPE_ONE);

			output = testLogic.tellGUIResponse();
			expectedOutput = "Task 1 is deleted successfully.";
			Assert::AreEqual(output, expectedOutput);

			//test for undo 
			userCommand = "undo";
			testLogic.executeUserCommand(userCommand);
			size = testLogic.taskList.size();
			expectedSize = 3;
			Assert::AreEqual(size, expectedSize);

			Assert::IsTrue(testLogic.taskList[0].taskName == "assignment");
			Assert::IsTrue(testLogic.taskList[0].endingTime == "11-05-2015 23:59");
			Assert::IsTrue(testLogic.taskList[0].type == DEFAULT_TYPE_TWO);
			
			Assert::IsTrue(testLogic.taskList[1].taskName == "reply email");
			Assert::IsTrue(testLogic.taskList[1].type == DEFAULT_TYPE_THREE);

			Assert::IsTrue(testLogic.taskList[2].taskName == "lecture");
			Assert::IsTrue(testLogic.taskList[2].startingTime == "10-05-2015 10:30");
			Assert::IsTrue(testLogic.taskList[2].endingTime == "10-05-2015 11:30");
			Assert::IsTrue(testLogic.taskList[2].type == DEFAULT_TYPE_ONE);

			output = testLogic.tellGUIResponse();
			expectedOutput = "Undo successful.";
			Assert::AreEqual(output, expectedOutput);

			//delete floating task
			userCommand = "delete;2";
			testLogic.executeUserCommand(userCommand);

			size = testLogic.taskList.size();
			expectedSize = 2;
			Assert::AreEqual(size, expectedSize);

			Assert::IsTrue(testLogic.taskList[0].taskName == "assignment");
			Assert::IsTrue(testLogic.taskList[0].endingTime == "11-05-2015 23:59");
			Assert::IsTrue(testLogic.taskList[0].type == DEFAULT_TYPE_TWO);

			Assert::IsTrue(testLogic.taskList[1].taskName == "lecture");
			Assert::IsTrue(testLogic.taskList[1].startingTime == "10-05-2015 10:30");
			Assert::IsTrue(testLogic.taskList[1].endingTime == "10-05-2015 11:30");
			Assert::IsTrue(testLogic.taskList[1].type == DEFAULT_TYPE_ONE);

			output = testLogic.tellGUIResponse();
			expectedOutput = "Task 2 is deleted successfully.";
			Assert::AreEqual(output, expectedOutput);

			userCommand = "undo";
			testLogic.executeUserCommand(userCommand);
			size = testLogic.taskList.size();
			expectedSize = 3;
			Assert::AreEqual(size, expectedSize);

			Assert::IsTrue(testLogic.taskList[0].taskName == "assignment");
			Assert::IsTrue(testLogic.taskList[0].endingTime == "11-05-2015 23:59");
			Assert::IsTrue(testLogic.taskList[0].type == DEFAULT_TYPE_TWO);
			
			Assert::IsTrue(testLogic.taskList[1].taskName == "reply email");
			Assert::IsTrue(testLogic.taskList[1].type == DEFAULT_TYPE_THREE);

			Assert::IsTrue(testLogic.taskList[2].taskName == "lecture");
			Assert::IsTrue(testLogic.taskList[2].startingTime == "10-05-2015 10:30");
			Assert::IsTrue(testLogic.taskList[2].endingTime == "10-05-2015 11:30");
			Assert::IsTrue(testLogic.taskList[2].type == DEFAULT_TYPE_ONE);

			output = testLogic.tellGUIResponse();
			expectedOutput = "Undo successful.";
			Assert::AreEqual(output, expectedOutput);

			//delete timed task
			userCommand = "delete;3";
			testLogic.executeUserCommand(userCommand);

			size = testLogic.taskList.size();
			expectedSize = 2;
			Assert::AreEqual(size, expectedSize);

			Assert::IsTrue(testLogic.taskList[0].taskName == "assignment");
			Assert::IsTrue(testLogic.taskList[0].endingTime == "11-05-2015 23:59");
			Assert::IsTrue(testLogic.taskList[0].type == DEFAULT_TYPE_TWO);

			Assert::IsTrue(testLogic.taskList[1].taskName == "reply email");
			Assert::IsTrue(testLogic.taskList[1].type == DEFAULT_TYPE_THREE);

			output = testLogic.tellGUIResponse();
			expectedOutput = "Task 3 is deleted successfully.";
			Assert::AreEqual(output, expectedOutput);

			userCommand = "undo";
			testLogic.executeUserCommand(userCommand);

			output = testLogic.tellGUIResponse();
			expectedOutput = "Undo successful.";
			Assert::AreEqual(output, expectedOutput);
			

		}

		TEST_METHOD(test_clear)
		{
			Logic testLogic;
			string task1 = "add;assignment;11may2015 23:59";
			string task2 = "add;reply email";
			string task3 = "add;lecture;10may2015 1030am;10may2015 1130am";

			testLogic.executeUserCommand(task1);
			testLogic.executeUserCommand(task2);
			testLogic.executeUserCommand(task3);

			int size = testLogic.taskList.size();
			int expectedSize = 3;
			Assert::AreEqual(size, expectedSize);

			string userCommand = "clear";
			testLogic.executeUserCommand(userCommand);

			size = testLogic.taskList.size();
			expectedSize = 0;
			Assert::AreEqual(size, expectedSize);

			string output = testLogic.tellGUIResponse();
			string expectedOutput = "The task list has been cleared.";
			Assert::AreEqual(output, expectedOutput);

		}

		TEST_METHOD(test_UndoRedo)
		{
			Logic testLogic;
			string userCommand;

			string task1 = "add;assignment;11may2015 23:59";
			
			testLogic.executeUserCommand(task1);
			int size = testLogic.taskList.size();
			int expectedSize = 1;
			Assert::AreEqual(size, expectedSize);

			//test for redo fail case
			userCommand = "redo";
			testLogic.executeUserCommand(userCommand);
			string output = testLogic.tellGUIResponse();
			string expectedOutput = "Failed to redo. No undo action performed.";
			Assert::AreEqual(output, expectedOutput);

			//test for undo success case
			userCommand = "undo";
			testLogic.executeUserCommand(userCommand);

			size = testLogic.taskList.size();
			expectedSize = 0;
			Assert::AreEqual(size, expectedSize);
			output = testLogic.tellGUIResponse();
			expectedOutput = "Undo successful.";
			Assert::AreEqual(output, expectedOutput);

			//test for undo fail case
			userCommand = "undo";
			testLogic.executeUserCommand(userCommand);

			output = testLogic.tellGUIResponse();
			expectedOutput = "Failed to undo. Exceed number of actions performed.";
			Assert::AreEqual(output, expectedOutput);

			//test for redo success case
			userCommand = "redo";
			testLogic.executeUserCommand(userCommand);
			output = testLogic.tellGUIResponse();
			expectedOutput = "Redo successful.";
			Assert::AreEqual(output, expectedOutput);

			size = testLogic.taskList.size();
			expectedSize = 1;
			Assert::AreEqual(size, expectedSize);

		}

	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\IntegratedTest.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\unittestHistory.cpp
	 */


#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTesthistory
{		
	TEST_CLASS(UnitTestHistory)
	{
	public:
		
		TEST_METHOD(testUndoRedo)
		{
			Task testTask1;
			testTask1.setTaskName("ABC");
			testTask1.setStartingTime ("0000");
			testTask1.setEndingTime ("2359");
			testTask1.setDone ("DONE");

			Task testTask2;
			testTask2.setTaskName("AAA");
			testTask2.setStartingTime ("1111");
			testTask2.setEndingTime ("2200");
			testTask2.setDone ("DONE");

			Task testTask3;
			testTask3.setTaskName("BBB");
			testTask3.setStartingTime ("1000");
			testTask3.setEndingTime ("2100");
			testTask3.setDone ("ONGOING");

			vector<Task> taskList1;
			vector<Task> taskList2;
			taskList1.push_back(testTask1);
			taskList1.push_back(testTask2);
			taskList2.push_back(testTask1);
			taskList2.push_back(testTask2);
			taskList2.push_back(testTask3);

			int size1 = taskList1.size();
			int size2 = taskList2.size();
			Assert::AreEqual(size1, 2);
			Assert::AreEqual(size2, 3);
			
			//taskList1 obtained by operation1 after first command
			//taskList2 obtained by operation2 after second command
			History histryStorage;
			histryStorage.saveOperation(taskList1);
			histryStorage.saveOperation(taskList2);
			
			//undo stack should have 2 tasklists
			stack <vector<Task>> undoStack;
			undoStack = histryStorage.getUndoStorageList();
			int size3 = undoStack.size();
			Assert::AreEqual(size3, 2);

			vector<Task> newTaskList;
			newTaskList = histryStorage.undo();
			undoStack = histryStorage.getUndoStorageList();
			int size4 = undoStack.size();
			Assert::AreEqual(size4, 1);
			
			stack <vector<Task>> redoStack;
			redoStack = histryStorage.getRedoStorageList();
			int size5 = redoStack.size();
			Assert::AreEqual(size5, 1);

			//after one undo, taskList obtained should be same as the tasklist1 
			Assert::IsTrue(newTaskList[0].taskName == taskList1[0].taskName);
			Assert::IsTrue(newTaskList[0].startingTime == taskList1[0].startingTime);
			Assert::IsTrue(newTaskList[0].endingTime == taskList1[0].endingTime);
			Assert::IsTrue(newTaskList[0].status == taskList1[0].status);

			Assert::IsTrue(newTaskList[1].taskName == taskList1[1].taskName);
			Assert::IsTrue(newTaskList[1].startingTime == taskList1[1].startingTime);
			Assert::IsTrue(newTaskList[1].endingTime == taskList1[1].endingTime);
			Assert::IsTrue(newTaskList[1].status == taskList1[1].status);

			//after 2 undo, undo stack should be empty
			newTaskList = histryStorage.undo();
			undoStack = histryStorage.getUndoStorageList();
			size4 = undoStack.size();
			Assert::AreEqual(size4, 0);
			redoStack = histryStorage.getRedoStorageList();
			size5 = redoStack.size();
			Assert::AreEqual(size5, 2);
			
			//after one redo
			newTaskList = histryStorage.redo();
			int size6 = newTaskList.size();
			Assert::AreEqual(size6, 2);
			redoStack = histryStorage.getRedoStorageList();
			size5 = redoStack.size();
			Assert::AreEqual(size5, 1);

			//after one redo, taskList obtained should be same as the tasklist1 
			Assert::IsTrue(newTaskList[0].taskName == taskList1[0].taskName);
			Assert::IsTrue(newTaskList[0].startingTime == taskList1[0].startingTime);
			Assert::IsTrue(newTaskList[0].endingTime == taskList1[0].endingTime);
			Assert::IsTrue(newTaskList[0].status == taskList1[0].status);

			Assert::IsTrue(newTaskList[1].taskName == taskList1[1].taskName);
			Assert::IsTrue(newTaskList[1].startingTime == taskList1[1].startingTime);
			Assert::IsTrue(newTaskList[1].endingTime == taskList1[1].endingTime);
			Assert::IsTrue(newTaskList[1].status == taskList1[1].status);

			newTaskList = histryStorage.redo();
			size6 = newTaskList.size();
			Assert::AreEqual(size6, 3);

			//after two redo, taskList obtained should be same as the tasklist2 
			Assert::IsTrue(newTaskList[0].taskName == taskList2[0].taskName);
			Assert::IsTrue(newTaskList[0].startingTime == taskList2[0].startingTime);
			Assert::IsTrue(newTaskList[0].endingTime == taskList2[0].endingTime);
			Assert::IsTrue(newTaskList[0].status == taskList2[0].status);

			Assert::IsTrue(newTaskList[1].taskName == taskList2[1].taskName);
			Assert::IsTrue(newTaskList[1].startingTime == taskList2[1].startingTime);
			Assert::IsTrue(newTaskList[1].endingTime == taskList2[1].endingTime);
			Assert::IsTrue(newTaskList[1].status == taskList2[1].status);

			Assert::IsTrue(newTaskList[2].taskName == taskList2[2].taskName);
			Assert::IsTrue(newTaskList[2].startingTime == taskList2[2].startingTime);
			Assert::IsTrue(newTaskList[2].endingTime == taskList2[2].endingTime);
			Assert::IsTrue(newTaskList[2].status == taskList2[2].status);

			redoStack = histryStorage.getRedoStorageList();
			undoStack = histryStorage.getUndoStorageList();
			size5 = redoStack.size();
			size4 = undoStack.size();
			Assert::AreEqual(size5, 0);
			Assert::AreEqual(size4, 2);
		}

		TEST_METHOD(testCheckUndoEmpty)
		{
			vector<Task> newTaskList;
			
			Task testTask1;
			testTask1.setTaskName("ABC");
			testTask1.setStartingTime ("0000");
			testTask1.setEndingTime ("2359");
			testTask1.setDone ("DONE");
			newTaskList.push_back(testTask1);
			
			History historyStorage;
			Assert::IsTrue(historyStorage.checkUndoEmpty() == false);

			historyStorage.saveOperation(newTaskList);
			Assert::IsTrue(historyStorage.checkUndoEmpty() == true);
			
		}

		TEST_METHOD(testCheckRedoEmpty)
		{
			History historyStorage;
			Assert::IsTrue (historyStorage.checkRedoEmpty() == false);

			vector<Task> testTaskList1;
			vector<Task> testTaskList2;
			Task testTask1;
			testTask1.setTaskName("ABC");
			testTask1.setStartingTime ("0000");
			testTask1.setEndingTime ("2359");
			testTask1.setDone ("DONE");
			testTaskList1.push_back(testTask1);
			historyStorage.saveOperation(testTaskList1);

			Task testTask2;
			testTask2.setTaskName("AAA");
			testTask2.setStartingTime ("1111");
			testTask2.setEndingTime ("2200");
			testTask2.setDone ("DONE");
			testTaskList2.push_back(testTask1);
			testTaskList2.push_back(testTask2);
			historyStorage.saveOperation(testTaskList2);
			
			vector<Task> newTaskList;
			newTaskList = historyStorage.undo();
			Assert::IsTrue (historyStorage.checkRedoEmpty() == true);
		
		}

	};
}
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\unittestHistory.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\unittestStorage.cpp
	 */


#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

const string TASK_NAME = "ABC";
const string STARTING_TIME = "0001";
const string ENDING_TIME = "2359";
const string STATUS = "DONE";

const string TEST_TIMED_TASK = "1. meeting ;  2012-01-01 1000 ; 2012-01-01 1300 ; Done";
const string TEST_DEADLINE_TASK = "2. assignment ; 2012-01-01 1300 ; Ongoing";
const string TEST_FLOATING_TASK = "3. reply email ; Ongoing";


namespace UnitTeststorage
{		
	TEST_CLASS(UnitTestStorage)
	{
	public:
		
	
		TEST_METHOD(testRemoveIndex)
		{
			Storage fileStorage;

			string testInput;
			testInput = TEST_TIMED_TASK;
			string testOutput;
			testOutput = fileStorage.removeIndex(testInput);
			Assert::IsTrue(testOutput == " meeting ;  2012-01-01 1000 ; 2012-01-01 1300 ; Done");

			testInput = TEST_DEADLINE_TASK;
			testOutput = fileStorage.removeIndex(testInput);
			Assert::IsTrue(testOutput == " assignment ; 2012-01-01 1300 ; Ongoing");

			testInput = TEST_FLOATING_TASK;
			testOutput = fileStorage.removeIndex(testInput);
			Assert::IsTrue(testOutput == " reply email ; Ongoing");

		}
		
		TEST_METHOD(testGetTaskName)
		{
			Storage fileStorage;

			string testInput;
			string testOutput;
			
			testInput = TEST_TIMED_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getTaskName(testInput);
			Assert::IsTrue(testOutput == "meeting");

			testInput = TEST_DEADLINE_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getTaskName(testInput);
			Assert::IsTrue(testOutput == "assignment");

			testInput = TEST_FLOATING_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getTaskName(testInput);
			Assert::IsTrue(testOutput == "reply email");

		}

		TEST_METHOD(testGetStartingTime)
		{
			Storage fileStorage;

			string testInput;
			string testOutput;

			testInput = TEST_TIMED_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getStartingTime(testInput);
			Assert::IsTrue(testOutput == "2012-01-01 1000");
		}

		TEST_METHOD(testGetEndingTime)
		{
			Storage fileStorage;

			string testInput;
			string testOutput;

			testInput = TEST_TIMED_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getEndingTime(testInput);
			Assert::IsTrue(testOutput == "2012-01-01 1300");
		}

		TEST_METHOD(testGetDueTime)
		{
			Storage fileStorage;

			string testInput;
			string testOutput;

			testInput = TEST_DEADLINE_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getDueTime(testInput);
			Assert::IsTrue(testOutput == "2012-01-01 1300");
		}

		TEST_METHOD(testGetStatus)
		{
			Storage fileStorage;

			string testInput;
			string testOutput;

			testInput = TEST_TIMED_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getStatus(testInput);
			Assert::IsTrue(testOutput == "Done");

			testInput = TEST_DEADLINE_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getStatus(testInput);
			Assert::IsTrue(testOutput == "Ongoing");

			testInput = TEST_FLOATING_TASK;
			testInput = fileStorage.removeIndex(testInput);
			testOutput = fileStorage.getStatus(testInput);
			Assert::IsTrue(testOutput == "Ongoing");
		}

		TEST_METHOD(testLoadTask)
		{
			Storage fileStorage;
			vector<string> testTaskLine;
			vector<Task> testTaskList;
			string trashTask = "Task has not been typed";

			testTaskLine.push_back(TEST_TIMED_TASK);
			testTaskLine.push_back(TEST_DEADLINE_TASK);
			testTaskLine.push_back(TEST_FLOATING_TASK);
			testTaskLine.push_back(trashTask);

			//trash task should not be retrieved into taskList
			fileStorage.loadTask(testTaskLine,testTaskList);
			int tasklistSize = testTaskList.size();
			int expectedSize = 3;
			Assert::IsTrue(tasklistSize == expectedSize);

			string expectedTimedTaskName = "meeting";
			string expectedTimedTaskStartTime = "2012-01-01 1000";
			string expectedTimedTaskEndTime = "2012-01-01 1300";
			string expectedTimedTaskStatus = "Done";
			string expectedTimedTaskType = "timed";

			Assert::IsTrue(testTaskList[0].taskName == expectedTimedTaskName);
			Assert::IsTrue(testTaskList[0].startingTime == expectedTimedTaskStartTime);
			Assert::IsTrue(testTaskList[0].endingTime == expectedTimedTaskEndTime);
			Assert::IsTrue(testTaskList[0].status == expectedTimedTaskStatus);
			Assert::IsTrue(testTaskList[0].type == expectedTimedTaskType);

			string expectedDeadlineTaskName = "assignment";
			string expectedDeadlineTaskDueTime = "2012-01-01 1300";
			string expectedDeadlineTaskStatus = "Ongoing";
			string expectedDeadlineTaskType = "deadline";

			Assert::IsTrue(testTaskList[1].taskName == expectedDeadlineTaskName);
			Assert::IsTrue(testTaskList[1].endingTime == expectedDeadlineTaskDueTime);
			Assert::IsTrue(testTaskList[1].status == expectedDeadlineTaskStatus);
			Assert::IsTrue(testTaskList[1].type == expectedDeadlineTaskType);

			string expectedFloatingTaskName = "reply email";
			string expectedFloatingTaskStatus = "Ongoing";
			string expectedFloatingTaskType = "floating";
			
			Assert::IsTrue(testTaskList[2].taskName == expectedFloatingTaskName);
			Assert::IsTrue(testTaskList[2].status == expectedFloatingTaskStatus);
			Assert::IsTrue(testTaskList[2].type == expectedFloatingTaskType);

		}

		TEST_METHOD(testGetOutFilePath)
		{
			Storage testStorage;
			
			string outFilePath;
			outFilePath = "abc";
			
			testStorage.setOutFilePath(outFilePath);
			string expectedOutFilePath = testStorage.getOutfilePath();
			Assert::IsTrue(outFilePath == expectedOutFilePath);

		}

		
		TEST_METHOD(testGetUserInputPath)
		{
			Storage testStorage;
			
			string userInputPath;
			userInputPath = "abc";
			
			testStorage.setUserInputPath(userInputPath);
			string expecteduserInputPath = testStorage.getUserInputPath();
			Assert::IsTrue(userInputPath == expecteduserInputPath);

		}

		TEST_METHOD(testHasDirectory)
		{
			Storage testStorage;
			
			string testPath1 = "myAppConfig.txt";
			ifstream readFile;
			readFile.open(testPath1.c_str());
			string testLine1;
			getline(readFile, testLine1);

			if(testStorage.hasDirectory() == true){
				string testPath2 = "myAppConfig.txt";
				ifstream file;
				file.open(testPath2.c_str());
				string testLine2;
				getline(file, testLine2);

				Assert::IsTrue(testLine1 == testLine2);
			}
			else{
				bool test = testStorage.hasDirectory();
				bool expectedOutcome = false;
				
				Assert::IsTrue(test == expectedOutcome);
			}

		}

		TEST_METHOD(testRetrieveTimedTask)
		{
			Storage testStorage;

			string task1 = " project ; 04-03-2015 1400 ; 04-03-2015 1600 ; Ongoing";
			string task2 = " lunch with Jim ; 10-03-2015 1800 ; 10-03-2015 2100 ; Done";
			string task3 = " lecture ; 03-03-2015 1000 ; 03-03-2015 1200 ; Overdue";

			vector<Task> testTaskList; 
			testStorage.retrieveTimedTask(task1, testTaskList);

			string expectedTimedTaskName = "project";
			string expectedTimedTaskStartTime = "04-03-2015 1400";
			string expectedTimedTaskEndTime = "04-03-2015 1600";
			string expectedTimedTaskStatus = "Ongoing";
			string expectedTimedTaskType = "timed";
			
			Assert::IsTrue(testTaskList[0].taskName == expectedTimedTaskName);
			Assert::IsTrue(testTaskList[0].startingTime == expectedTimedTaskStartTime);
			Assert::IsTrue(testTaskList[0].endingTime == expectedTimedTaskEndTime);
			Assert::IsTrue(testTaskList[0].status == expectedTimedTaskStatus);
			Assert::IsTrue(testTaskList[0].type == expectedTimedTaskType);

			testStorage.retrieveTimedTask(task2, testTaskList);

			expectedTimedTaskName = "lunch with Jim";
			expectedTimedTaskStartTime = "10-03-2015 1800";
			expectedTimedTaskEndTime = "10-03-2015 2100";
			expectedTimedTaskStatus = "Done";
			expectedTimedTaskType = "timed";
			
			Assert::IsTrue(testTaskList[1].taskName == expectedTimedTaskName);
			Assert::IsTrue(testTaskList[1].startingTime == expectedTimedTaskStartTime);
			Assert::IsTrue(testTaskList[1].endingTime == expectedTimedTaskEndTime);
			Assert::IsTrue(testTaskList[1].status == expectedTimedTaskStatus);
			Assert::IsTrue(testTaskList[1].type == expectedTimedTaskType);

			testStorage.retrieveTimedTask(task3, testTaskList);

			expectedTimedTaskName = "lecture";
			expectedTimedTaskStartTime = "03-03-2015 1000";
			expectedTimedTaskEndTime = "03-03-2015 1200";
			expectedTimedTaskStatus = "Overdue";
			expectedTimedTaskType = "timed";
			
			Assert::IsTrue(testTaskList[2].taskName == expectedTimedTaskName);
			Assert::IsTrue(testTaskList[2].startingTime == expectedTimedTaskStartTime);
			Assert::IsTrue(testTaskList[2].endingTime == expectedTimedTaskEndTime);
			Assert::IsTrue(testTaskList[2].status == expectedTimedTaskStatus);
			Assert::IsTrue(testTaskList[2].type == expectedTimedTaskType);

		}

		TEST_METHOD(testRetrieveDeadlineTask)
		{
			Storage testStorage;

			string task1 = " assignment ; 04-03-2015 1400 ; Done";
			string task2 = " tutorial ; 10-03-2015 2100 ; Ongoing";
			string task3 = " IE presentation ; 03-03-2015 1200 ; Overdue";

			vector<Task> testTaskList; 
			testStorage.retrieveDeadlineTask(task1, testTaskList);

			string expectedDeadlineTaskName = "assignment";
			string expectedDeadlineTaskStartTime = "";
			string expectedDeadlinedTaskEndTime = "04-03-2015 1400";
			string expectedDeadlineTaskStatus = "Done";
			string expectedDeadlineTaskType = "deadline";

			Assert::IsTrue(testTaskList[0].taskName == expectedDeadlineTaskName);
			Assert::IsTrue(testTaskList[0].startingTime == expectedDeadlineTaskStartTime);
			Assert::IsTrue(testTaskList[0].endingTime == expectedDeadlinedTaskEndTime);
			Assert::IsTrue(testTaskList[0].status == expectedDeadlineTaskStatus);
			Assert::IsTrue(testTaskList[0].type == expectedDeadlineTaskType);

			testStorage.retrieveDeadlineTask(task2, testTaskList);
			expectedDeadlineTaskName = "tutorial";
			expectedDeadlineTaskStartTime = "";
			expectedDeadlinedTaskEndTime = "10-03-2015 2100";
			expectedDeadlineTaskStatus = "Ongoing";
			expectedDeadlineTaskType = "deadline";

			Assert::IsTrue(testTaskList[1].taskName == expectedDeadlineTaskName);
			Assert::IsTrue(testTaskList[1].startingTime == expectedDeadlineTaskStartTime);
			Assert::IsTrue(testTaskList[1].endingTime == expectedDeadlinedTaskEndTime);
			Assert::IsTrue(testTaskList[1].status == expectedDeadlineTaskStatus);
			Assert::IsTrue(testTaskList[1].type == expectedDeadlineTaskType);

			testStorage.retrieveDeadlineTask(task3, testTaskList);
			expectedDeadlineTaskName = "IE presentation";
			expectedDeadlineTaskStartTime = "";
			expectedDeadlinedTaskEndTime = "03-03-2015 1200";
			expectedDeadlineTaskStatus = "Overdue";
			expectedDeadlineTaskType = "deadline";

			Assert::IsTrue(testTaskList[2].taskName == expectedDeadlineTaskName);
			Assert::IsTrue(testTaskList[2].startingTime == expectedDeadlineTaskStartTime);
			Assert::IsTrue(testTaskList[2].endingTime == expectedDeadlinedTaskEndTime);
			Assert::IsTrue(testTaskList[2].status == expectedDeadlineTaskStatus);
			Assert::IsTrue(testTaskList[2].type == expectedDeadlineTaskType);
		}

		TEST_METHOD(testRetrieveFloatingTask)
		{
			Storage testStorage;

			string task1 = " abc ; Done";
			string task2 = " 123 ; Ongoing";
			string task3 = " YYY ; Overdue";

			vector<Task> testTaskList;
			testStorage.retrieveFloatingTask(task1, testTaskList);
			
			string expectedFloatingTaskName = "abc";
			string expectedFloatingTaskStatus = "Done";
			string expectedFloatingTaskType = "floating";
			string expectedFloatingStartTime = "";
			string expectedFloatingEndTime = "";

			Assert::IsTrue(testTaskList[0].taskName == expectedFloatingTaskName);
			Assert::IsTrue(testTaskList[0].status == expectedFloatingTaskStatus);
			Assert::IsTrue(testTaskList[0].type == expectedFloatingTaskType);
			Assert::IsTrue(testTaskList[0].startingTime == expectedFloatingStartTime);
			Assert::IsTrue(testTaskList[0].endingTime == expectedFloatingEndTime);

			testStorage.retrieveFloatingTask(task2, testTaskList);
			expectedFloatingTaskName = "123";
			expectedFloatingTaskStatus = "Ongoing";
			expectedFloatingTaskType = "floating";
			expectedFloatingStartTime = "";
			expectedFloatingEndTime = "";

			Assert::IsTrue(testTaskList[1].taskName == expectedFloatingTaskName);
			Assert::IsTrue(testTaskList[1].status == expectedFloatingTaskStatus);
			Assert::IsTrue(testTaskList[1].type == expectedFloatingTaskType);
			Assert::IsTrue(testTaskList[1].startingTime == expectedFloatingStartTime);
			Assert::IsTrue(testTaskList[1].endingTime == expectedFloatingEndTime);

			testStorage.retrieveFloatingTask(task3, testTaskList);
			expectedFloatingTaskName = "YYY";
			expectedFloatingTaskStatus = "Overdue";
			expectedFloatingTaskType = "floating";
			expectedFloatingStartTime = "";
			expectedFloatingEndTime = "";

			Assert::IsTrue(testTaskList[2].taskName == expectedFloatingTaskName);
			Assert::IsTrue(testTaskList[2].status == expectedFloatingTaskStatus);
			Assert::IsTrue(testTaskList[2].type == expectedFloatingTaskType);
			Assert::IsTrue(testTaskList[2].startingTime == expectedFloatingStartTime);
			Assert::IsTrue(testTaskList[2].endingTime == expectedFloatingEndTime);

		}
		
		TEST_METHOD(testSaveFile)
		{
			Storage testStorage;
			string testFilePath = "testFile.txt";
			testStorage.setOutFilePath(testFilePath);
			
			//timed task
			Task testTask1;
			testTask1.setTaskName("ABC");
			testTask1.setStartingTime ("0000");
			testTask1.setEndingTime ("2359");
			testTask1.setDone ("DONE");
			testTask1.setType("timed");

			//deadline task
			Task testTask2;
			testTask2.setTaskName("AAA");
			testTask2.setStartingTime ("");
			testTask2.setEndingTime ("2200");
			testTask2.setDone ("DONE");
			testTask2.setType("deadline");

			//floating task
			Task testTask3;
			testTask3.setTaskName("BBB");
			testTask3.setStartingTime ("");
			testTask3.setEndingTime ("");
			testTask3.setDone ("ONGOING");
			testTask3.setType("floating");

			//task has not been specified type
			Task testTask4;
			testTask4.setTaskName("meeting");
			testTask3.setStartingTime ("");
			testTask3.setEndingTime ("");
			testTask3.setDone ("ONGOING");

			vector<Task> testTaskList;
			testTaskList.push_back(testTask1);
			testTaskList.push_back(testTask2);
			testTaskList.push_back(testTask3);
			testTaskList.push_back(testTask4);

			testStorage.saveFile(testTaskList);
			
			ifstream file(testFilePath.c_str());
			vector<string> testLine;
			string line;
			while(getline(file,line)){
				testLine.push_back(line);
			}
			int expectedSize = 5;
			
			Assert::IsTrue(testLine.size() == expectedSize);
			Assert::IsTrue(testLine[0] == " Tasklist: ");
			Assert::IsTrue(testLine[1] == "1. ABC ; 0000 ; 2359 ; DONE");
			Assert::IsTrue(testLine[2] == "2. AAA ; 2200 ; DONE");
			Assert::IsTrue(testLine[3] == "3. BBB ; ONGOING");
			Assert::IsTrue(testLine[4] == "Task has not been typed");

		}
	};
}

	
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\unittestStorage.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\History.cpp
	 */


#include <assert.h>
#include "History.h"
#include "Logger.h"

using namespace std;

const string UNABLE_UNDO = "it is unable to undo further";
const string ABLE_UNDO = "undo is successful";
const string UNABLE_REDO = "it is unable to redo further";
const string ABLE_REDO = "redo is successful";

//constructor
History::History(){
}

//destructor
History::~History(){
}


///////////////////
// Getter Method //
///////////////////
stack <vector<Task>> History::getUndoStorageList(){
	return _undoStorageList;
}

stack <vector<Task>> History::getRedoStorageList(){
	return _redoStorageList;
}

//save operation in term of every tasklist after each operation to the undo stack
//one vector of Task is one unit in the stack
//the newest tasklist after most recent operation will be at top of stack
void History::saveOperation(vector<Task>& taskStorage){
	_undoStorageList.push(taskStorage);

}

//undo an operation by users
//if undo is available, return the tasklist at previous command entered by users
//if undo is not available, retuen empty tasklist
vector<Task> History::undo(){
    
    vector<Task> updatedTaskList;
	RHLogger logFile = RHLogger::getInstance();
    
	//whether the undo stack is empty, undo is only available when it is not empty
	if (checkUndoEmpty() == true){

		//transfer the latest tasklist from undo stack to redo stack
        _redoStorageList.push(_undoStorageList.top());
		_undoStorageList.pop();
			
			//if only one operation made, undo returns empty
			//if not only one operation made, undo returns tasklist of previous state
			if (checkUndoEmpty() == false){
				logFile.addLog(UNABLE_UNDO);
				logFile.saveLog();
				return updatedTaskList;
			}
			else{
				updatedTaskList = _undoStorageList.top();
			}
		logFile.addLog(ABLE_UNDO);
		logFile.saveLog();	
        return updatedTaskList;
    }
	else{
		assert(checkUndoEmpty() == false);
		logFile.addLog(UNABLE_UNDO);
		logFile.saveLog();
		return updatedTaskList;
	}
}

//redo an operation after undo by users
//if redo is available, returns tasklist of state before last undo
//if redo is not availble, returns empty tasklist
vector<Task> History::redo(){
	
	vector<Task> updatedTaskList;
	RHLogger logFile = RHLogger::getInstance();

	//redo is available only when redo stack is not empty
	if (checkRedoEmpty() == true){
		
		updatedTaskList = _redoStorageList.top();
		
		//transfer tasklist back from redo stack to undo stack
		_undoStorageList.push(_redoStorageList.top());
		_redoStorageList.pop();

		logFile.addLog(ABLE_REDO);
		logFile.saveLog();
		return updatedTaskList;
	}
	else{
		assert(checkRedoEmpty() == false);
		logFile.addLog(UNABLE_REDO);
		logFile.saveLog();
		return updatedTaskList;
	}
}

//to determine whether undo stack is empty
//return true when it is not empty
//return false when it is empty
bool History::checkUndoEmpty(){
	bool undoStatus = false;

	if(!_undoStorageList.empty()){
		undoStatus = true;
		assert(undoStatus == true);
		return undoStatus;
	}
	else{
		assert(undoStatus == false);
		return undoStatus;
	}
}

//to determine whether redo stack is empty
//return true when it is not empty
//return false when it is empty
bool History::checkRedoEmpty(){
	bool redoStatus = false;

	if(!_redoStorageList.empty()){
		redoStatus = true;
		assert(redoStatus == true);
		return redoStatus;
	}
	else{
		assert(redoStatus == false);
		return redoStatus;
	}
}





	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\History.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\History.h
	 */


#ifndef HISTORY_H
#define HISTORY_H

#include <iostream>
#include <vector>
#include <string>
#include <stack>
#include "Task.h"

//History class is to save all operations done by the programme
//Every taskList generated after every operation will be saved in a vector of Task
//History performs undo and redo command for users
class History{
private:
	stack <vector<Task>> _undoStorageList;
	stack <vector<Task>> _redoStorageList;
	
public:
	History();
	~History();

	stack <vector<Task>> getUndoStorageList();
	stack <vector<Task>> getRedoStorageList();
	void saveOperation(vector<Task>&);
	vector<Task> undo();
	vector<Task> redo();
	bool checkUndoEmpty();
	bool checkRedoEmpty();
};

#endif


	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\History.h





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Storage.cpp
	 */


#include <sstream>
#include <fstream>
#include <algorithm>
#include <sys/stat.h>
#include <assert.h>
#include "Storage.h"
#include "Task.h"
#include "Logger.h"

using namespace std;

const string SAVE_FILE_MSG = "file is saved successfully";
const string READ_FILE_MSG = "file is retrieved successfully";
const string CREATE_FILE_MSG = "new file is created successfully";
const string TEXT_FILE_NAME = "rushhour.txt";
const string CONFIG_FILE_NAME = "myAppConfig.txt";
const string FILE_TITLE = " Tasklist: ";
const string DEFAULT_TIMED_TASK_TYPE = "timed";
const string DEFAULT_DEADLINE_TASK_TYPE = "deadline";
const string DEFAULT_FLOATING_TASK_TYPE = "floating";
const string INDEX_SPACER = ". ";
const string TASK_SPACER = " ; ";
const string DEFAULT_NO_TYPE_TASK_MSG = "Task has not been typed";
const string NEW_FILE_MSG = "Welcome";
const string INDEX_SEPERATOR = ".";
const string TASK_SEPERATOR = ";";
const char filePathSeparator =
#ifdef _WIN32
	'\\';
#else
	'/';
#endif


//constructor
Storage::Storage(){
}

//destructor
Storage::~Storage(){
}


///////////////////
// Getter Method //
///////////////////
string Storage::getOutfilePath(){
	return _outFilePath;
}

string Storage::getUserInputPath(){
	return _userInputPath;
}


///////////////////
// Setter Method //
///////////////////
void Storage::setOutFilePath(string outFilePath){
	_outFilePath = outFilePath;
}

//used to set user key-in input received by Logic as file path to be saved 
void Storage::setUserInputPath(string userInputPath){
	_userInputPath = userInputPath;
}

//check whether there is an existing file path for save .txt file in a Configuration file
//return true if file path is stored in the Configuration file and get the fiil path 
//return false if no file path stored in the Configuration file
bool Storage::hasDirectory(){
	bool directory = false;
	
	//this is the Configuration file, inside should only store one line, the file path to actual save .txt file
	string configPath = CONFIG_FILE_NAME; 
	
	ifstream configIn (configPath.c_str());
	if (configIn.is_open()){
		
		directory = true;
		assert(directory == true);
		
		//get and store the file path
		string line;
		if ( getline (configIn,line) ){
			_outFilePath = line;
		}
		configIn.close();
	}
	else{
		directory = false;
		assert(directory == false);
	}
	return directory;
}

//to save taskList passed from Logic by reference
//taskList is saveed after every operation, the current overwrites the previous taskList in the .txt file
//taskList is saved in user-defined location which stored in _outFilePath
void Storage::saveFile(vector<Task>& taskList){
	
	RHLogger logFile = RHLogger::getInstance();
	string filePath = getOutfilePath();
	
	//write file into user-defined location
	ofstream writeFile;
	writeFile.open(filePath.c_str());

	writeFile << FILE_TITLE << endl;

	for (unsigned i = 0; i < taskList.size(); i++){
		
		if(taskList[i].type == DEFAULT_TIMED_TASK_TYPE){
			writeFile << i + 1 << INDEX_SPACER;
			writeFile << taskList[i].taskName << TASK_SPACER;
			writeFile << taskList[i].startingTime << TASK_SPACER;
			writeFile << taskList[i].endingTime << TASK_SPACER;
			writeFile << taskList[i].status << endl;
		}
		else if(taskList[i].type == DEFAULT_DEADLINE_TASK_TYPE){
			writeFile << i + 1 << INDEX_SPACER;
			writeFile << taskList[i].taskName << TASK_SPACER;
			writeFile << taskList[i].endingTime << TASK_SPACER;
			writeFile << taskList[i].status << endl;
		}
		else if(taskList[i].type == DEFAULT_FLOATING_TASK_TYPE){
			writeFile << i + 1 << INDEX_SPACER;
			writeFile << taskList[i].taskName << TASK_SPACER;
			writeFile << taskList[i].status << endl;
		}
		else{
			writeFile << DEFAULT_NO_TYPE_TASK_MSG << endl;
		}
		
	}
	
	logFile.addLog(SAVE_FILE_MSG);
	logFile.saveLog();
	writeFile.close();
}

//to retrieve file from local .txt file if there is existing file
//to create new file at given directory if there is no existing file
void Storage::readFile(vector<Task>& taskList){
	
	string filePath;
	vector<string> tempTask;
	RHLogger logFile = RHLogger::getInstance();
	
	//there is an existing file
	if(hasDirectory() == true){
		
		assert(hasDirectory() == true);
		filePath = getOutfilePath();
		
		ifstream file;
		string taskLine;
		string titleLine;

		file.open(filePath.c_str());
		tempTask.clear();
		
		//remove the tile line at start of .txt file
		getline(file, titleLine);
		
		//get each line as one whole string
		while (getline(file, taskLine)){
			tempTask.push_back(taskLine);
		}
		
		//partition the whole string accordingly and pass to Logic to store in taskList
		loadTask(tempTask, taskList);

		logFile.addLog(READ_FILE_MSG);
		logFile.saveLog();
		file.close();
	}
	//there is no existing file
	else{
		assert(hasDirectory() == false);
		string filePath = createFilePath();
		
		ofstream outputFile;
		outputFile.open(filePath.c_str());
		outputFile << NEW_FILE_MSG;

		logFile.addLog(CREATE_FILE_MSG);
		logFile.saveLog();
		outputFile.close();
	}
	
}

//create new file at user-defined location 
//save the user-defined file path into the Configuration file for future retrival use
string Storage::createFilePath(){
		
		string configPath = CONFIG_FILE_NAME; 
		
		//combine the user giving directory and defaul text file name to the actual file path
		string pathname;
		pathname = getUserInputPath();
		_outFilePath = pathname + filePathSeparator+ TEXT_FILE_NAME;

		// save this file path to the configuration file
		ofstream configOut;
		configOut.open(configPath.c_str());
		configOut << _outFilePath;
		configOut.close();
		return _outFilePath;

}


//partition every taskline into different components 
//taskList is passed by reference from Logic
//all valid tasks will be retrieved and categorised 
void Storage::loadTask (vector<string> taskLineList, vector<Task>& taskList){

	for (unsigned i = 0; i<taskLineList.size(); i++){
		
		//get each task string line and remove the display index
		string line = taskLineList[i];
		string taskDetail = removeIndex(line);
		
		int numberOfDelimiter = count(taskDetail.begin(), taskDetail.end(), ';');

		if (numberOfDelimiter == 3){
			retrieveTimedTask(taskDetail, taskList);
		}
		else if (numberOfDelimiter == 2){
			retrieveDeadlineTask(taskDetail, taskList);
		}
		else if (numberOfDelimiter == 1){
			retrieveFloatingTask(taskDetail, taskList);
		}
		else{
			string trashLine = taskDetail;
		}
	}
}

void Storage::retrieveTimedTask(string taskDetail, vector<Task>& taskList){
	string taskName = getTaskName(taskDetail);
	string startingTime = getStartingTime(taskDetail);
	string endingTime = getEndingTime(taskDetail);
	string status = getStatus(taskDetail);
	string taskType = DEFAULT_TIMED_TASK_TYPE;

	Task taskStorage;
	taskStorage.setTaskName(taskName);
	taskStorage.setStartingTime(startingTime);
	taskStorage.setEndingTime(endingTime);
	taskStorage.setDone(status);
	taskStorage.setType(taskType);

	taskList.push_back(taskStorage);
}

void Storage::retrieveDeadlineTask(string taskDetail, vector<Task>& taskList){
	string taskName = getTaskName(taskDetail);
	string dueTime = getDueTime(taskDetail);
	string status = getStatus(taskDetail);
	string startTime = "";
	string taskType = DEFAULT_DEADLINE_TASK_TYPE;

	Task taskStorage;
	taskStorage.setTaskName(taskName);
	taskStorage.setStartingTime(startTime);
	taskStorage.setDone(status);
	taskStorage.setEndingTime(dueTime);
	taskStorage.setType(taskType);

	taskList.push_back(taskStorage);
}

void Storage::retrieveFloatingTask(string taskDetail, vector<Task>& taskList){
	string taskName = getTaskName(taskDetail);
	string status = getStatus(taskDetail);
	string startingTime = "";
	string endingTime = "";
	string taskType = DEFAULT_FLOATING_TASK_TYPE;

	Task taskStorage;
	taskStorage.setTaskName(taskName);
	taskStorage.setDone(status);
	taskStorage.setStartingTime(startingTime);
	taskStorage.setEndingTime(endingTime);
	taskStorage.setType(taskType);

	taskList.push_back(taskStorage);
}
			
string Storage::removeIndex(string input){
	size_t positionStart = 0;
    size_t positionEnd = input.size();
    string taskDetail;
	positionStart = input.find_first_of(INDEX_SEPERATOR) + 1;
    taskDetail = input.substr(positionStart, positionEnd - positionStart);
    return taskDetail;
}

string Storage::getTaskName(string input){
	
	size_t positionStart = 0;
	size_t positionEnd = 0;
	string taskName;
	
	positionStart = input.find_first_not_of(' ');
	
	//get rid of the spacing before the first TASK_SEPERATOR
	positionEnd = input.find_first_of(TASK_SEPERATOR) - 1;
	taskName = input.substr(positionStart, positionEnd - positionStart);
	return taskName;
}

string Storage::getStartingTime(string input){
	size_t positionStart = 0;
	size_t positionMid = 0;
	size_t positionEnd = input.size();

	//remove the part of task name 
	positionStart = input.find_first_of(TASK_SEPERATOR) + 1;
	string temp = input.substr(positionStart, positionEnd-positionStart);
	
	//get the part of starting time
	string startTime;
	positionMid = temp.find_first_of(TASK_SEPERATOR)-1;
	positionStart = temp.find_first_not_of(' ');
	startTime = temp.substr(positionStart, positionMid-positionStart);
	return startTime;

}

string Storage::getEndingTime(string input){
	size_t positionStart = 0;
	size_t positionMid1 = 0;
	size_t positionMid2 = 0;
	size_t positionEnd = input.size();

	//remove part of task name
	positionStart = input.find_first_of(TASK_SEPERATOR) + 1;
	string temp = input.substr(positionStart, positionEnd-positionStart);

	//remove part of starting time
	positionMid1 = temp.find_first_of(TASK_SEPERATOR) + 1;
	positionEnd = temp.size();
	string temp2 = temp.substr(positionMid1, positionEnd-positionMid1);

	//get part of ending time
	positionMid2 = temp2.find_first_of(TASK_SEPERATOR)-1;
	positionStart = temp2.find_first_not_of(' ');
	string endTime = temp2.substr(positionStart, positionMid2-positionStart);
	return endTime;
}

string Storage::getStatus(string input){
	size_t positionStart = 0;
	size_t positionEnd = input.size();
	
	//start at the beginning of task status
	positionStart = input.find_last_of(TASK_SEPERATOR) + 2;
	string status = input.substr(positionStart, positionEnd-positionStart);
	return status;
}

string Storage::getDueTime(string input){
	size_t positionStart = 0;
	size_t positionMid = 0;
	size_t positionEnd = input.size();
	
	//remove the part of task name 
	positionStart = input.find_first_of(TASK_SEPERATOR) + 1;
	string temp = input.substr(positionStart, positionEnd-positionStart);
	
	//get the part of due time
	string dueTime;
	positionMid = temp.find_first_of(TASK_SEPERATOR)-1;
	positionStart = temp.find_first_not_of(' ');
	dueTime = temp.substr(positionStart, positionMid-positionStart);
	return dueTime;
}


	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Storage.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Storage.h
	 */


#ifndef Storage_H_
#define Storage_H_

#include <iostream>
#include <string>
#include <vector>
#include "Task.h"

//Storage class is to retrieve tasklist from .txt file in local computer if .txt file exists
//Storage creates a .txt file if there is no existing one
//Storage save any progross made to the .txt file after each operation
class Storage{
private:

	string _outFilePath;
	string _userInputPath;
	
public:
	Storage();
	~Storage();

	bool hasDirectory();
	void saveFile(vector<Task>&);
	void readFile(vector<Task>&);
	void loadTask(vector<string>,  vector<Task>&);
	void setOutFilePath(string);
	void setUserInputPath(string);
	void retrieveTimedTask(string, vector<Task>&);
	void retrieveDeadlineTask(string, vector<Task>&);
	void retrieveFloatingTask(string, vector<Task>&);
	string removeIndex(string);
	string getTaskName(string);
	string getStartingTime(string);
	string getEndingTime(string);
	string getStatus(string);
	string getDueTime(string);
	string getOutfilePath();
	string getUserInputPath();
	string createFilePath();
};

#endif
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Storage.h





