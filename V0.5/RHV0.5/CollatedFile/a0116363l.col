//@author: a0116363l



	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\DisplayTest.cpp
	 */


#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTest
{
	TEST_CLASS(UnitTest)
	{
	public:
		//display and display window will be tested together
		//the get functions are privtae methods therefore could not be tested
		TEST_METHOD(display_setDefaultDisplay) 
		{
			Display display;
			Task testTask1;
			testTask1.setTaskName("buy milk");
			testTask1.setStartingTime("");
			testTask1.setEndingTime("");
			testTask1.setDone("done");

			Task testTask2;
			testTask2.setTaskName("tutorial");
			testTask2.setStartingTime("1111");
			testTask2.setEndingTime("2200");
			testTask2.setDone("done");

			Task testTask3;
			testTask3.setTaskName("buy breakfast");
			testTask3.setStartingTime("");
			testTask3.setEndingTime("10/5");
			testTask3.setDone("ongoing");

			vector<Task> taskList;
			taskList.push_back(testTask1);
			taskList.push_back(testTask2);
			taskList.push_back(testTask3);

			display.setDefaultDisplay(taskList);
			string actualOutput = display.getContent();
			ostringstream oss;
			oss << "[1.][buy milk][][][done]"
				<< endl
				<< "[2.][tutorial][1111][2200][done]"
				<< endl
				<< "[3.][buy breakfast][][10/5][ongoing]"
				<< endl;
			//since the time is not parsed by the parser,they will not be displayed in a standard format
			string expectedOutput = oss.str();
			Assert::AreEqual(expectedOutput, actualOutput);

			taskList.clear();//to test a empty tasklist
			display.setDefaultDisplay(taskList);
			actualOutput = display.getContent();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		TEST_METHOD(display_setVariousDisplay)
		{
			string FLOATING_TASK = "floating";
			string DEADLINE_TASK = "deadline";
			string TIMED_TASK = "timed";
			Display display;
			Task testTask1;
			testTask1.setTaskName("buy milk");
			testTask1.setStartingTime("");
			testTask1.setEndingTime("");
			testTask1.setDone("done");
			testTask1.setType("floating");
			//floating & done type

			Task testTask2;
			testTask2.setTaskName("tutorial");
			testTask2.setStartingTime("1111");
			testTask2.setEndingTime("2200");
			testTask2.setDone("overdue");
			testTask2.setType("timed");
			//timed & overdue

			Task testTask3;
			testTask3.setTaskName("buy breakfast");
			testTask3.setStartingTime("");
			testTask3.setEndingTime("10/5");
			testTask3.setDone("ongoing");
			testTask3.setType("deadline");
			//deadline& ongoing

			vector<Task> taskList;
			taskList.push_back(testTask1);
			taskList.push_back(testTask2);
			taskList.push_back(testTask3);

			
			string OVERDUE_TASK = "overdue";
			string DONE_TASK = "done";
			string ONGOING_TASK = "ongoing";
			string ALL_TASK = "all";
			string INVALID_DISPLAYTYPE = "This display type is invalid";
			string NO_DEADLINE = "There is no deadline task";
			string NO_TIMED = "There is no timed task";
			string NO_FLOATING = "There is no floating task";
			string NO_DONE = "There is no done task";
			string NO_OVERDUE = "There is no overdue task";
			string NO_ONGOING = "There is no ongoing task";
			string DISPLAYED = "The target tasklist has been displayed";

			string actualResp = display.setVariousDisplay(taskList, ALL_TASK);
			Assert::AreEqual(DISPLAYED, actualResp);

			string actualOutput = display.getContent();
			ostringstream oss;
			oss << "[1.][buy milk][][][done]"
				<< endl
				<< "[2.][tutorial][1111][2200][overdue]"
				<< endl
				<< "[3.][buy breakfast][][10/5][ongoing]"
				<< endl;
			//since the time is not parsed by the parser,they will not be displayed in a standard format
			string expectedOutput = oss.str();
			Assert::AreEqual(expectedOutput, actualOutput);

			//to test invalid displaytype
			actualResp = display.setVariousDisplay(taskList, "completed");
			Assert::AreEqual(INVALID_DISPLAYTYPE, actualResp);

			actualOutput = display.getContent();
			//expectedOutput will not be changed since the setContent function is not called.
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		
			TEST_METHOD(display_various){

            Display display;
			Task testTask1;
			testTask1.setTaskName("buy milk");
			testTask1.setStartingTime("");
			testTask1.setEndingTime("");
			testTask1.setDone("done");
			testTask1.setType("floating");
			//floating & done type

			Task testTask2;
			testTask2.setTaskName("tutorial");
			testTask2.setStartingTime("1111");
			testTask2.setEndingTime("2200");
			testTask2.setDone("overdue");
			testTask2.setType("timed");
			//timed & overdue

			Task testTask3;
			testTask3.setTaskName("buy breakfast");
			testTask3.setStartingTime("");
			testTask3.setEndingTime("10/5");
			testTask3.setDone("ongoing");
			testTask3.setType("deadline");
			//deadline& ongoing

			vector<Task> taskList;
			taskList.push_back(testTask1);
			taskList.push_back(testTask2);
			taskList.push_back(testTask3);

			
			string FLOATING_TASK = "floating";
			string DEADLINE_TASK = "deadline";
			string TIMED_TASK = "timed";
			string OVERDUE_TASK = "overdue";
			string DONE_TASK = "done";
			string ONGOING_TASK = "ongoing";
			string ALL_TASK = "all";
			string INVALID_DISPLAYTYPE = "This display type is invalid";
			string NO_DEADLINE = "There is no deadline task";
			string NO_TIMED = "There is no timed task";
			string NO_FLOATING = "There is no floating task";
			string NO_DONE = "There is no done task";
			string NO_OVERDUE = "There is no overdue task";
			string NO_ONGOING = "There is no ongoing task";
			string DISPLAYED = "The target tasklist has been displayed";


			string actualResp;
			string actualOutput;
			string expectedOutput;

			//to display timed
			actualResp = display.setVariousDisplay(taskList, TIMED_TASK);
			Assert::AreEqual(DISPLAYED, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "[1.][tutorial][1111][2200][overdue]\n";
			Assert::AreEqual(expectedOutput, actualOutput);


	        //to display floating
			actualResp = display.setVariousDisplay(taskList, FLOATING_TASK);	
			Assert::AreEqual(DISPLAYED, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "[1.][buy milk][][][done]\n";
			Assert::AreEqual(expectedOutput, actualOutput);
		
			
			//to display deadline
			actualResp = display.setVariousDisplay(taskList, DEADLINE_TASK);
			Assert::AreEqual(DISPLAYED, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "[1.][buy breakfast][][10/5][ongoing]\n";
			Assert::AreEqual(expectedOutput, actualOutput);


			//to display ongoing
			actualResp = display.setVariousDisplay(taskList, ONGOING_TASK);
			Assert::AreEqual(DISPLAYED, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "[1.][buy breakfast][][10/5][ongoing]\n";
			Assert::AreEqual(expectedOutput, actualOutput);


			//to display done
			actualResp = display.setVariousDisplay(taskList, DONE_TASK);
			Assert::AreEqual(DISPLAYED, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "[1.][buy milk][][][done]\n";
			Assert::AreEqual(expectedOutput, actualOutput);


			//to display overdue
			actualResp = display.setVariousDisplay(taskList, OVERDUE_TASK);
			Assert::AreEqual(DISPLAYED, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "[1.][tutorial][1111][2200][overdue]\n";
			Assert::AreEqual(expectedOutput, actualOutput);

			
			taskList.clear();//to test no target type for display

			//to display floating
			actualResp = display.setVariousDisplay(taskList, FLOATING_TASK);
			Assert::AreEqual(NO_FLOATING, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);


			//to display timed
			actualResp = display.setVariousDisplay(taskList, TIMED_TASK);
			Assert::AreEqual(NO_TIMED, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);

			//to display deadline
			actualResp = display.setVariousDisplay(taskList, DEADLINE_TASK);
			Assert::AreEqual(NO_DEADLINE, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);

			//to display ongoing
			actualResp = display.setVariousDisplay(taskList, ONGOING_TASK);
			Assert::AreEqual(NO_ONGOING, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);


			//to display done
			actualResp = display.setVariousDisplay(taskList, DONE_TASK);
			Assert::AreEqual(NO_DONE, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);


			//to display overdue
			actualResp = display.setVariousDisplay(taskList, OVERDUE_TASK);
			Assert::AreEqual(NO_OVERDUE, actualResp);

			actualOutput = display.getContent();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		TEST_METHOD(getfunction_test){ 
			// tasklist will be autometically sorted in get functions
			// all time format must be standardised
			Display display;
			Task testTask1;
			testTask1.setTaskName("buy milk");
			testTask1.setStartingTime("");
			testTask1.setEndingTime("");
			testTask1.setDone("done");
			testTask1.setType("floating");
			//floating & done type

			Task testTask2;
			testTask2.setTaskName("tutorial");
			testTask2.setStartingTime("03-04-2014 09:00");
			testTask2.setEndingTime("07-04-2014 22:00");
			testTask2.setDone("overdue");
			testTask2.setType("timed");
			//timed & overdue

			Task testTask3;
			testTask3.setTaskName("buy breakfast");
			testTask3.setStartingTime("");
			testTask3.setEndingTime("10-05-2015 23:59");
			testTask3.setDone("ongoing");
			testTask3.setType("deadline");
			//deadline& ongoing

			Task testTask4;
			testTask4.setTaskName("drink milk");
			testTask4.setStartingTime("");
			testTask4.setEndingTime("");
			testTask4.setDone("done");
			testTask4.setType("floating");
			//floating & done type

			Task testTask5;
			testTask5.setTaskName("finish tutorial");
			testTask5.setStartingTime("03-04-2014 09:23");
			testTask5.setEndingTime("06-04-2015 23:59");
			testTask5.setDone("overdue");
			testTask5.setType("timed");
			//timed & overdue

			Task testTask6;
			testTask6.setTaskName("eat breakfast");
			testTask6.setStartingTime("");
			testTask6.setEndingTime("10-06-2015 08:00");
			testTask6.setDone("ongoing");
			testTask6.setType("deadline");
			//deadline& ongoing
			

			vector<Task> taskList;
			taskList.push_back(testTask1);
			taskList.push_back(testTask2);
			taskList.push_back(testTask3);
			taskList.push_back(testTask4);
			taskList.push_back(testTask5);
			taskList.push_back(testTask6);

			vector<Task> expectedTasklist;
			vector<Task> actualTasklist;
			//test getDeadline
			actualTasklist= display.getDeadlineTask(taskList);
			//should be sorted according to ascending endingTime
			expectedTasklist.push_back(testTask3);
			expectedTasklist.push_back(testTask6);

			Assert::IsTrue(expectedTasklist[0].endingTime == actualTasklist[0].endingTime);
			Assert::IsTrue(expectedTasklist[1].endingTime == actualTasklist[1].endingTime);

			//test getTimed
			actualTasklist = display.getTimedTask(taskList);
			//should be sorted according to ascending startingTime
			expectedTasklist.clear();
			expectedTasklist.push_back(testTask2);
			expectedTasklist.push_back(testTask5);
			Assert::IsTrue(expectedTasklist[0].startingTime == actualTasklist[0].startingTime);
			Assert::IsTrue(expectedTasklist[1].startingTime == actualTasklist[1].startingTime);

			//test getFloating
			actualTasklist = display.getFloatingTask(taskList);
			//should be sorted according alphabetical order of taskName
			expectedTasklist.clear();
			expectedTasklist.push_back(testTask1);
			expectedTasklist.push_back(testTask4);
			Assert::IsTrue(expectedTasklist[0].taskName == actualTasklist[0].taskName);
			Assert::IsTrue(expectedTasklist[1].taskName == actualTasklist[1].taskName);


			//test getOverdue
			actualTasklist = display.getOverdueTask(taskList);
			//should be sorted according alphabetical order of taskName
			expectedTasklist.clear();
			expectedTasklist.push_back(testTask5);
			expectedTasklist.push_back(testTask2);
			Assert::IsTrue(expectedTasklist[0].taskName == actualTasklist[0].taskName);
			Assert::IsTrue(expectedTasklist[1].taskName == actualTasklist[1].taskName);

			//test getOngoing
			actualTasklist = display.getOngoingTask(taskList);
			//should be sorted according alphabetical order of taskName
			expectedTasklist.clear();
			expectedTasklist.push_back(testTask3);
			expectedTasklist.push_back(testTask6);
			Assert::IsTrue(expectedTasklist[0].taskName == actualTasklist[0].taskName);
			Assert::IsTrue(expectedTasklist[1].taskName == actualTasklist[1].taskName);

			//test getDone
			actualTasklist = display.getDoneTask(taskList);
			//should be sorted according alphabetical order of taskName
			expectedTasklist.clear();
			expectedTasklist.push_back(testTask1);
			expectedTasklist.push_back(testTask4);
			Assert::IsTrue(expectedTasklist[0].taskName == actualTasklist[0].taskName);
			Assert::IsTrue(expectedTasklist[1].taskName == actualTasklist[1].taskName);
		}

	};
}
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\DisplayTest.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\IntegratedTest2.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTestForCommand
{		
	TEST_CLASS(UnitTest1)
	{
	public:
		
		TEST_METHOD(test_delete1){// test for normal deletion

			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;tutorial;6/4 9:00");
			logic.executeUserCommand("add;buy breakfast");

			logic.executeUserCommand("delete;1");
			string expectedResp = "Task 1 is deleted successfully.";
			string actualResp = logic.tellGUIResponse();	
			Assert::AreEqual(expectedResp, actualResp);
			Assert::IsTrue(logic.taskList[0].taskName == "tutorial");
		

			logic.executeUserCommand("delete;1");
			Assert::IsTrue(logic.taskList[0].taskName == "buy breakfast");


		}

		TEST_METHOD(test_delete2){// test for boundary case deletion

			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;tutorial;6/4 9:00");
			logic.executeUserCommand("add;buy breakfast");

			//invalid index deletion
			logic.executeUserCommand("delete;0");
			string expectedResp = "Failed to delete the task. Task \"0\" is not in the list.";
			string actualResp = logic.tellGUIResponse();
			Assert::AreEqual(expectedResp, actualResp);
			Assert::IsTrue(logic.taskList[0].taskName == "buy milk");

			logic.executeUserCommand("delete;4");
			Assert::IsTrue(logic.taskList[0].taskName == "buy milk");
			expectedResp = "Failed to delete the task. Task \"4\" is not in the list.";
			actualResp = logic.tellGUIResponse();
			Assert::AreEqual(expectedResp, actualResp);


		}
		//for display all
		TEST_METHOD(test_display1){

			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;complete tutorial;04-05-2015 09:00");
			logic.executeUserCommand("add;have breakfast;02-03-2015 09:00;04-06-2015 10:00");
			logic.executeUserCommand("mark done;2");
			logic.taskList[2].setDone("overdue");
			logic.executeUserCommand("display;all");
			string actualResp = logic.tellGUIResponse();
			string expectedResp = "The target tasklist has been displayed";
			Assert::AreEqual(expectedResp, actualResp);
			string actualOutput = logic.tellGUI();
			string expectedOutput = "[1.][buy milk][][][ongoing]\n[2.][complete tutorial][][04-05-2015 09:00][done]\n[3.][have breakfast][02-03-2015 09:00][04-06-2015 10:00][overdue]\n";
			Assert::AreEqual(expectedOutput, actualOutput);
	        
			//test for invalid dispaly type
			logic.executeUserCommand("display;nothing");
		    actualResp = logic.tellGUIResponse();
			expectedResp = "This display type is invalid";
			Assert::AreEqual(expectedResp, actualResp);
			actualOutput = logic.tellGUI();
		    expectedOutput = "[1.][buy milk][][][ongoing]\n[2.][complete tutorial][][04-05-2015 09:00][done]\n[3.][have breakfast][02-03-2015 09:00][04-06-2015 10:00][overdue]\n";
			Assert::AreEqual(expectedOutput, actualOutput);


		}

		//for display floating
		TEST_METHOD(test_display2){

			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;complete tutorial;04-05-2015 09:00");
			logic.executeUserCommand("add;have breakfast;02-03-2015 09:00;04-06-2015 10:00");
			logic.executeUserCommand("mark done;2");
			logic.taskList[2].setDone("overdue");
			logic.executeUserCommand("display;floating");

			string actualResp = logic.tellGUIResponse();
			string expectedResp = "The target tasklist has been displayed";
			Assert::AreEqual(expectedResp, actualResp);
			string actualOutput = logic.tellGUI();
			string expectedOutput = "[1.][buy milk][][][ongoing]\n";
			Assert::AreEqual(expectedOutput, actualOutput);

			logic.taskList.clear();
			logic.executeUserCommand("display;floating");

			actualResp = logic.tellGUIResponse();
			expectedResp = "There is no floating task";
			Assert::AreEqual(expectedResp, actualResp);
			actualOutput = logic.tellGUI();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);


		}

		//for display deadline
		TEST_METHOD(test_display3){
			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;complete tutorial;04-05-2015 09:00");
			logic.executeUserCommand("add;have breakfast;02-03-2015 09:00;04-06-2015 10:00");
			logic.executeUserCommand("mark done;2");
			logic.taskList[2].setDone("overdue");
			logic.executeUserCommand("display;deadline");

			string actualResp = logic.tellGUIResponse();
			string expectedResp = "The target tasklist has been displayed";
			Assert::AreEqual(expectedResp, actualResp);
			string actualOutput = logic.tellGUI();
			string expectedOutput = "[1.][complete tutorial][][04-05-2015 09:00][done]\n";
			Assert::AreEqual(expectedOutput, actualOutput);

			logic.taskList.clear();
			logic.executeUserCommand("display;deadline");

			actualResp = logic.tellGUIResponse();
			expectedResp = "There is no deadline task";
			Assert::AreEqual(expectedResp, actualResp);
			actualOutput = logic.tellGUI();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		//for display timed
		TEST_METHOD(test_display4){
			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;complete tutorial;04-05-2015 09:00");
			logic.executeUserCommand("add;have breakfast;02-03-2015 09:00;04-06-2015 10:00");
			logic.executeUserCommand("mark done;2");
			logic.taskList[2].setDone("overdue");
			logic.executeUserCommand("display;timed");

			string actualResp = logic.tellGUIResponse();
			string expectedResp = "The target tasklist has been displayed";
			Assert::AreEqual(expectedResp, actualResp);
			string actualOutput = logic.tellGUI();
			string expectedOutput = "[1.][have breakfast][02-03-2015 09:00][04-06-2015 10:00][overdue]\n";
			Assert::AreEqual(expectedOutput, actualOutput);

			logic.taskList.clear();
			logic.executeUserCommand("display;timed");

			actualResp = logic.tellGUIResponse();
			expectedResp = "There is no timed task";
			Assert::AreEqual(expectedResp, actualResp);
			actualOutput = logic.tellGUI();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		//for display ongoing 
		TEST_METHOD(test_display5){
			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;complete tutorial;04-05-2015 09:00");
			logic.executeUserCommand("add;have breakfast;02-03-2015 09:00;04-06-2015 10:00");
			logic.executeUserCommand("mark done;2");
			logic.taskList[2].setDone("overdue");
			logic.executeUserCommand("display;ongoing");

			string actualResp = logic.tellGUIResponse();
			string expectedResp = "The target tasklist has been displayed";
			Assert::AreEqual(expectedResp, actualResp);
			string actualOutput = logic.tellGUI();
			string expectedOutput = "[1.][buy milk][][][ongoing]\n";
			Assert::AreEqual(expectedOutput, actualOutput);

			logic.taskList.clear();
			logic.executeUserCommand("display;ongoing");

			actualResp = logic.tellGUIResponse();
			expectedResp = "There is no ongoing task";
			Assert::AreEqual(expectedResp, actualResp);
			actualOutput = logic.tellGUI();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);
		}


		//for display overdue
		TEST_METHOD(test_display6){
			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;complete tutorial;04-05-2015 09:00");
			logic.executeUserCommand("add;have breakfast;02-03-2015 09:00;04-06-2015 10:00");
			logic.executeUserCommand("mark done;2");
			logic.taskList[2].setDone("overdue");
			logic.executeUserCommand("display;overdue");

			string actualResp = logic.tellGUIResponse();
			string expectedResp = "The target tasklist has been displayed";
			Assert::AreEqual(expectedResp, actualResp);
			string actualOutput = logic.tellGUI();
			string expectedOutput = "[1.][have breakfast][02-03-2015 09:00][04-06-2015 10:00][overdue]\n";
			Assert::AreEqual(expectedOutput, actualOutput);

			logic.taskList.clear();
			logic.executeUserCommand("display;overdue");

			actualResp = logic.tellGUIResponse();
			expectedResp = "There is no overdue task";
			Assert::AreEqual(expectedResp, actualResp);
			actualOutput = logic.tellGUI();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		//for display done
		TEST_METHOD(test_display7){
			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;complete tutorial;04-05-2015 09:00");
			logic.executeUserCommand("add;have breakfast;02-03-2015 09:00;04-06-2015 10:00");
			logic.executeUserCommand("mark done;2");
			logic.taskList[2].setDone("overdue");
			logic.executeUserCommand("display;done");

			string actualResp = logic.tellGUIResponse();
			string expectedResp = "The target tasklist has been displayed";
			Assert::AreEqual(expectedResp, actualResp);
			string actualOutput = logic.tellGUI();
			string expectedOutput = "[1.][complete tutorial][][04-05-2015 09:00][done]\n";
			Assert::AreEqual(expectedOutput, actualOutput);

			logic.taskList.clear();
			logic.executeUserCommand("display;done");

			actualResp = logic.tellGUIResponse();
			expectedResp = "There is no done task";
			Assert::AreEqual(expectedResp, actualResp);
			actualOutput = logic.tellGUI();
			expectedOutput = "";
			Assert::AreEqual(expectedOutput, actualOutput);
		}
		

		TEST_METHOD(test_search1)
		{
			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;tutorial;6/4 9:00");
			logic.executeUserCommand("add;buy breakfast");

			logic.executeUserCommand("search;u");
			string expectedSysResp = "Search Result is displayed.";
			string actualSysResp = logic.tellGUIResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			ostringstream oss;
			oss << "[1.][buy milk][][][ongoing]"
				<< endl
				<< "[2.][tutorial][][06-04-2015 09:00][ongoing]"
				<< endl
				<< "[3.][buy breakfast][][][ongoing]"
				<< endl;
			string expectedResult = oss.str();
			string actualResult = logic.tellGUI();
			Assert::AreEqual(expectedResult, actualResult);


		}

		TEST_METHOD(test_search2){

			Logic logic;

			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;tutorial;6/4 9:00");
			logic.executeUserCommand("add;buy breakfast");

			logic.executeUserCommand("search;buy");
			string expectedSysResp = "Search Result is displayed.";
			string actualSysResp = logic.tellGUIResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			ostringstream oss2;
			oss2 << "[1.][buy milk][][][ongoing]"
				<< endl
				<< "[2.][buy breakfast][][][ongoing]"
				<< endl;
			string expectedResult = oss2.str();
			string actualResult = logic.tellGUI();
			Assert::AreEqual(expectedResult, actualResult);

		}
		TEST_METHOD(test_search3){// test no matching search
			Logic logic;

			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;tutorial;6/4 9:00");
			logic.executeUserCommand("add;buy breakfast");

			logic.executeUserCommand("search;timed");
			string expectedSysResp = "There is no result found.";
			string actualSysResp = logic.tellGUIResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			ostringstream oss3;
			oss3 << "";
			string expectedResult = oss3.str();
			string actualResult = logic.tellGUI();
			Assert::AreEqual(expectedResult, actualResult);
		}
		TEST_METHOD(test_search4){//test esearch empty

			Logic logic;
			logic.executeUserCommand("add;buy milk");
			logic.executeUserCommand("add;tutorial;6/4 9:00");
			logic.executeUserCommand("add;buy breakfast");


			logic.executeUserCommand("delete;1");
			logic.executeUserCommand("delete;1");
			logic.executeUserCommand("delete;1");


			//for the case when there is no task in the list"
			logic.executeUserCommand("search;timed");
			string expectedSysResp = "There is no result found.";
			string actualSysResp = logic.tellGUIResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			ostringstream oss4;
			oss4 << "";
			string expectedResult = oss4.str();
			string actualResult = logic.tellGUI();
			Assert::AreEqual(expectedResult, actualResult);
		}
	};
}
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\IntegratedTest2.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\LoggerTest.cpp
	 */


#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTest
{
	TEST_CLASS(LoggerTest)
	{
	public:
		
		TEST_METHOD(addlog_test)
		{
			
		  RHLogger logger = RHLogger::getInstance();

		  logger.addLog("This is a test");
		  logger.addLog("This is another test");
		  vector<string> actualLogContent = logger.getLogContent();
		  vector<string> expectedLogContent;
		  expectedLogContent.push_back("This is a test");
		  expectedLogContent.push_back("This is another test");

		  Assert::AreEqual(expectedLogContent[0], actualLogContent[0]);
		  Assert::AreEqual(expectedLogContent[1], actualLogContent[1]);

		}


		TEST_METHOD(savelog_test)
		{  
			



		}

	};
}
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\LoggerTest.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\TimeCheckerTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTest
{
	TEST_CLASS(timeCheckerTest)
	{
	public:
		
		TEST_METHOD(checkStatus_test){
			TimeChecker time;
			bool isOverdue;
			//not overdue case
			string testTime1 = "20-05-2015 09:00";
			isOverdue = time.checkStatus(testTime1);
			Assert::IsFalse(isOverdue);

			//overdue case
			string testTime2 = "03-04-2014 09:00";
			isOverdue = time.checkStatus(testTime2);
			Assert::IsTrue(isOverdue);
		}

		TEST_METHOD(updateStatus_test){
			
			TimeChecker time;
			Task testTask1;
			testTask1.setTaskName("buy milk");
			testTask1.setStartingTime("");
			testTask1.setEndingTime("");
			testTask1.setDone("done");
			testTask1.setType("floating");

			Task testTask2;
			testTask2.setTaskName("drink milk");
			testTask2.setStartingTime("");
			testTask2.setEndingTime("03-04-2014 09:23");
			testTask2.setDone("done");
			testTask2.setType("deadline");
			//floating & done type will not be set as overdue

			Task testTask3;
			testTask3.setTaskName("finish tutorial");
			testTask3.setStartingTime("03-04-2014 09:23");
			testTask3.setEndingTime("06-04-2015 23:59");
			testTask3.setDone("ongoing");
			testTask3.setType("timed");
			//timed will be set as overdue

			Task testTask4;
			testTask4.setTaskName("eat breakfast");
			testTask4.setStartingTime("");
			testTask4.setEndingTime("10-06-2015 08:00");
			testTask4.setDone("ongoing");
			testTask4.setType("deadline");
			//deadline& ongoing

			vector<Task> taskList;
			taskList.push_back(testTask1);
			taskList.push_back(testTask2);
			taskList.push_back(testTask3);
			taskList.push_back(testTask4);
			
			time.updateStatus(taskList);

			vector<Task> expectedOutput;
			vector<Task> actualOutput = taskList;
			expectedOutput.push_back(testTask1);
			expectedOutput.push_back(testTask2);
			expectedOutput.push_back(testTask3);
			expectedOutput.push_back(testTask4);
			expectedOutput[2].setDone("overdue");

			Assert::AreEqual(expectedOutput[2].status, actualOutput[2].status);

		}

	};
}
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\AutometedTesting\TimeCheckerTest.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHGUI\GUI.h
	 */

#pragma once
#include <msclr/marshal_cppstd.h>
#include <iostream>
#include <cliext/vector>
#include "Logic.h"
#include "Logger.h"
#using <mscorlib.dll>

Logic logic;

namespace GUI {

	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;

	/// <summary>
	/// Summary for MyForm
	/// </summary>
	public ref class MyForm : public System::Windows::Forms::Form
	{
	public:
		MyForm(void)
		{
			InitializeComponent();
			
			//
			//TODO: Add the constructor code here
			//
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~MyForm()
		{
			if (components)
			{
				delete components;
			}
		}
	private: System::Windows::Forms::Button^  comfirmButton;
	protected:

	private: System::Windows::Forms::TextBox^  inputBox;


	private: System::Windows::Forms::Label^  SystemResponse;
	private: System::Windows::Forms::ListView^  DisplayContent;

	private: System::Windows::Forms::ColumnHeader^  Index;
	private: System::Windows::Forms::ColumnHeader^  TaskName;
	private: System::Windows::Forms::ColumnHeader^  Start;
	private: System::Windows::Forms::ColumnHeader^  End;
	private: System::Windows::Forms::ColumnHeader^  Status;


	protected:System::Windows::Forms::ListViewItem^ listViewItems;
	private: System::Windows::Forms::Timer^  timer1;
	private: System::Windows::Forms::Button^  HelpButton;





	protected:

	protected:
	private: System::ComponentModel::IContainer^  components;

	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>


#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
			this->components = (gcnew System::ComponentModel::Container());
			this->comfirmButton = (gcnew System::Windows::Forms::Button());
			this->inputBox = (gcnew System::Windows::Forms::TextBox());
			this->SystemResponse = (gcnew System::Windows::Forms::Label());
			this->DisplayContent = (gcnew System::Windows::Forms::ListView());
			this->Index = (gcnew System::Windows::Forms::ColumnHeader());
			this->TaskName = (gcnew System::Windows::Forms::ColumnHeader());
			this->Start = (gcnew System::Windows::Forms::ColumnHeader());
			this->End = (gcnew System::Windows::Forms::ColumnHeader());
			this->Status = (gcnew System::Windows::Forms::ColumnHeader());
			this->timer1 = (gcnew System::Windows::Forms::Timer(this->components));
			this->HelpButton = (gcnew System::Windows::Forms::Button());
			this->SuspendLayout();
			// 
			// comfirmButton
			// 
			this->comfirmButton->Font = (gcnew System::Drawing::Font(L"Arial", 10.5F, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->comfirmButton->Location = System::Drawing::Point(461, 23);
			this->comfirmButton->Name = L"comfirmButton";
			this->comfirmButton->Size = System::Drawing::Size(62, 28);
			this->comfirmButton->TabIndex = 1;
			this->comfirmButton->Text = L"Enter";
			this->comfirmButton->UseVisualStyleBackColor = true;
			this->comfirmButton->Click += gcnew System::EventHandler(this, &MyForm::comfirmButton_Click);
			// 
			// inputBox
			// 
			this->inputBox->Font = (gcnew System::Drawing::Font(L"Arial", 12, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->inputBox->Location = System::Drawing::Point(12, 24);
			this->inputBox->Multiline = true;
			this->inputBox->Name = L"inputBox";
			this->inputBox->Size = System::Drawing::Size(443, 28);
			this->inputBox->TabIndex = 0;
			this->inputBox->TextChanged += gcnew System::EventHandler(this, &MyForm::inputBox_TextChanged);
			// 
			// SystemResponse
			// 
			this->SystemResponse->Font = (gcnew System::Drawing::Font(L"Arial", 9, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->SystemResponse->ForeColor = System::Drawing::Color::Red;
			this->SystemResponse->ImageAlign = System::Drawing::ContentAlignment::TopLeft;
			this->SystemResponse->Location = System::Drawing::Point(9, 498);
			this->SystemResponse->Name = L"SystemResponse";
			this->SystemResponse->Size = System::Drawing::Size(432, 26);
			this->SystemResponse->TabIndex = 4;
			this->SystemResponse->Text = L"SystemResponse";
			this->SystemResponse->Click += gcnew System::EventHandler(this, &MyForm::label1_Click);
			// 
			// DisplayContent
			// 
			this->DisplayContent->AllowColumnReorder = true;
			this->DisplayContent->Columns->AddRange(gcnew cli::array< System::Windows::Forms::ColumnHeader^  >(5) {
				this->Index, this->TaskName,
					this->Start, this->End, this->Status
			});
			this->DisplayContent->Font = (gcnew System::Drawing::Font(L"Arial", 9, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->DisplayContent->FullRowSelect = true;
			this->DisplayContent->GridLines = true;
			this->DisplayContent->Location = System::Drawing::Point(12, 58);
			this->DisplayContent->Name = L"DisplayContent";
			this->DisplayContent->Size = System::Drawing::Size(512, 437);
			this->DisplayContent->TabIndex = 5;
			this->DisplayContent->UseCompatibleStateImageBehavior = false;
			this->DisplayContent->View = System::Windows::Forms::View::Details;
			this->DisplayContent->SelectedIndexChanged += gcnew System::EventHandler(this, &MyForm::listView1_SelectedIndexChanged);
			// 
			// Index
			// 
			this->Index->Text = L"Index";
			this->Index->Width = 50;
			// 
			// TaskName
			// 
			this->TaskName->Text = L"TaskName";
			this->TaskName->TextAlign = System::Windows::Forms::HorizontalAlignment::Center;
			this->TaskName->Width = 100;
			// 
			// Start
			// 
			this->Start->Text = L"Start";
			this->Start->TextAlign = System::Windows::Forms::HorizontalAlignment::Center;
			this->Start->Width = 150;
			// 
			// End
			// 
			this->End->Text = L"End";
			this->End->TextAlign = System::Windows::Forms::HorizontalAlignment::Center;
			this->End->Width = 150;
			// 
			// Status
			// 
			this->Status->Text = L"Status";
			this->Status->TextAlign = System::Windows::Forms::HorizontalAlignment::Center;
			// 
			// timer1
			// 
			this->timer1->Enabled = true;
			this->timer1->Interval = 60000;
			this->timer1->Tick += gcnew System::EventHandler(this, &MyForm::timer1_Tick_1);
			// 
			// HelpButton
			// 
			this->HelpButton->FlatStyle = System::Windows::Forms::FlatStyle::Popup;
			this->HelpButton->Font = (gcnew System::Drawing::Font(L"Arial", 9, System::Drawing::FontStyle::Bold, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->HelpButton->ForeColor = System::Drawing::Color::Red;
			this->HelpButton->Location = System::Drawing::Point(448, 500);
			this->HelpButton->Name = L"HelpButton";
			this->HelpButton->Size = System::Drawing::Size(75, 23);
			this->HelpButton->TabIndex = 6;
			this->HelpButton->Text = L"Help ( F1 )";
			this->HelpButton->UseVisualStyleBackColor = true;
			this->HelpButton->Click += gcnew System::EventHandler(this, &MyForm::button1_Click);
			// 
			// MyForm
			// 
			this->AcceptButton = this->comfirmButton;
			this->AutoScaleDimensions = System::Drawing::SizeF(6, 12);
			this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
			this->AutoSizeMode = System::Windows::Forms::AutoSizeMode::GrowAndShrink;
			this->ClientSize = System::Drawing::Size(541, 533);
			this->Controls->Add(this->HelpButton);
			this->Controls->Add(this->DisplayContent);
			this->Controls->Add(this->SystemResponse);
			this->Controls->Add(this->inputBox);
			this->Controls->Add(this->comfirmButton);
			this->Font = (gcnew System::Drawing::Font(L"SimSun-ExtB", 9, System::Drawing::FontStyle::Regular, System::Drawing::GraphicsUnit::Point,
				static_cast<System::Byte>(0)));
			this->Name = L"MyForm";
			this->Text = L"RushHour";
			this->Load += gcnew System::EventHandler(this, &MyForm::MyForm_Load);
			this->ResumeLayout(false);
			this->PerformLayout();

		}
#pragma endregion
	private: System::Void MyForm_Load(System::Object^  sender, System::EventArgs^  e) {

		//To register hotkeys in  the inetrface
		this->KeyPreview = true;
		this->KeyDown += gcnew System::Windows::Forms::KeyEventHandler(this, &MyForm::MyForm_KeyDown);

		int count = 0;
		size_t tempStart = 0;
		size_t tempEnd = -2;
		String^ temp;
		string componentInfo;
		//To check whether user is a first-time user
		//We assume there is only one user for this software on each computer
		logic.checkDirectory();
	
		//To display the feedback message which is the user prompt for a file directory
		//or a welcome message for second-time user
		string responseMessage = logic.tellGUIResponse();
		this->SystemResponse->Text = gcnew String(responseMessage.c_str());

		//To update the status of any ouverdue tasks
		logic.refreshStatus();

		//To prepare the display window 
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHGUI\GUI.h





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHGUI\GUI.h
	 */

    //To register F1 as a hotkey for Help Button
	private: System::Void MyForm_KeyDown(System::Object^  sender, System::Windows::Forms::KeyEventArgs^  e) {
		if (e->KeyCode == System::Windows::Forms::Keys::F1) {
			this->HelpButton->PerformClick();
		}
	}
	

    //Specify the following procedures when the Enter button is clicked
	private: System::Void comfirmButton_Click(System::Object^  sender, System::EventArgs^  e) {

		int count = 0;
		size_t tempStart = 0;
		size_t tempEnd = -2;
		String^ temp;
		string componentInfo;
		//To extract the user input from the input textbox
		string userInput = msclr::interop::marshal_as<string>(inputBox->Text);

		//Clear the input box for next input and set the focus at the beginning of input textbox
		inputBox->Clear();
		inputBox->Select(0, 0);

		//clear the display window for updated tasklist
		DisplayContent->Items->Clear();
		
		//Pass the user input for further actions
		logic.executeUserCommand(userInput);

	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHGUI\GUI.h





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHGUI\GUI.h
	 */

		//To display feedback or user prompt
		string responseMessage = logic.tellGUIResponse();
		this->SystemResponse->Text = gcnew String(responseMessage.c_str());

	}

	private: System::Void inputBox_TextChanged(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void label1_Click(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void listView1_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e) {
	}

	private: System::Void feedbackWindow_TextChanged_1(System::Object^  sender, System::EventArgs^  e) {
	}

	//To automatically refresh the display Window every 60 seconds
    //The overdue tasks will be updated
    private: System::Void timer1_Tick_1(System::Object^  sender, System::EventArgs^  e) {
		     int count = 0;
		     size_t tempStart = 0;
		     size_t tempEnd = -2;
		     String^ temp;
		     string componentInfo;

		     logic.refreshStatus();
			 DisplayContent->Items->Clear();
			 string returnInfo = logic.tellGUI();
			 String^ tempString = gcnew String(returnInfo.c_str());


	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHGUI\GUI.h





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHGUI\GUI.h
	 */

    //To display the message box containing information
	//to assist user with command format when help button is clicked
    private: System::Void button1_Click(System::Object^  sender, System::EventArgs^  e) {

				   ostringstream instruction;
			       instruction<< "Please read the instructions for supported functionalities below\n"
					   << "and note that the software is case sensitive:\n\n"
					   << "If you are reqired a directory, please specify a directory as following:\n"
					   << "directory; file path you want\n\n"
					   << "Supported commands:\n"
					   << "1.add;task\n"
					   << "2.add;task;start(time);end(time)\n"
					   << "3.add;task(time);end(time)\n"
					   << "4:delete;index\n"
					   << "5.edit;index;task(modified)\n"
					   << "6.edit;index;task(modified);start(modified);end(modified)\n"
					   << "7.edit;index;task(modified);end(modified)\n"
					   << "8.search;keyword\n"
					   << "9.display;all\n"
					   << "10.display;timed\n"
					   << "11.display;floating\n"
					   << "12.display;deadline\n"
					   << "13.display;ongoing\n"
					   << "14.display;done\n"
					   << "15.display;overdue\n"
					   << "16.mark done;index\n"
					   << "17.undo\n"
					   << "18.redo\n"
					   << "Time format supported:\n"
					   << "1852->18:52    1042am->10:42    09:13pm->21:13\n"	
					   << "21:33h->21:33  07.12am->07:12   1544h->15:44\n"
					   << "6/11->06-11-2015  3-12->03-12-2015  5/6/2017->05-06-2017 \n"
					   << "7-9-2018->07-09-2018  6Sep2013->06-11-2013  7sep2013->07-09-2013  8SEP2014->08-09-2013\n"
					   << "3MAY2016 18.43h   6dec2013 0900\n";

				   string format = instruction.str();
				   System::Windows::Forms::MessageBox::Show(gcnew String(format.c_str()));
               }
};
}
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHGUI\GUI.h





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Display.cpp
	 */


#include "Display.h"
#include "Logger.h"
const string Display::FLOATING_TASK ="floating";
const string Display::DEADLINE_TASK="deadline";
const string Display::TIMED_TASK="timed";
const string Display::OVERDUE_TASK="overdue";
const string Display::DONE_TASK="done";
const string Display::ONGOING_TASK="ongoing";
const string Display::ALL_TASK = "all";
const string Display::INVALID_DISPLAYTYPE= "This display type is invalid";
const string Display::NO_DEADLINE ="There is no deadline task";
const string Display::NO_TIMED="There is no timed task";
const string Display::NO_FLOATING="There is no floating task";
const string Display::NO_DONE="There is no done task";
const string Display::NO_OVERDUE="There is no overdue task";
const string Display::NO_ONGOING = "There is no ongoing task";
const string Display::DISPLAYED = "The target tasklist has been displayed";
const string Display::FLOATING_RETRIVED_SORTED = "Floating tasks are retrived and sorted successfully";
const string Display::DEADLINE_RETRIVED_SORTED = "Deadline tasks are retrived and sorted successfully";
const string Display::TIMED_RETRIVED_SORTED = "Timed tasks are retrived and sorted successfully";
const string Display::OVERDUE_RETRIVED_SORTED = "Overdue tasks are retrived and sorted successfully";
const string Display::ONGOING_RETRIVED_SORTED = "Ongoing tasks are retrived and sorted successfully";
const string Display::DONE_RETRIVED_SORTED = "Done tasks are retrived and sorted successfully";

Display::Display(){}

Display::~Display(){}


void Display::setDefaultDisplay(vector<Task> &taskList){
	_mainDisplay.setContent(taskList);
	return;
}

//Tos set up display content when display type is specified
string Display::setVariousDisplay(vector<Task>& taskList,string displayType){

	vector<Task> targetTasklist;
	//Logger is meant to track the progress of displaying the target list
	RHLogger logger = RHLogger::getInstance();

	
	if (displayType ==FLOATING_TASK){
		targetTasklist = getFloatingTask(taskList);
		_mainDisplay.setContent(targetTasklist);
		if (targetTasklist.empty()){
			logger.addLog(NO_FLOATING);
			logger.saveLog();
			return NO_FLOATING;
		}
	}
	else if (displayType ==DEADLINE_TASK){
		targetTasklist = getDeadlineTask(taskList);
		_mainDisplay.setContent(targetTasklist);
		if (targetTasklist.empty()){
			logger.addLog(NO_DEADLINE);
			logger.saveLog();
			return NO_DEADLINE;
		}
	}
	else if (displayType == TIMED_TASK){
		targetTasklist = getTimedTask(taskList);
		_mainDisplay.setContent(targetTasklist);
		if (targetTasklist.empty()){
			logger.addLog(NO_TIMED);
			logger.saveLog();
			return NO_TIMED;
		}
	}
	else if (displayType == OVERDUE_TASK){
		targetTasklist = getOverdueTask(taskList);
		_mainDisplay.setContent(targetTasklist);
		if (targetTasklist.empty()){
			logger.addLog(NO_OVERDUE);
			logger.saveLog();
			return NO_OVERDUE;
		}
	}
	else if (displayType == DONE_TASK){
		targetTasklist = getDoneTask(taskList);
		_mainDisplay.setContent(targetTasklist);
		if (targetTasklist.empty()){
			logger.addLog(NO_DONE);
			logger.saveLog();
			return NO_DONE;
		}
	}
	else if (displayType == ONGOING_TASK){
		targetTasklist = getOngoingTask(taskList);
        _mainDisplay.setContent(targetTasklist);
		if (targetTasklist.empty()){
			logger.addLog(NO_ONGOING);
			logger.saveLog();
			return NO_ONGOING;
		}
	}
	else if (displayType == ALL_TASK){
		targetTasklist = taskList;
		_mainDisplay.setContent(targetTasklist);

	}
	else{
		logger.addLog(INVALID_DISPLAYTYPE);
		logger.saveLog();
		return INVALID_DISPLAYTYPE;
	}
	logger.addLog(DISPLAYED);
	logger.saveLog();
	return DISPLAYED;
}

vector<Task>Display::getFloatingTask(vector<Task> taskList){
	vector<Task> sortedFloatingTaskList;
	vector<Task> floatingTaskList;
	for (unsigned i = 0; i < taskList.size(); i++){
		if (taskList[i].type == FLOATING_TASK){
			floatingTaskList.push_back(taskList[i]);
		}
	}
	sortedFloatingTaskList = sorter.sortFloatingTaskList(floatingTaskList);
	RHLogger logger = RHLogger::getInstance();
	logger.addLog(FLOATING_RETRIVED_SORTED);
	logger.saveLog();
	return sortedFloatingTaskList;
}



vector<Task>Display::getDeadlineTask(vector<Task> taskList){
	vector<Task> deadlineTaskList;
	vector<Task> sortedDeadlineTaskList;
	for (unsigned i = 0; i < taskList.size(); i++){
		if (taskList[i].type == DEADLINE_TASK){
			deadlineTaskList.push_back(taskList[i]);
		}
	}
	sortedDeadlineTaskList = sorter.sortDeadlineTaskList(deadlineTaskList);
	RHLogger logger = RHLogger::getInstance();
	logger.addLog(DEADLINE_RETRIVED_SORTED);
	logger.saveLog();

	return sortedDeadlineTaskList;
}

vector<Task>Display::getTimedTask(vector<Task> taskList){
	vector<Task> timedTaskList;
	vector<Task> sortedTimedTaskList;
	for (unsigned i = 0; i < taskList.size(); i++){
		if (taskList[i].type == TIMED_TASK){
			timedTaskList.push_back(taskList[i]);
		}
	}
	sortedTimedTaskList = sorter.sortTimedTaskList(timedTaskList);
	RHLogger logger = RHLogger::getInstance();
	logger.addLog(TIMED_RETRIVED_SORTED);
	logger.saveLog();

	return sortedTimedTaskList;

}

vector<Task>Display::getOverdueTask(vector<Task> tasklist){
	vector<Task> overdueTaskList;
	vector<Task> sortedOverdueTaskList;

	for (unsigned i = 0; i < tasklist.size(); i++){
		if (tasklist[i].status == OVERDUE_TASK)
			overdueTaskList.push_back(tasklist[i]);
	}
	sortedOverdueTaskList = sorter.sortOverdueTaskList(overdueTaskList);
	RHLogger logger = RHLogger::getInstance();
	logger.addLog(OVERDUE_RETRIVED_SORTED);
	logger.saveLog();

	return sortedOverdueTaskList;
}

vector<Task>Display::getDoneTask(vector<Task> tasklist){
	vector<Task> doneTaskList;
	vector<Task> sortedDoneTaskList;

	for (unsigned i = 0; i < tasklist.size(); i++){
		if (tasklist[i].status == DONE_TASK)
			doneTaskList.push_back(tasklist[i]);
	}
	sortedDoneTaskList = sorter.sortDoneTaskList(doneTaskList);

	RHLogger logger = RHLogger::getInstance();
	logger.addLog(DONE_RETRIVED_SORTED);
	logger.saveLog();

	return sortedDoneTaskList;
}

vector<Task>Display::getOngoingTask(vector<Task> tasklist){
	vector<Task> ongoingTaskList;
	vector<Task> sortedOngoingTaskList;

	for (unsigned i = 0; i < tasklist.size(); i++){
		if (tasklist[i].status == ONGOING_TASK)
			ongoingTaskList.push_back(tasklist[i]);
	}
	sortedOngoingTaskList = sorter.sortOngoingTaskList(ongoingTaskList);

	RHLogger logger = RHLogger::getInstance();
	logger.addLog(ONGOING_RETRIVED_SORTED);
	logger.saveLog();

	return sortedOngoingTaskList;
}


string Display::getContent(){
	return _mainDisplay.getContent();
}


	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Display.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Display.h
	 */

#ifndef DISPLAY_H
#define DISPLAY_H

#include <vector>
#include <string>
#include <sstream>
#include "Task.h"
#include "DisplayWindow.h"
#include "Sorter.h"

//Display class is used to prepare the DisplayWindow with the target tasklist
//The tasklist is prepared either by default or according to the specified display type
//When the DisplayWindow is set up, Display can retrieve the content from DisplayWindow and return to Logic

class Display{
private:
	
	DisplayWindow _mainDisplay;

	static const string FLOATING_TASK;
	static const string DEADLINE_TASK;
	static const string TIMED_TASK;
	static const string OVERDUE_TASK;
	static const string DONE_TASK;
	static const string ONGOING_TASK;
	static const string ALL_TASK;
	static const string INVALID_DISPLAYTYPE;
	static const string NO_FLOATING;
	static const string NO_DEADLINE;
	static const string NO_TIMED;
	static const string NO_OVERDUE;
	static const string NO_DONE;
	static const string NO_ONGOING;
	static const string DISPLAYED;
	static const string FLOATING_RETRIVED_SORTED;
	static const string DEADLINE_RETRIVED_SORTED; 
	static const string TIMED_RETRIVED_SORTED; 
	static const string OVERDUE_RETRIVED_SORTED;
	static const string ONGOING_RETRIVED_SORTED;
	static const string DONE_RETRIVED_SORTED;

public:

	Display();
	~Display();
	Sorter sorter;
	void setDefaultDisplay(vector<Task>&);
	string setVariousDisplay(vector<Task>&, string);
    string getContent();

	vector<Task> getFloatingTask(vector<Task>);//sorting alphabetically
	vector<Task> getDeadlineTask(vector<Task>);//sorting according to endingtime
	vector<Task> getTimedTask(vector<Task>);//sorting according  to starting time
	vector<Task> getOverdueTask(vector<Task>);//soring alphabetically
	vector<Task> getDoneTask(vector<Task>);//sorting same as above
	vector<Task> getOngoingTask(vector<Task>);//sorting same as above
};
#endif

	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Display.h





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\DisplayWindow.cpp
	 */


#include "DisplayWindow.h"
#include <iomanip>

const char DisplayWindow::OPEN_BRACKET='[';
const char DisplayWindow::CLOSE_BRACKET=']';
const char DisplayWindow::FULL_STOP='.';



DisplayWindow::DisplayWindow(){}
DisplayWindow::~DisplayWindow(){}

//To write the tasklist in a formatted string so as to prepare it for display in GUI
void DisplayWindow::setContent(vector<Task>& tasklist){

   ostringstream oss;
   for (unsigned i = 0; i < tasklist.size(); i++){
	   oss << OPEN_BRACKET << i + 1 << FULL_STOP << CLOSE_BRACKET
		   << OPEN_BRACKET<<tasklist[i].taskName<<CLOSE_BRACKET
		   << OPEN_BRACKET << tasklist[i].startingTime << CLOSE_BRACKET
		   << OPEN_BRACKET << tasklist[i].endingTime<<CLOSE_BRACKET
		   << OPEN_BRACKET << tasklist[i].status <<CLOSE_BRACKET<< endl;
   }
        _content = oss.str();
}

string DisplayWindow::getContent(){
	   return _content;
}
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\DisplayWindow.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\DisplayWindow.h
	 */


#ifndef DISPLAYWINDOW_H
#define DISPLAYWINDOW_H
#include <vector>
#include <string>
#include <sstream>
#include "Task.h"


//This class to format the tasklist and prepare it ready for display in GUI
//When the content is required, the formatted string of the tasks will be returned

class DisplayWindow{

private:

	string _content;
	static const char OPEN_BRACKET;
	static const char CLOSE_BRACKET;
	static const char FULL_STOP;

public:

	DisplayWindow();
	~DisplayWindow();

	void setContent(vector<Task>&);
	string getContent();
	

};

#endif
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\DisplayWindow.h





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Sorter.cpp
	 */

//This is the sorting algorithm for ending time
bool cmpEndingTime(Task a, Task b){

	TransformTime time;
	time_t timeA = time.stringToTime(a.endingTime);
	time_t timeB = time.stringToTime(b.endingTime);
	if (timeA < timeB){
		return true;
	}
	else {
		return false;
	}

}


//This is the sorting algorithm for starting time
bool cmpStartingTime(Task a, Task b){

	TransformTime time;
	time_t timeA = time.stringToTime(a.startingTime);
	time_t timeB = time.stringToTime(b.startingTime);
	if (timeA < timeB){
		return true;
	}
	else {
		return false;
	}

}


vector<Task> Sorter::sortFloatingTaskList(vector<Task> tasklist){

	sort(tasklist.begin(), tasklist.end(), cmpName);
	for (unsigned i = 1; i < tasklist.size() ; i++){
		assert(tasklist[i-1].taskName < tasklist[i].taskName);
		//make sure the list is properly sorted
	}
	return tasklist;
}

vector<Task> Sorter::sortDeadlineTaskList(vector<Task> tasklist){
	sort(tasklist.begin(), tasklist.end(), cmpEndingTime);
	for (unsigned i = 1; i < tasklist.size(); i++){
		assert(tasklist[i-1].endingTime < tasklist[i].endingTime);
		//make sure the list is properly sorted
	}
	return tasklist;
}

vector<Task> Sorter::sortTimedTaskList(vector<Task> tasklist){
	sort(tasklist.begin(), tasklist.end(), cmpStartingTime);
	for (unsigned i = 1; i < tasklist.size(); i++){
		assert(tasklist[i-1].startingTime < tasklist[i].startingTime);
		//make sure the list is properly sorted
	}
	return tasklist;
}


vector<Task> Sorter::sortOverdueTaskList(vector<Task> tasklist){
	sort(tasklist.begin(), tasklist.end(), cmpName);
	for (unsigned i = 1; i < tasklist.size(); i++){
		assert(tasklist[i-1].taskName < tasklist[i].taskName);
		//make sure the list is properly sorted
	}
	return tasklist;
}


vector<Task> Sorter::sortDoneTaskList(vector<Task> tasklist){
	sort(tasklist.begin(), tasklist.end(), cmpName);
	for (unsigned i = 1; i < tasklist.size(); i++){
		assert(tasklist[i-1].taskName < tasklist[i].taskName);
		//make sure the list is properly sorted
	}
	return tasklist;
}

vector<Task> Sorter::sortOngoingTaskList(vector<Task> tasklist){
	sort(tasklist.begin(), tasklist.end(), cmpName);
	for (unsigned i = 1; i < tasklist.size(); i++){
		assert(tasklist[i-1].taskName < tasklist[i].taskName);
		//make sure the list is properly sorted
	}
	return tasklist;
}
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Sorter.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Sorter.h
	 */


#ifndef SORTER_H
#define SORTER_H

#include <vector>
#include <string>
#include <algorithm>
#include "Task.h"
#include "TransformTime.h"

//This class is to sort the target list according a specific algorithm
//It is called when a specific display type is required
//Different type of tasks will be sorted differently
//For e.g Floating Ongoing Overdue Done tasks are sorted accroding to 
//alphabetical order of task name
//Deadline tasks are sorted according to ascending endingTime
//Timed tasks are sorted accordingt to ascending startingTime

class Sorter{
private:



public:

	vector<Task> sortFloatingTaskList(vector<Task>);
	vector<Task> sortDeadlineTaskList(vector<Task>);
	vector<Task> sortTimedTaskList(vector<Task>);
	vector<Task> sortDoneTaskList(vector<Task>);
	vector<Task> sortOverdueTaskList(vector<Task>);
	vector<Task> sortOngoingTaskList(vector<Task>);
};

#endif
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\Sorter.h





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\TimeChecker.cpp
	 */


#include "TimeChecker.h"
#include "Logger.h"

const string TimeChecker::NON_TARGET_TYPE = "floating";
const string TimeChecker::STATUS_OVERDUE = "overdue";
const string TimeChecker::STATUS_ONGOING = "ongoing";
const string TimeChecker::MESSAGE_MARKOVERDUE = "Task\"%s\" is marked as overdue";

TimeChecker::TimeChecker(){};
TimeChecker::~TimeChecker(){};


//To update non-floating and ongoing task's status if it is overdue
//logger is used to keep track which task is marked as overdue 
void TimeChecker::updateStatus(vector<Task>& tasklist){
	RHLogger logger = RHLogger::getInstance();

	for (unsigned i = 0; i < tasklist.size(); i++){
		if (tasklist[i].type != NON_TARGET_TYPE){
			if (checkStatus(tasklist[i].endingTime) && tasklist[i].status == STATUS_ONGOING){
				tasklist[i].status = STATUS_OVERDUE;
				string indexString = to_string(i);
				sprintf_s(outputBuffer, MESSAGE_MARKOVERDUE.c_str(), indexString.c_str());
				logger.addLog(outputBuffer);
				logger.saveLog();
			}
		}
	}
}

//To compare current time with endingTime of a task
//If the time is passed, the task is said to be overdue
bool TimeChecker::checkStatus(string endingTime){

	bool isOverdue = false;
	string currentTime = _transformTime.getCurrentTime();
	time_t currentT = _transformTime.stringToTime(currentTime);
	time_t endTime = _transformTime.stringToTime(endingTime);
	if (currentT > endTime){
		isOverdue = true;
	}
	return isOverdue;
}    



	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\TimeChecker.cpp





	/**
	 * origin: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\TimeChecker.h
	 */


#ifndef TIMECHECKER_H
#define TIMECHECKER_H
#include <time.h>
#include <iostream>
#include <vector>
#include <string>
#include "Task.h"
#include "TransformTime.h"


#define MAX_CHAR 255

//timeChecker is a class in charge of checking the endingTime of a task 
//against the system time and update the status to overdue accordingly. 
//The class is to support the refresh function of the program.
class TimeChecker{

private:
	TransformTime _transformTime;
	static const string NON_TARGET_TYPE;
	static const string STATUS_OVERDUE;
	static const string STATUS_ONGOING;
	static const string MESSAGE_MARKOVERDUE;
public:
	char outputBuffer[MAX_CHAR];
	void updateStatus(vector<Task>&);
	bool checkStatus(string);

	TimeChecker();
	~TimeChecker();
};

#endif
	// End of segment: C:\Users\svmsung\Desktop\cs\V0.5\RHV0.5\RHV0.5\TimeChecker.h





