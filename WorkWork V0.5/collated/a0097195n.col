//@author: a0097195n



	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWUI.cpp
	 */

#include "WWUI.h"
//magic strings used for logging
const std::string WWUI::LOG_USER_INPUT = "User Input: ";	
const std::string WWUI::LOG_DISPLAY = "WWUI display function called";
const std::string WWUI::LOG_DISPLAY_SYSTEM_RESPONSE = "WWUI displaySystemResponse function called";
const std::string WWUI::LOG_GET_FLOATING_TASK = "WWUI getFloatingTask function called";
const std::string WWUI::LOG_GET_PAGE_INDEX = "WWUI getPageIndex function called";

WWUI::WWUI() {
}

//This method passes the user input and the current PageIndex to WWLogic
void WWUI::runProgram(std::string userInput, int PageIndex) {
	WWLogger& logUI = WWLogger::getInstance();
	logUI.addLog(LOG_USER_INPUT + userInput);

	WWUtilities::PageType pageType = _convert.changeFromIntToPageType(PageIndex);
	_logic.runInput(userInput, pageType);
	_display = _logic.getDisplay();
	logUI.saveLog();
}

//This method gets the main display from WWdisplay and return it as a vector of vector of string
std::vector<std::vector<std::string>> WWUI::display() {
	WWLogger& logUI = WWLogger::getInstance();
	logUI.addLog(LOG_DISPLAY);
	logUI.saveLog();
	_taskContent = _display.getMainDisplay();
	return _taskContent;
}

//This method gets the system response from WWdisplay and return it as a string
std::string WWUI::displaySystemResponse() {
	WWLogger& logUI = WWLogger::getInstance();
	logUI.addLog(LOG_DISPLAY_SYSTEM_RESPONSE);
	logUI.saveLog();
	_systemResponse = _display.getSystemResponse();
	return _systemResponse;
}

//This method gets a random floating task from WWdisplay and return it as a string
std::string WWUI::getFloatingTask() {
	WWLogger& logUI = WWLogger::getInstance();
	logUI.addLog(LOG_GET_FLOATING_TASK);
	logUI.saveLog();
	_currentFloatingTask = _display.getFloatingTask();
	return _currentFloatingTask;
}

//This method gets the appropriate PageIndex from WWdisplay to display the tasks
int WWUI::getPageIndex() {
	WWLogger& logUI = WWLogger::getInstance();
	logUI.addLog(LOG_GET_PAGE_INDEX);
	logUI.saveLog();
	_currentPageIndex = _display.getPageIndex();
	return _currentPageIndex;
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWUI.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWUIConverter.cpp
	 */

#include "WWUIConverter.h"

WWUIConverter::WWUIConverter() {
}

//This method converts an integer value to PageType ( enumeration declared in WWUtilities)
WWUtilities::PageType WWUIConverter::changeFromIntToPageType(int PageIndex) {

	switch(PageIndex) {
		case 0: {
			_pageType = WWUtilities::PAGEALL;
			break;
		}
		case 1: {
			_pageType = WWUtilities::PAGEDEADLINE;
			break; 
		}
		case 2: {
			_pageType = WWUtilities::PAGETIMED;
			break;
		}
		case 3: {
			_pageType = WWUtilities::PAGEFLOATING;
			break; 
		}
		case 4: {
			_pageType = WWUtilities::PAGETODAY;
			break;
		}
		case 5: {
			_pageType = WWUtilities::PAGEDONE;
			break; 
		}
		case 6: {
			_pageType = WWUtilities::PAGEUNDONE;
			break;
		}
		case 7: {
			_pageType = WWUtilities::PAGEOVERDUE;
			break; 
		}
		case 8: {
			_pageType = WWUtilities::PAGESEARCH;
			break; 
		}
		default: {
			_pageType = WWUtilities::PAGEINVALID;
		 }
	}
	return _pageType;
}


	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWUIConverter.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWSystemTest.cpp
	 */

//Description: All available commands to user are being tested
//             Each test case will include the testing of page index, system response,
//             and the list of tasks that will be displayed to the user
//             Different options of viewing will have a different page index 
//             System Response will display the feedback to inform the user 
//             the outcome of the last input he entered.
//             List of tasks contains all the tasks that the user has entered

#include "stdafx.h"
#include "CppUnitTest.h"
#include "WWUtilities.h"
#include "WWUI.h"

const int ALL_PAGE_INDEX                  = 0;
const int DEADLINE_PAGE_INDEX             = 1;
const int TIMED_PAGE_INDEX                = 2;
const int FLOATING_PAGE_INDEX             = 3;
const int TODAY_PAGE_INDEX                = 4;
const int COMPLETE_PAGE_INDEX             = 5;
const int INCOMPLETE_PAGE_INDEX           = 6;
const int OVERDUE_PAGE_INDEX              = 7;
const int SEARCH_PAGE_INDEX               = 8;

const std::string COMPLETE                = "complete";
const std::string INCOMPLETE              = "incomplete";
const std::string OVERDUE                 = "overdue";

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace WorkWorkTest
{
	TEST_CLASS(WWSystemTest)
	{
	public:
		//TC1: adding deadline task
		TEST_METHOD(test_addDeadline) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1 23nov", ALL_PAGE_INDEX);
			//checking of page index
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expected = "All floating task done!";
			std::string actual = WorkWork.getFloatingTask();
			Assert::AreEqual(expected, actual);
			//checking for appropriate system response
			std::string expectedSysResp = "taskname 1 created";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			//checking for the list of tasks shown to user
			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 1", "Due  : 23 Nov 2014", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			//clearing all tasks previously entered
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}

		//TC2: adding timed task
		TEST_METHOD(test_addTimed) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expected = "All floating task done!";
			std::string actual = WorkWork.getFloatingTask();
			Assert::AreEqual(expected,actual);

			std::string expectedSysResp = "taskname 2 created";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 2", "From: 11 Mar 2014, 08:00am\nTo     : 23 Mar 2014, 10:00pm", OVERDUE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}

		//TC3: adding floating task
		TEST_METHOD(test_addFloating) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 3", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expected = "taskname 3";
			std::string actual = WorkWork.getFloatingTask();
			Assert::AreEqual(expected, actual);

			std::string expectedSysResp = "taskname 3 created";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 3", "", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}

		//TC4: deleting a negative index
		TEST_METHOD(test_delete_NegativeIndex) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 4", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete -1", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expected = "taskname 4";
			std::string actual = WorkWork.getFloatingTask();
			Assert::AreEqual(expected, actual);

			std::string expectedSysResp = "Index not found";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			
			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 4", "", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC5: deleting an index that is out of range (only has 4 tasks but the user delete no.5)
		TEST_METHOD(test_delete_OutOfRangeIndex) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 3", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 4", ALL_PAGE_INDEX);
			//trying to delete an invalid index(at the boundary)
			WorkWork.runProgram("delete 5", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);
			
			std::string expectedSysResp = "Index not found";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			//trying to delete an invalid index(not at the boundary)
			WorkWork.runProgram("delete 25", ALL_PAGE_INDEX);
			expectedSysResp = "Index not found";
			actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array1[] = { "taskname 1", "", INCOMPLETE};
			std::string array2[] = { "taskname 2", "", INCOMPLETE};
			std::string array3[] = { "taskname 3", "", INCOMPLETE};
			std::string array4[] = { "taskname 4", "", INCOMPLETE};
			std::vector<std::string> test1 (array1, array1 + 3 );
			std::vector<std::string> test2 (array2, array2 + 3);
			std::vector<std::string> test3 (array3, array3 + 3);
			std::vector<std::string> test4 (array4, array4 + 3);
			expectedListOfTasks.push_back(test1);
			expectedListOfTasks.push_back(test2);
			expectedListOfTasks.push_back(test3);
			expectedListOfTasks.push_back(test4);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			Assert::AreEqual(expectedListOfTasks[1][0], actualListOfTasks[1][0]);
			Assert::AreEqual(expectedListOfTasks[1][1], actualListOfTasks[1][1]);
			Assert::AreEqual(expectedListOfTasks[1][2], actualListOfTasks[1][2]);
			Assert::AreEqual(expectedListOfTasks[2][0], actualListOfTasks[2][0]);
			Assert::AreEqual(expectedListOfTasks[2][1], actualListOfTasks[2][1]);
			Assert::AreEqual(expectedListOfTasks[2][2], actualListOfTasks[2][2]);
			Assert::AreEqual(expectedListOfTasks[3][0], actualListOfTasks[3][0]);
			Assert::AreEqual(expectedListOfTasks[3][1], actualListOfTasks[3][1]);
			Assert::AreEqual(expectedListOfTasks[3][2], actualListOfTasks[3][2]);

			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC6: deleting an index that is valid 
		TEST_METHOD(test_delete_ValidIndex) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expectedSysResp = "taskname 2 deleted";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 1", "", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}

		//TC7: editing the taskname of a task  
		TEST_METHOD(test_editTaskname) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("edit 1 taskname 3", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expectedSysResp = "taskname 3 edited";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 3", "", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}

		//TC8: editing the task to a deadline task
		TEST_METHOD(test_edit_TaskToDeadlineTask) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("edit 1 23nov", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expectedSysResp = "taskname 1 edited";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 1", "Due  : 23 Nov 2014", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}

		//TC9: editing the task to a timed task
		TEST_METHOD(test_edit_TaskToTimedTask) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("edit 1 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expectedSysResp = "taskname 1 edited";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 1", "From: 11 Mar 2014, 08:00am\nTo     : 23 Mar 2014, 10:00pm", OVERDUE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}

		//TC10: testing the complete command
		TEST_METHOD(test_complete) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 3 23 Nov 2014", ALL_PAGE_INDEX);
			WorkWork.runProgram("complete 1", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expectedSysResp = "taskname 3 is marked as completed";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 3", "Due  : 23 Nov 2014", COMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);

			WorkWork.runProgram("complete 1", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			expectedSysResp = "taskname 3 is already completed";
			actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			actualListOfTasks = WorkWork.display();
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC11: testing the incomplete command
		TEST_METHOD(test_incomplete) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("incomplete 1", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expectedSysResp = "taskname 4 is already incomplete";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 4", "Due  : 23 Nov 2014", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);

			WorkWork.runProgram("complete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("incomplete 1", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			expectedSysResp = "taskname 4 is marked as incomplete";
			actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);
			actualListOfTasks = WorkWork.display();
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC12: viewing different modes of display: in this case viewing all tasks
		TEST_METHOD(test_viewAll) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("view all", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 1", "", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0],actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1],actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2],actualListOfTasks[0][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}

		//TC13: viewing deadline tasks
		TEST_METHOD(test_viewDeadline) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("view deadline", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEDEADLINE);

			std::string expectedSysResp = "You have 1 deadline tasks in total";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 4", "Due  : 23 Nov 2014", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("view all", DEADLINE_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC14: viewing timed tasks
		TEST_METHOD(test_viewTimed) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 3 11jan2014 0600h 23jan2014 1600h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("view timed", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGETIMED);

			std::string expectedSysResp = "You have 2 timed tasks in total";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp, actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array1[] = {"taskname 3", "From: 11 Jan 2014, 06:00am\nTo     : 23 Jan 2014, 04:00pm", OVERDUE};
			std::string array2[] = {"taskname 2", "From: 11 Mar 2014, 08:00am\nTo     : 23 Mar 2014, 10:00pm", OVERDUE};
			std::vector<std::string> test1 (array1, array1 + 3);
			std::vector<std::string> test2 (array2, array2 + 3);
			expectedListOfTasks.push_back(test1);
			expectedListOfTasks.push_back(test2);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			Assert::AreEqual(expectedListOfTasks[1][0], actualListOfTasks[1][0]);
			Assert::AreEqual(expectedListOfTasks[1][1], actualListOfTasks[1][1]);
			Assert::AreEqual(expectedListOfTasks[1][2], actualListOfTasks[1][2]);
			WorkWork.runProgram("view all", TIMED_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC15: viewing floating tasks
		TEST_METHOD(test_viewFloating) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 3 11jan2014 0600h 23jan2014 1200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("view floating", ALL_PAGE_INDEX);

			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEFLOATING);
			std::string expectedSysResp = "You have 1 floating tasks in total";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp,actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array[] = {"taskname 1", "", INCOMPLETE};
			std::vector<std::string> test (array, array + 3);
			expectedListOfTasks.push_back(test);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			WorkWork.runProgram("view all", TIMED_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC16: viewing completed tasks
		TEST_METHOD(test_viewComplete) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 3 11jan2014 0600h 23jan2014 1400h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("complete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("complete 3", ALL_PAGE_INDEX);
			WorkWork.runProgram("view complete", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEDONE);

			std::string expectedSysResp = "You have 2 completed tasks in total";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp,actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array1[] = {"taskname 1","", COMPLETE};
			std::string array2[] = {"taskname 3", "From: 11 Jan 2014, 06:00am\nTo     : 23 Jan 2014, 02:00pm", COMPLETE};
			std::vector<std::string> test1 (array1, array1 + 3);
			std::vector<std::string> test2 (array2, array2 + 3);
			expectedListOfTasks.push_back(test1);
			expectedListOfTasks.push_back(test2);
			Assert::AreEqual(expectedListOfTasks[0][0], actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1], actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2], actualListOfTasks[0][2]);
			Assert::AreEqual(expectedListOfTasks[1][0], actualListOfTasks[1][0]);
			Assert::AreEqual(expectedListOfTasks[1][1], actualListOfTasks[1][1]);
			Assert::AreEqual(expectedListOfTasks[1][2], actualListOfTasks[1][2]);
			WorkWork.runProgram("view all", TIMED_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC17: viewing incompleted tasks
		TEST_METHOD(test_viewIncomplete) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 3 11jan2014 0600h 23jan2014 1400h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("complete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("complete 3", ALL_PAGE_INDEX);
			WorkWork.runProgram("view incomplete", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEUNDONE);

			std::string expectedSysResp = "You have 2 incomplete tasks in total";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp,actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array1[] = {"taskname 2", "From: 11 Mar 2014, 08:00am\nTo     : 23 Mar 2014, 10:00pm", OVERDUE};
			std::string array2[] = {"taskname 4", "Due  : 23 Nov 2014", INCOMPLETE};
			std::vector<std::string> test1 (array1, array1 + 3);
			std::vector<std::string> test2 (array2, array2 + 3);
			expectedListOfTasks.push_back(test1);
			expectedListOfTasks.push_back(test2);
			Assert::AreEqual(expectedListOfTasks[0][0],actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1],actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2],actualListOfTasks[0][2]);
			Assert::AreEqual(expectedListOfTasks[1][0],actualListOfTasks[1][0]);
			Assert::AreEqual(expectedListOfTasks[1][1],actualListOfTasks[1][1]);
			Assert::AreEqual(expectedListOfTasks[1][2],actualListOfTasks[1][2]);
			WorkWork.runProgram("view all", TIMED_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
		//TC18: viewing overdue tasks
		TEST_METHOD(test_viewOverdue) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 3 11jan2014 0600h 23jan2014 1400h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("complete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("complete 3", ALL_PAGE_INDEX);
			WorkWork.runProgram("view overdue", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEOVERDUE);

			std::string expectedSysResp = "You have 2 overdue tasks in total";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp,actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array1[] = {"taskname 2", "From: 11 Mar 2014, 08:00am\nTo     : 23 Mar 2014, 10:00pm", OVERDUE};
			std::string array2[] = {"taskname 3", "From: 11 Jan 2014, 06:00am\nTo     : 23 Jan 2014, 02:00pm", COMPLETE};
			std::vector<std::string> test1 (array1, array1 + 3);
			std::vector<std::string> test2 (array2, array2 + 3);
			expectedListOfTasks.push_back(test1);
			expectedListOfTasks.push_back(test2);
			Assert::AreEqual(expectedListOfTasks[0][0],actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1],actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2],actualListOfTasks[0][2]);
			Assert::AreEqual(expectedListOfTasks[1][0],actualListOfTasks[1][0]);
			Assert::AreEqual(expectedListOfTasks[1][1],actualListOfTasks[1][1]);
			Assert::AreEqual(expectedListOfTasks[1][2],actualListOfTasks[1][2]);
			WorkWork.runProgram("view all", TIMED_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);	
		}
		
		//TC19: testing the redo command
		TEST_METHOD(test_redo) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 3 11jan2014 0600h 23jan2014 1400h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("undo", ALL_PAGE_INDEX);
			WorkWork.runProgram("redo", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expectedSysResp = "Redo successful";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp,actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array1[] = {"taskname 2", "From: 11 Mar 2014, 08:00am\nTo     : 23 Mar 2014, 10:00pm", OVERDUE};
			std::string array3[] = {"taskname 1", "", INCOMPLETE};
			std::string array2[] = {"taskname 4", "Due  : 23 Nov 2014", INCOMPLETE};
			std::vector<std::string> test1 (array1, array1 + 3);
			std::vector<std::string> test2 (array2, array2 + 3);
			std::vector<std::string> test3 (array3, array3 + 3);
			expectedListOfTasks.push_back(test1);
			expectedListOfTasks.push_back(test2);
			expectedListOfTasks.push_back(test3);
			Assert::AreEqual(expectedListOfTasks[0][0],actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1],actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2],actualListOfTasks[0][2]);
			Assert::AreEqual(expectedListOfTasks[1][0],actualListOfTasks[1][0]);
			Assert::AreEqual(expectedListOfTasks[1][1],actualListOfTasks[1][1]);
			Assert::AreEqual(expectedListOfTasks[1][2],actualListOfTasks[1][2]);
			Assert::AreEqual(expectedListOfTasks[2][0],actualListOfTasks[2][0]);
			Assert::AreEqual(expectedListOfTasks[2][1],actualListOfTasks[2][1]);
			Assert::AreEqual(expectedListOfTasks[2][2],actualListOfTasks[2][2]);
			WorkWork.runProgram("view all", TIMED_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);		
		}

		//TC20: testing the uno command
		TEST_METHOD(test_undo) {
			WWUI WorkWork;
			WorkWork.runProgram("add taskname 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 2 11mar2014 0800h 23mar2014 2200h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 3 11jan2014 0600h 23jan2014 1400h", ALL_PAGE_INDEX);
			WorkWork.runProgram("add taskname 4 23nov", ALL_PAGE_INDEX);
			WorkWork.runProgram("undo", ALL_PAGE_INDEX);
			Assert::AreEqual(WorkWork.getPageIndex(), (int)WWUtilities::PAGEALL);

			std::string expectedSysResp = "Undo successful";
			std::string actualSysResp = WorkWork.displaySystemResponse();
			Assert::AreEqual(expectedSysResp,actualSysResp);

			std::vector<std::vector<std::string>> expectedListOfTasks; 
			std::vector<std::vector<std::string>> actualListOfTasks = WorkWork.display();
			std::string array1[] = {"taskname 3", "From: 11 Jan 2014, 06:00am\nTo     : 23 Jan 2014, 02:00pm", OVERDUE};
			std::string array2[] = {"taskname 2", "From: 11 Mar 2014, 08:00am\nTo     : 23 Mar 2014, 10:00pm", OVERDUE};
			std::string array3[] = {"taskname 1", "", INCOMPLETE};
			std::vector<std::string> test1 (array1, array1 + 3);
			std::vector<std::string> test2 (array2, array2 + 3);
			std::vector<std::string> test3 (array3, array3 + 3);
			expectedListOfTasks.push_back(test1);
			expectedListOfTasks.push_back(test2);
			expectedListOfTasks.push_back(test3);
			Assert::AreEqual(expectedListOfTasks[0][0],actualListOfTasks[0][0]);
			Assert::AreEqual(expectedListOfTasks[0][1],actualListOfTasks[0][1]);
			Assert::AreEqual(expectedListOfTasks[0][2],actualListOfTasks[0][2]);
			Assert::AreEqual(expectedListOfTasks[1][0],actualListOfTasks[1][0]);
			Assert::AreEqual(expectedListOfTasks[1][1],actualListOfTasks[1][1]);
			Assert::AreEqual(expectedListOfTasks[1][2],actualListOfTasks[1][2]);
			Assert::AreEqual(expectedListOfTasks[2][0],actualListOfTasks[2][0]);
			Assert::AreEqual(expectedListOfTasks[2][1],actualListOfTasks[2][1]);
			Assert::AreEqual(expectedListOfTasks[2][2],actualListOfTasks[2][2]);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
			WorkWork.runProgram("delete 1", ALL_PAGE_INDEX);
		}
		
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWSystemTest.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWUIConverterTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"
#include "WWUtilities.h"
#include "WWUIConverter.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace UnitTest
{		
	TEST_CLASS(WWUIConverterTest)
	{
	public:
		//testing the conversion from integer to the corresponding PageType in Utilities
		TEST_METHOD(test_converter) {
			WWUIConverter _convert;
			WWUtilities::PageType pageType;

			pageType = _convert.changeFromIntToPageType(0);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGEALL);

			pageType = _convert.changeFromIntToPageType(1);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGEDEADLINE);

			pageType = _convert.changeFromIntToPageType(2);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGETIMED);

			pageType = _convert.changeFromIntToPageType(3);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGEFLOATING);

			pageType = _convert.changeFromIntToPageType(4);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGETODAY);

			pageType = _convert.changeFromIntToPageType(5);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGEDONE);

			pageType = _convert.changeFromIntToPageType(6);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGEUNDONE);

			pageType = _convert.changeFromIntToPageType(7);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGEOVERDUE);

			pageType = _convert.changeFromIntToPageType(8);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGESEARCH);

			pageType = _convert.changeFromIntToPageType(9);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGEINVALID);

			pageType = _convert.changeFromIntToPageType(100);
			Assert::AreEqual((int)pageType,(int)WWUtilities::PAGEINVALID);
		}
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWUIConverterTest.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WWGUI\main.cpp
	 */

//Description: Runs the program and displays an image to the user 
//             signalling the start of the program.

#include "wwgui.h"
#include <QtWidgets/QApplication>
#include <Windows.h>
#include <QSplashScreen>
#include <QTimer>

int main(int argc, char *argv[])
{
	QApplication a(argc, argv);
	WWGUI w;
	//To display the starting image of the program
	QPixmap pixmap(":/WWGUI/Resources/WW.png");
	QSplashScreen splash(pixmap);
	splash.show();
	//start program after 3 seconds
	QTimer::singleShot(3000, &splash, SLOT(close()));
    Sleep(3000);
	w.show();
	return a.exec();
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WWGUI\main.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WWGUI\popupdialog.cpp
	 */

#include "popupdialog.h"

const QString popUpDialog::BROWN_BACKGROUND = "background: rgb(245, 222, 179);";
const QString popUpDialog::WHITE_BACKGROUND = "background: white;";
const QString popUpDialog::FLOATING_LABEL   = "<font color='black'>Got Time? </font>";
const QString popUpDialog::SHORTCUTS_LABEL  = "<font color='black'>Shortcuts </font>";

popUpDialog::popUpDialog(QWidget *parent) : QDialog(parent) {
	ui.setupUi(this);
	setUpDialog();
}

popUpDialog::~popUpDialog() {
}

//To set up the floating task box that shows a random floating task
void popUpDialog::setFloatingTask(QString floatingTask) {
	ui.FloatingBox->setText(floatingTask);
}

//formatting the pop up dialog
void popUpDialog::setUpDialog() {
	this->setWindowFlags(Qt::FramelessWindowHint | Qt::Dialog | Qt::Popup);
	colorFormatting();
	setUpShortcutBox();
}

//To set up the display that shows the various shortcuts to the user
void popUpDialog::setUpShortcutBox() {
	const QString shortcutString = \
		"<b>Esc:</b>"
		" Clear text box<br />"
		"<br />"
		"<b>F1:</b>"
		" View all<br />"
		"<b>F2:</b>"
		" View Deadline<br />"	
		"<b>F3:</b>"
		" View Timed<br />"
		"<b>F4:</b>"
		" View Floating<br />"
		"<b>F5:</b>"
		" View Today<br />"
		"<b>F6:</b>"
		" View Complete<br />"	
		"<b>F7:</b>"
		" View Incomplete<br />"
		"<b>F8:</b>"
		" View Overdue<br />"
		"<br />"
		"<b>F12:</b>"
		" Un/Hide side windows<br />"
		"<br />"
		"<b>Ctrl + F1:</b>"
		" Help<br />"
		"<b>Ctrl + F2:</b>"
		" Minimize Window<br />";
	ui.ShortcutsBox->setText(shortcutString);
}

//formatting the background of the pop up dialog
void popUpDialog::colorFormatting() {
	this->setStyleSheet(BROWN_BACKGROUND);
	ui.FloatingText->setText(FLOATING_LABEL);
	ui.Shortcuts->setText(SHORTCUTS_LABEL);
	ui.FloatingBox->setStyleSheet(WHITE_BACKGROUND);
	ui.ShortcutsBox->setStyleSheet(WHITE_BACKGROUND);
}

//moving of the pop up dialog with mouse
void popUpDialog::mousePressEvent(QMouseEvent *event) {                                                                                                      
	this->_windowPos = this->pos();   
	this->_mousePos = event->globalPos();  
	this->_dPos = _mousePos - _windowPos;  
}  

//moving of the pop up dialog with mouse
void popUpDialog::mouseMoveEvent(QMouseEvent *event) { 
	this->move(event->globalPos() - this->_dPos);  
} 
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WWGUI\popupdialog.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WWGUI\wwgui.cpp
	 */

#include "wwgui.h"

const char WWGUI::a                            = 'a';
const char WWGUI::c                            = 'c';
const char WWGUI::d                            = 'd';
const char WWGUI::e                            = 'e';
const char WWGUI::h                            = 'h';
const char WWGUI::i                            = 'i';
const char WWGUI::o                            = 'o';
const char WWGUI::q                            = 'q';
const char WWGUI::r                            = 'r';
const char WWGUI::s                            = 's';
const char WWGUI::u                            = 'u';
const char WWGUI::v                            = 'v';

const QString WWGUI::ADD_INPUT_MSG             = "add";
const QString WWGUI::DELETE_INPUT_MSG          = "delete";
const QString WWGUI::EDIT_INPUT_MSG            = "edit";
const QString WWGUI::COMPLETE_INPUT_MSG        = "complete";
const QString WWGUI::INCOMPLETE_INPUT_MSG      = "incomplete";
const QString WWGUI::SEARCH_INPUT_MSG          = "search";
const QString WWGUI::VIEW_INPUT_MSG            = "view";
const QString WWGUI::REDO_INPUT_MSG            = "redo";
const QString WWGUI::UNDO_INPUT_MSG            = "undo";
const QString WWGUI::HELP_INPUT_MSG            = "help";
const QString WWGUI::QUIT_INPUT_MSG            = "quit";

const QString WWGUI::COMMAND_PROMPT            = "Commands available:\n[a]dd, [d]elete, [e]dit, [c]omplete, [i]ncomplete, [s]earch, [v]iew, [r]edo, [u]ndo, [h]elp, [q]uit";
const QString WWGUI::ADD_PROMPT                = "Task name is a must!\nadd [task name] {start date} {start time} {end time} {end time}";
const QString WWGUI::DELETE_PROMPT             = "Enter the index of the task\ndelete <index / all>";
const QString WWGUI::EDIT_PROMPT               = "Enter the component you wish to edit\nedit <index> [taskname] {start date} {start time} {end time} {end time}";
const QString WWGUI::COMPLETE_PROMPT           = "Which task have you completed?\ncomplete <index>";
const QString WWGUI::INCOMPLETE_PROMPT         = "Which task do you want to incomplete?\nincomplete <index>";
const QString WWGUI::SEARCH_PROMPT             = "Searching for something?\nsearch [keyword] {date} {time}";
const QString WWGUI::VIEW_PROMPT               = "\nview < all / deadline / timed / floating / today / complete / incomplete / overdue >";
const QString WWGUI::REDO_PROMPT               = "\nRedo last action? Press enter to redo";
const QString WWGUI::UNDO_PROMPT               = "\nUndo last action? Press enter to undo";
const QString WWGUI::HELP_PROMPT               = "\nhelp < add / delete/ edit / complete / incomplete/ search / view / redo / undo / quit >";
const QString WWGUI::QUIT_PROMPT               = "\nQuitting program? Press enter to quit";

const QString WWGUI::VIEW                      = "view ";
const QString WWGUI::ALL                       = "all";
const QString WWGUI::DEADLINE                  = "deadline";
const QString WWGUI::TIMED                     = "timed";
const QString WWGUI::FLOATING                  = "floating";
const QString WWGUI::TODAY                     = "today";
const QString WWGUI::COMPLETE                  = "complete";
const QString WWGUI::INCOMPLETE                = "incomplete";
const QString WWGUI::OVERDUE                   = "overdue";
const QString WWGUI::SEARCH                    = "search";

const QString WWGUI::EMPTY_QSPACE              = " ";
const QString WWGUI::EMPTY_QSTRING             = "";
const QString WWGUI::EMPTY_DISPLAY_MSG         = "You have entered nothing!";
const QString WWGUI::WORKWORK_TITLE            = "WorkWork";
const QString WWGUI::HELP_TITLE                = "Help";
const QString WWGUI::REFRESH_DISPLAY           = "refresh";
const QString WWGUI::WORKWORK_IMAGE            = ":/WWGUI/Resources/workwork.png";
const QString WWGUI::BROWN_BACKGROUND          = "background: rgb(245, 222, 179);";
const QString WWGUI::WHITE_BACKGROUND          = "background: white;";

WWGUI::WWGUI(QWidget *parent): QMainWindow(parent) {
	ui.setupUi(this);
	WorkWork = new WWUI();
	setUpUI();
}

WWGUI::~WWGUI() {
	//hides the trayicon before exiting the program
	trayIcon->hide();
	delete WorkWork;
}

//setting up the UI
void WWGUI::setUpUI() {
	setUpConnections();
	setUpTable();
	setUpShortcuts();
	setUpFormatting();
	setUpTrayIcon();
	setUpDisplay();
}

//setting up the connections(signals and slots).
void WWGUI::setUpConnections() {
	connect(ui.Input, SIGNAL(textEdited(QString)), this,SLOT(promptMsg()));
	connect(ui.Input, SIGNAL(textEdited(QString)), this, SLOT(checkAlphabet()));
	connect(ui.Input, SIGNAL(returnPressed()), this, SLOT(run()));
	connect(ui.MinimizeButton, SIGNAL(clicked()), this, SLOT(minimizeWindow()));
	connect(ui.CloseButton, SIGNAL(clicked()), this, SLOT(closeWindow()));
	QTimer *timer = new QTimer();
	connect(timer, SIGNAL(timeout()), this, SLOT(refreshDisplay()));
	timer->start(TEN_SEC);
}

//formatting the table
void WWGUI::setUpTable() {
	setColumnWidth();
	fixColumnWidth();
}

//initialising the shortcuts 
void WWGUI::setUpShortcuts() {
	//for viewing different types of tasks
	new QShortcut(Qt::Key_F1, this, SLOT(viewAll()));
	new QShortcut(Qt::Key_F2, this, SLOT(viewDeadline()));
	new QShortcut(Qt::Key_F3, this, SLOT(viewTimed()));
	new QShortcut(Qt::Key_F4, this, SLOT(viewFloating()));
	new QShortcut(Qt::Key_F5, this, SLOT(viewToday()));
	new QShortcut(Qt::Key_F6, this, SLOT(viewComplete()));
	new QShortcut(Qt::Key_F7, this, SLOT(viewIncomplete()));
	new QShortcut(Qt::Key_F8, this, SLOT(viewOverdue()));
	//for displaying the side window (shows a random floating task and the shortcuts available to the user)
	new QShortcut(Qt::Key_F12, this, SLOT(popDialog()));
	//clears the entire text in input box
	new QShortcut(Qt::Key_Escape, this, SLOT(clearText()));
	//for scrollbars 
	new QShortcut(Qt::Key_Up, this, SLOT(scrollUp()));
	new QShortcut(Qt::Key_Down, this, SLOT(scrollDown()));
	new QShortcut(Qt::Key_PageUp, this, SLOT(scrollUp()));
	new QShortcut(Qt::Key_PageDown, this, SLOT(scrollDown()));
	//for general help
	new QShortcut(Qt::CTRL + Qt::Key_F1, this, SLOT(helpFunction()));
	//for minimizing program
	new QShortcut(Qt::CTRL + Qt::Key_F2, this, SLOT(minimizeWindow()));
}

void WWGUI::setUpFormatting() {
	//removing the border of main window
	this->setWindowFlags(Qt::FramelessWindowHint | Qt::WindowSystemMenuHint | Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);
	//changing background colour to brown
	this->setStyleSheet(BROWN_BACKGROUND);
	//setting the background colour of table, input box and buttons
	ui.Table->setStyleSheet(WHITE_BACKGROUND);
	ui.Input->setStyleSheet(WHITE_BACKGROUND);
}

//initialising the trayicon for the program 
void WWGUI::setUpTrayIcon() {
	QPixmap pixmap(WORKWORK_IMAGE);
	QIcon image(pixmap);
	QMainWindow::setWindowIcon(image);
	trayIcon = new QSystemTrayIcon(image, this);
	trayIcon->show();
	trayIcon->setToolTip(WORKWORK_TITLE);
	connect(trayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, SLOT(iconIsActived(QSystemTrayIcon::ActivationReason)));
}

//initialising the display whenever the user on the program
void WWGUI::setUpDisplay() {
	welcomePrompt();
	startingDisplay();
}

//starting display 
void WWGUI::startingDisplay() {
	_PageIndex = ALL_PAGE_INDEX;
	QString viewInput = VIEW + ALL;
	runProgram(viewInput, _PageIndex);
}

//welcome prompt for the user when he first start the program
void WWGUI::welcomePrompt() {
	ui.Prompt->setText(COMMAND_PROMPT);
}

//setting the columns width of the table
void WWGUI::setColumnWidth() {
	ui.Table->setColumnCount(COLUMN_INDEX);
	ui.Table->setColumnWidth(TASK_INDEX, TASK_INDEX_LENGTH);
	ui.Table->setColumnWidth(TASK_DESC, TASK_NAME_LENGTH);
	ui.Table->setColumnWidth(DATE, DATE_LENGTH);
	ui.Table->horizontalHeader()->hide();
}

//fixing the columns width of the table
void WWGUI::fixColumnWidth() {
	for(unsigned int col = FIRST_COLUMN_INDEX ; col < COLUMN_INDEX ; col++) {
		ui.Table->horizontalHeader()->setSectionResizeMode(col, QHeaderView::Fixed);
	}
}

//updates the table with the list of tasks 
void WWGUI::updateDisplay() {
	//updates the label eg to show "ALL" to inform the user that the table is showing all tasks
	updateLabel();
	ui.Table->clearContents();
	ui.Table->setRowCount(ZERO_ROW);

	QFont font;
	font.setPointSize(FONT_SIZE_14);
	font.setBold(true);

	for (unsigned row = FIRST_ROW_INDEX; row < _listOfTasks.size(); row++) {
		ui.Table->insertRow( ui.Table->rowCount() );
		
		QString taskIndex = QString::number(row + ONE_ROW_INDEX);
		QTableWidgetItem *displayIndex = new QTableWidgetItem(taskIndex);
		displayIndex->setFont(font);
		displayIndex->setTextAlignment(Qt::AlignCenter);
		ui.Table->setItem(row, FIRST_COLUMN_INDEX, displayIndex);
		
		QTableWidgetItem *displayTaskDesc = new QTableWidgetItem(QString::fromStdString(_listOfTasks[row][FIRST_ELEMENT_INDEX]));	
		displayTaskDesc->setFont(font);
		ui.Table->setItem(row, SECOND_COLUMN_INDEX, displayTaskDesc);

		QTableWidgetItem *displayDate = new QTableWidgetItem(QString::fromStdString(_listOfTasks[row][SECOND_ELEMENT_INDEX]));	
		ui.Table->setItem(row, THIRD_COLUMN_INDEX, displayDate);
		//setting the background color of the index based on the status of the task
		if(_listOfTasks[row][THIRD_ELEMENT_INDEX] == COMPLETE.toStdString()) {
			displayIndex->setBackgroundColor(QColor(180,238,180));
		} else if(_listOfTasks[row][THIRD_ELEMENT_INDEX] == INCOMPLETE.toStdString()) {
			displayIndex->setBackgroundColor(QColor(255,255,255));
		} else if(_listOfTasks[row][THIRD_ELEMENT_INDEX] == OVERDUE.toStdString()) {
			displayIndex->setBackgroundColor(QColor(255,193,193));
		} else if(_listOfTasks[row][THIRD_ELEMENT_INDEX] == TODAY.toStdString()) {
			displayIndex->setBackgroundColor(QColor(255, 255, 100));
		}
		ui.Table->resizeRowsToContents();
	}
}

//used for the shortcuts that displays the different modes of displays
void WWGUI::displayTable(int PageIndex) {
	QString viewInput;
	switch(PageIndex) {
		case ALL_PAGE_INDEX: {
			viewInput =  VIEW + ALL;
			ui.TaskType->setText(ALL.toUpper());
			break;
		}
		case DEADLINE_PAGE_INDEX: {
			viewInput =  VIEW + DEADLINE;
			ui.TaskType->setText(DEADLINE.toUpper());
			break;
		}
		case TIMED_PAGE_INDEX: {
			viewInput = VIEW + TIMED;
			ui.TaskType->setText(TIMED.toUpper());
			break;
		}
		case FLOATING_PAGE_INDEX: {
			viewInput = VIEW + FLOATING;
			ui.TaskType->setText(FLOATING.toUpper());
			break;
		}
		case TODAY_PAGE_INDEX: {
			viewInput = VIEW + TODAY;
			ui.TaskType->setText(TODAY.toUpper());
			break;
		}
		case COMPLETE_PAGE_INDEX: {
			viewInput = VIEW + COMPLETE;
			ui.TaskType->setText(COMPLETE.toUpper());
			break;
		}
		case INCOMPLETE_PAGE_INDEX: {
			viewInput = VIEW + INCOMPLETE;
			ui.TaskType->setText(INCOMPLETE.toUpper());
			break;
		}
		case OVERDUE_PAGE_INDEX: {
			viewInput = VIEW + OVERDUE;
			ui.TaskType->setText(OVERDUE.toUpper());
			break;
		}
		case SEARCH_PAGE_INDEX: {
			viewInput = VIEW + SEARCH;
			ui.TaskType->setText(SEARCH.toUpper());
			break;
		}
		default: {
			viewInput =  VIEW + ALL;
			ui.TaskType->setText(ALL.toUpper());
		}
	}
	runProgram(viewInput,_PageIndex);
}

//updates the label that shows the types of tasks that the user is currently looking at
void WWGUI::updateLabel() {
	switch(_PageIndex) {
		case ALL_PAGE_INDEX: {
			ui.TaskType->setText(ALL.toUpper());
			break;
		}
		case DEADLINE_PAGE_INDEX: {
			ui.TaskType->setText(DEADLINE.toUpper());
			break;
		}
		case TIMED_PAGE_INDEX: {
			ui.TaskType->setText(TIMED.toUpper());
			break;
		}
		case FLOATING_PAGE_INDEX: {
			ui.TaskType->setText(FLOATING.toUpper());
			break;
		}
		case TODAY_PAGE_INDEX: {
			ui.TaskType->setText(TODAY.toUpper());
			break;
		}
		case COMPLETE_PAGE_INDEX: {
			ui.TaskType->setText(COMPLETE.toUpper());
			break;
		}
		case INCOMPLETE_PAGE_INDEX: {
			ui.TaskType->setText(INCOMPLETE.toUpper());
			break;
		}
		case OVERDUE_PAGE_INDEX: {
			ui.TaskType->setText(OVERDUE.toUpper());
			break;
		}
		case SEARCH_PAGE_INDEX: {
			ui.TaskType->setText(SEARCH.toUpper());
			break;
		}
		default: {
			ui.TaskType->setText(ALL.toUpper());
		}
	}
}

//refreshes the main display every 60 seconds
void WWGUI::refreshDisplay() {
	runProgram(REFRESH_DISPLAY, _PageIndex);
}

//sends the user input to WWUI and gets display information from WWUI, updates the side window and gives feedback to the user
// Display information received
// 1) the updated list of tasks
// 2) a random floating task
// 3) the appropriate page index to display the list of tasks 
// 4) getting the feedback for the user input and displaying it to the user  
void WWGUI::runProgram(QString input, int PageIndex) {
	WorkWork->runProgram(input.toStdString(), PageIndex);
	_listOfTasks = WorkWork->display();
	_PageIndex = WorkWork->getPageIndex();
	//floating task should not be empty string
	//a string should inform the user that there is no floating task
	_floatingTask = QString::fromStdString(WorkWork->getFloatingTask());
	assert(_floatingTask != EMPTY_QSTRING);
	_dialog.setFloatingTask(_floatingTask);
	updateDisplay();
	//system response string should not be empty
	QString _sysResp = QString::fromStdString(WorkWork->displaySystemResponse());
	assert(_sysResp != EMPTY_QSTRING);
	statusBar()->showMessage(_sysResp);
}

//Different help messages for different commands
void WWGUI::helpAdd() {
	const QString HELP_ADD = \
		"<b>Add</b><br />"
		"This command is used to add tasks to WorkWork.<br />"
		"Tasks may be timed, floating or have a deadline.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'a' for 'add'.<br />"
		"* Enter task description.<br />"
		"* Enter one date/time to specify a deadline task.<br />"
		"* Enter two dates/time to specify a timed task.<br />"
		"* No date/time is needed for floating task.<br />"
		"<br />"
		"<b>Examples</b><br />"
		"* add school project 1apr 1600h 21apr2014 0500h<br />"
		"* add Save Princess Peach 22/12/2014<br />"
		"* add Meeting 11.00am<br />"
		"* add Take afternoon nap<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_ADD);
}

void WWGUI::helpDelete() {
	const QString HELP_DELETE = \
		"<b>Delete</b><br />"
		"This command is used to delete tasks.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'd' for 'delete'.<br />"
		"* Enter the task's index.<br />"
		"* Enter 'all' to clear all tasks.<br />"
		"<br />"
		"<b>Examples</b><br />"
		"* delete 2<br />"
		"* delete all<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_DELETE);
}

void WWGUI::helpEdit() {
	const QString HELP_EDIT = \
		"<b>Edit</b><br />"
		"This command allows you to change the attributes of a task.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'e' for 'edit' followed by the task's index.<br />"
		"* Specify the changes you want to make<br />"
		"  whether to task description, start date/time or end date/time.<br />"
		"<br />"
		"<b>Examples</b><br />"
		"* edit 1 Dental appointment<br />"
		"* edit 2 12:00pm 30/10<br />"
		"* edit 1 31 Oct 9am 4Apr 5pm<br />"
		"* edit 3 2000h 2130h<br />"
		"* edit 4 Get hair cut 31/10<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_EDIT);
}

void WWGUI::helpComplete() {
	const QString HELP_COMPLETE = \
		"<b>Complete</b><br />"
		"This command marks a task as complete.<br />"
		" The index of the completed task will be marked in green.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'c' for complete.<br />"
		"* Specify the index of the task to mark it as completed.<br />"
		"<br />"
		"<b>Example</b><br />"
		"* complete 2<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_COMPLETE);
}

void WWGUI::helpIncomplete() {
	const QString HELP_INCOMPLETE = \
		"<b>Incomplete</b><br />"
		"This command marks a task as incomplete.<br />"
		" The index of the incomplete task will be marked in white.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'i' for 'incomplete'.<br />"
		"* Enter the index of the task to mark it as incomplete.<br />"
		"<br />"
		"<b>Example</b><br />"
		"* incomplete 1<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_INCOMPLETE);
}

void WWGUI::helpSearch() {
	const QString HELP_SEARCH = \
		"<b>Search</b><br />"
		"This command will search for tasks containing certain keywords.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 's' for 'search'.<br />"
		"* Enter the words you want to search.<br />"
		"<br />"
		"<b>Examples</b><br />"
		"* search boss<br />"
		"* search homework<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_SEARCH);
}

void WWGUI::helpView() {
	const QString HELP_VIEW = \
		"<b>View</b><br />"
		"This command displays all saved tasks.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'v' for 'view'. <br />"
		"* Enter a display mode. Options are 'all', 'deadline',<br />"
		"  'timed', 'floating', 'today', 'complete', 'incomplete'.<br />"
		"<br />"
		"<b>Examples</b><br />"
		"* view all<br />"
		"* view deadline<br />"
		"* view timed<br />"
		"* view floating<br />"
		"* view today<br />"
		"* view complete<br />"
		"* view incomplete<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_VIEW);
}

void WWGUI::helpRedo() {
	const QString HELP_REDO = \
		"<b>Redo</b><br />"
		"This command reverts the last 'undo' operation on the task list.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'r' for 'redo' and enter.<br />"
		"<br />"
		"<b>Examples</b><br />"
		"* redo<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_REDO);
}

void WWGUI::helpUndo() {
	const QString HELP_UNDO = \
		"<b>Undo</b><br />"
		"This command reverts the last operation on the task list.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'u' for 'undo' and enter.<br />"
		"<br />"
		"<b>Examples</b><br />"
		"* undo<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_UNDO);
}

void WWGUI::helpQuit() {
	const QString HELP_QUIT = \
		"<b>Quit</b><br />"
		"This command quits the program.<br />"
		"<br />"
		"<b>Command format</b><br />"
		"* Press 'q' for 'quit' and enter.<br />"
		"<br />"
		"<b>Examples</b><br />"
		"* quit<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HELP_QUIT);
}

//used to display the help messages for the various different commands
void WWGUI::displayMsgBox(QString title, QString description){
	QPixmap pixmap(WORKWORK_IMAGE);
	QIcon image(pixmap);
	QMessageBox msgBox;
	msgBox.setWindowTitle(title);
	msgBox.setWindowIcon(image);
	msgBox.setText(description);
	msgBox.exec();
}

//for moving the main window 
void WWGUI::mousePressEvent(QMouseEvent *event){                                                                                                      
	this->_windowPos = this->pos();   
	this->_mousePos = event->globalPos();  
	this->_dPos = _mousePos - _windowPos; 
}  
//for moving the main window 
void WWGUI::mouseMoveEvent(QMouseEvent *event){ 
	this->move(event->globalPos() - this->_dPos);  
} 

void WWGUI::iconIsActived(QSystemTrayIcon::ActivationReason) { 
	if(isMinimized()) {
		show();
		setWindowState(Qt::WindowActive);
	} else {
		showMinimized();
	}
}
//based on the first alphabet(regardless small or capital letter) that the user has entered,
//it will autofill the command word automatically
void WWGUI::checkAlphabet() {
	QString text = ui.Input->text();	
	text = text.toLower();

	if(text[STARTING_INDEX] == a && text.length() <= (ADD_LENGTH + EMPTY_SPACE_LENGTH)) {
		ui.Input->setText(ADD_INPUT_MSG + EMPTY_QSPACE);
	} else if (text[STARTING_INDEX] == d && text.length() <= (DELETE_LENGTH + EMPTY_SPACE_LENGTH)) {
		ui.Input->setText(DELETE_INPUT_MSG + EMPTY_QSPACE);
	}  else if (text[STARTING_INDEX] == e && text.length() <= (EDIT_LENGTH + EMPTY_SPACE_LENGTH)) {
		ui.Input->setText(EDIT_INPUT_MSG + EMPTY_QSPACE);
	} else if (text[STARTING_INDEX] == c && text.length() <= (COMPLETE_LENGTH + EMPTY_SPACE_LENGTH)) {
		ui.Input->setText(COMPLETE_INPUT_MSG + EMPTY_QSPACE);
	} else if (text[STARTING_INDEX] == i && text.length() <= (INCOMPLETE_LENGTH +EMPTY_SPACE_LENGTH)) {
		ui.Input->setText(INCOMPLETE_INPUT_MSG + EMPTY_QSPACE);
	} else if (text[STARTING_INDEX] == s && text.length() <= (SEARCH_LENGTH + EMPTY_SPACE_LENGTH)) {
		ui.Input->setText(SEARCH_INPUT_MSG + EMPTY_QSPACE);
	} else if (text[STARTING_INDEX] == v && text.length() <= (VIEW_LENGTH + EMPTY_SPACE_LENGTH)) {
		ui.Input->setText(VIEW_INPUT_MSG + EMPTY_QSPACE);
	} else if (text[STARTING_INDEX] == r) {
		ui.Input->setText(REDO_INPUT_MSG);
	} else if (text[STARTING_INDEX] == u) {
		ui.Input->setText(UNDO_INPUT_MSG);
	} else if (text[STARTING_INDEX] == h && text.length() <= (HELP_LENGTH + EMPTY_SPACE_LENGTH)) {
		ui.Input->setText(HELP_INPUT_MSG + EMPTY_QSPACE);
	} else if (text[STARTING_INDEX] == q) {
		ui.Input->setText(QUIT_INPUT_MSG);
	} 
}
//alternative way to clear the text in the input box quickly
void WWGUI::clearText() {
	ui.Input->clear();
	ui.Prompt->setText(COMMAND_PROMPT);
}
//for setting up shortcuts for scrolling up the table
void WWGUI::scrollUp() {
	ui.Table->verticalScrollBar()->setSliderPosition(ui.Table->verticalScrollBar()->sliderPosition() - ui.Table->verticalScrollBar()->pageStep());
}
//for setting up shortcuts for scrolling down the table
void WWGUI::scrollDown() {
	ui.Table->verticalScrollBar()->setSliderPosition(ui.Table->verticalScrollBar()->sliderPosition() + ui.Table->verticalScrollBar()->pageStep());
}
//the view functions used for shortcuts. Shortcuts display different displays modes such as all, deadline, etc.
void WWGUI::viewAll() {
	displayTable(ALL_PAGE_INDEX);
}

void WWGUI::viewDeadline() {
	displayTable(DEADLINE_PAGE_INDEX);
}

void WWGUI::viewTimed() {
	displayTable(TIMED_PAGE_INDEX);
}

void WWGUI::viewFloating() {
	displayTable(FLOATING_PAGE_INDEX);
}

void WWGUI::viewToday() {
	displayTable(TODAY_PAGE_INDEX);
}

void WWGUI::viewComplete() {
	displayTable(COMPLETE_PAGE_INDEX);
}

void WWGUI::viewIncomplete() {
	displayTable(INCOMPLETE_PAGE_INDEX);
}

void WWGUI::viewOverdue() {
	displayTable(OVERDUE_PAGE_INDEX);
}
//activated when user presses enter
//processes userinput to check for help command and empty string
//Otherwise, user input will be sent to WWUI to process
void WWGUI::run() {
	ui.Prompt->setText(COMMAND_PROMPT);
	QString userInput = ui.Input->text();
	QString checkHelp = userInput.toLower();
	ui.Input->setText(EMPTY_QSTRING);
	try {
		//if userinput is empty will display to user a empty input message
		if(userInput == EMPTY_QSTRING) {
			throw EMPTY_QSTRING;
		}
		if( checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE ) {
			helpFunction();
		} else if( checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + ADD_INPUT_MSG ) {
			helpAdd();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + DELETE_INPUT_MSG ) {
			helpDelete();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + EDIT_INPUT_MSG ) {
			helpEdit();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + COMPLETE_INPUT_MSG ) {
			helpComplete();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + INCOMPLETE_INPUT_MSG ) {
			helpIncomplete();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + SEARCH_INPUT_MSG ) {
			helpSearch();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + VIEW_INPUT_MSG ) {
			helpView();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + REDO_INPUT_MSG ) {
			helpRedo();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + UNDO_INPUT_MSG ) {
			helpUndo();
		} else if (checkHelp == HELP_INPUT_MSG + EMPTY_QSPACE + QUIT_INPUT_MSG ) {
			helpQuit();
		} else {
			runProgram(userInput, _PageIndex);
		}
	} catch (QString) {
		ui.statusBar->showMessage(EMPTY_DISPLAY_MSG);
	}
}
//displays a prompt msg to aid the user in entering a valid user input
void WWGUI::promptMsg() {
	QString text = ui.Input->text();
	text = text.toLower();
	if(text == EMPTY_QSTRING) {
		ui.Prompt->setText(COMMAND_PROMPT);
	} else {
		if(text[STARTING_INDEX] == a ) {
			ui.Prompt->setText(ADD_PROMPT);
		} else if (text[STARTING_INDEX] == d) {
			ui.Prompt->setText(DELETE_PROMPT);
		} else if (text[STARTING_INDEX] == e) {
			ui.Prompt->setText(EDIT_PROMPT);
		} else if (text[STARTING_INDEX] == c) {
			ui.Prompt->setText(COMPLETE_PROMPT);
		} else if (text[STARTING_INDEX] == i) {
			ui.Prompt->setText(INCOMPLETE_PROMPT);
		} else if (text[STARTING_INDEX] == s) {
			ui.Prompt->setText(SEARCH_PROMPT);
		} else if (text[STARTING_INDEX] == v) {
			ui.Prompt->setText(VIEW_PROMPT);
		} else if (text[STARTING_INDEX] == r) {
			ui.Prompt->setText(REDO_PROMPT);
		} else if (text[STARTING_INDEX] == u) {
			ui.Prompt->setText(UNDO_PROMPT);
		} else if (text[STARTING_INDEX] == h) {
			ui.Prompt->setText(HELP_PROMPT);
		} else if (text[STARTING_INDEX] == q) {
			ui.Prompt->setText(QUIT_PROMPT);
		}
	}
}
//displays the side window dialog 
void WWGUI::popDialog() {
	if(_dialog.isVisible()) {
		_dialog.close();
	} else {
		QPoint ptGlobal = this->mapToGlobal(QPoint(this->width(), 0));
		_dialog.setGeometry(QRect(ptGlobal, _dialog.size()));
		_dialog.show();
	}
}

void WWGUI::helpFunction(){
	const QString HOTKEY_LIST = \
		"<b>Commands</b><br />"
		"[a]dd, [d]elete, [e]dit, [c]omplete, [i]ncomplete<br />"	
		"[s]earch, [r]edo, [u]ndo, [v]iew, [q]uit<br />"	
		"Type 'help', followed by any of the above, to see usage tips and examples.<br />"
		"<br />";
	displayMsgBox(HELP_TITLE, HOTKEY_LIST);
}

//closes the program and the pop up dialog if it is still opened
void WWGUI::closeWindow() {
	if(_dialog.isVisible()) {
		_dialog.close();
	}
	this->close();
}

void WWGUI::minimizeWindow() {
	if(_dialog.isVisible()) {
		_dialog.close();
	}
	this->showMinimized();
}

	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WWGUI\wwgui.cpp





