//@author: a0099689w



	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWCommandInterpreter.cpp
	 */

#include <cctype>

#include "WWCommandInterpreter.h"
#include "assert.h"


using namespace std;

const int    WWCommandInterpreter::INVALID_INDEX        = -1;
const string WWCommandInterpreter::EMPTY_CONTENT        = "";
const string WWCommandInterpreter::SPACE                = " "; 
const string WWCommandInterpreter::NO_INDEX_EXCEPTION   = "No Index found£¡";
const string WWCommandInterpreter::INTERPRET_ADD_LOG    = "Interpreting add command.";
const string WWCommandInterpreter::INTERPRET_EDIT_LOG   = "Interpreting edit command.";
const string WWCommandInterpreter::INTERPRET_DELETE_LOG = "Interpreting delete command.";
const string WWCommandInterpreter::INTERPRET_DONE_LOG   = "Interpreting done command.";
const string WWCommandInterpreter::INTERPRET_UNDONE_LOG = "Interpreting undone command.";
const string WWCommandInterpreter::INTERPRET_SEARCH_LOG = "Interpreting search command.";

WWCommandInterpreter::WWCommandInterpreter(){
}

// This function extract the task to be added from the WWCommand object
// and store into a WWTask object.
// precondition : 1. The WWCommand object must have a commandType of ADD.
//                2. The WWTask object should be a empty task.  
// postcondition: task details of the new task is stored into taskToBeAdded
void WWCommandInterpreter::interpretAdd(WWCommand addCommand, WWTask& taskToBeAdded) {
	// the commandtype must be ADD in order for the method to function correctly
	assert (addCommand.getCommand() == WWUtilities::CommandType::ADD);
	
	WWLogger& logAdd = WWLogger::getInstance();
	logAdd.addLog(INTERPRET_ADD_LOG);
	logAdd.saveLog();

	if(addCommand.hasDetail()) {
		taskToBeAdded.setTaskName(addCommand.getDetail());
	} else {
		taskToBeAdded.setTaskName(EMPTY_CONTENT);
	}

	if(addCommand.hasDate1()) {
		taskToBeAdded.setStartDate(addCommand.getDate1());
	} else {
		taskToBeAdded.setStartDate(EMPTY_CONTENT);
	}

	if(addCommand.hasTime1()) {
		taskToBeAdded.setStartTime(addCommand.getTime1());
	} else {
		taskToBeAdded.setStartTime(EMPTY_CONTENT);
	}

	if(addCommand.hasDate2()) {
		taskToBeAdded.setEndDate(addCommand.getDate2());
	} else {
		taskToBeAdded.setEndDate(EMPTY_CONTENT);
	}

	if(addCommand.hasTime2()) {
		taskToBeAdded.setEndTime(addCommand.getTime2());
	} else {
		taskToBeAdded.setEndTime(EMPTY_CONTENT);
	}
}

// This function helped to identify the index of the target task to be edited
// and store the edit details into a WWTask object.
// precondition : 1.The WWCommand object must have a commandType of EDIT.
//                2.The editIndex should not be initialised before 
//                  passing to the function.
//                3.The WWTask object should be a empty task.
// postcondition: 1.The desired modification to different attributes of the 
//                  target task are stored separatedy in the taskToBeEdited.
//                2.editIndex is adjusted to the index of the target task to be edited.
void WWCommandInterpreter::interpretEdit(WWCommand editCommand, int& editIndex, WWTask& taskToBeEdited) {
	assert (editCommand.getCommand() == WWUtilities::CommandType::EDIT);
	
	WWLogger& logEdit = WWLogger::getInstance();
	logEdit.addLog(INTERPRET_EDIT_LOG);
	logEdit.saveLog();

	string editDetail = editCommand.getDetail();
	string editedTaskName;
	
	try {
		// extract the index of the target task and the new task name
	    // proposed by the user from the editDetail string.
		separateIndexDetail(editDetail, editIndex, editedTaskName); 
	} catch (string&){
		// the exception thrown indicates that the function is unable to
		// obtain a valid index in the editDetail
		editIndex = INVALID_INDEX; 
	}
	if(!editedTaskName.empty()){
		taskToBeEdited.setTaskName(editedTaskName);
	} else {
		taskToBeEdited.setTaskName(EMPTY_CONTENT);
	}

	if(editCommand.hasDate1()) {
		taskToBeEdited.setStartDate(editCommand.getDate1());
	} else {
		taskToBeEdited.setStartDate(EMPTY_CONTENT);
	}

	if(editCommand.hasTime1()) {
		taskToBeEdited.setStartTime(editCommand.getTime1());
	} else {
		taskToBeEdited.setStartTime(EMPTY_CONTENT);
	}

	if(editCommand.hasDate2()) {
		taskToBeEdited.setEndDate(editCommand.getDate2());
	} else {
		taskToBeEdited.setEndDate(EMPTY_CONTENT);
	}

	if(editCommand.hasTime2()) {
		taskToBeEdited.setEndTime(editCommand.getTime2());
	} else {
		taskToBeEdited.setEndTime(EMPTY_CONTENT);
	}
}

// This function helps to interpret the seachCommand by extracting the 
// relevant search keywords and store them in a vector of string.
// precondition : The WWCommand object must have a commandType of SEARCH.
// postcondition: The different search keywords that required by the user are extracted and
//                stored into keywordStorage separately. The vector stores a maximum of 
//                5 strings. 
void WWCommandInterpreter::interpretSearch(WWCommand searchCommand, vector<string>& keywordStorage) {
	assert (searchCommand.getCommand() == WWUtilities::CommandType::SEARCH);
	
	WWLogger& logSearch = WWLogger::getInstance();
	logSearch.addLog(INTERPRET_SEARCH_LOG);
	logSearch.saveLog();
	
	keywordStorage.clear();

	if(searchCommand.hasDetail()) {
		keywordStorage.push_back(searchCommand.getDetail());
	} else {
		keywordStorage.push_back(EMPTY_CONTENT);
	}
	
	if(searchCommand.hasDate1()) {
		keywordStorage.push_back(searchCommand.getDate1());
	} else {
		keywordStorage.push_back(EMPTY_CONTENT);
	}

	if (searchCommand.hasTime1()) {
		keywordStorage.push_back(searchCommand.getTime1());
	} else {
		keywordStorage.push_back(EMPTY_CONTENT);
	}

	if (searchCommand.hasDate2()) {
		keywordStorage.push_back(searchCommand.getDate2());
	} else {
		keywordStorage.push_back(EMPTY_CONTENT);
	}

	if (searchCommand.hasTime2()) {
		keywordStorage.push_back(searchCommand.getTime2());
	} else {
		keywordStorage.push_back(EMPTY_CONTENT);
	}

}

// precondition : The WWCommand object must have a commandType of DELETE.
// postcondition: 1. deleteIndex is adjusted to the index of the task to be deleted
//                   if the index exists, otherwise, an exception is thrown
void WWCommandInterpreter::interpretDelete(WWCommand deleteCommand, int& deleteIndex) {
	assert (deleteCommand.getCommand() == WWUtilities::CommandType::DELETE);
	
	WWLogger& logDelete = WWLogger::getInstance();
	logDelete.addLog(INTERPRET_DELETE_LOG);
	logDelete.saveLog();

	string deleteIndexString = deleteCommand.getDetail();
	try {
		deleteIndex              = convertStringToInt(deleteIndexString);
	} catch (string& ) {
		deleteIndex = INVALID_INDEX;
	}
}

// precondition : The WWCommand object must have a commandType of DONE.
// postcondition: doneIndex is adjusted to the index of the task to be marked done
//                if the index exists, otherwise, an exception is thrown
void WWCommandInterpreter::interpretDone(WWCommand doneCommand, int& doneIndex) {
	assert (doneCommand.getCommand() == WWUtilities::CommandType::DONE);

	WWLogger& logDone = WWLogger::getInstance();
	logDone.addLog(INTERPRET_DONE_LOG);
	logDone.saveLog();

	string doneIndexString = doneCommand.getDetail();

	try {
		doneIndex              = convertStringToInt(doneIndexString);
	} catch (string&) {
		doneIndex = INVALID_INDEX;
	} 
}

// precondition : The WWCommand object must have a commandType of UNDONE.
// postcondition: undoneIndex is adjusted to the index of the task to be marked undone.
//                if the index exists, otherwise, an exception is thrown
void WWCommandInterpreter::interpretUndone(WWCommand undoneCommand, int& undoneIndex) {
	assert (undoneCommand.getCommand() == WWUtilities::CommandType::UNDONE);

	WWLogger& logUndone = WWLogger::getInstance();
	logUndone.addLog(INTERPRET_UNDONE_LOG);
	logUndone.saveLog();

	string undoneIndexString = undoneCommand.getDetail();

	try {
		undoneIndex              = convertStringToInt(undoneIndexString);
	} catch (string&){
		// exception will be thrown if there is no information for index
		undoneIndex = INVALID_INDEX;
	}

}


// This function serves to separate the index of the task to be edited and the proposed 
// new task name by the user from a string editDetail.
// precondition : The index is located at the beginning of editDetail and separated
//                with the rest by a space.
// postcondition: 1. Index of the target task is stored in editIndex.
//                2. An exception is thrown if no valid index found.
//                2. The new task name is stored into editedTaskName.
void WWCommandInterpreter::separateIndexDetail(string editDetail, int& editIndex, string& editedTaskName) {
	int taskNameLocation;
	int indexLocation = editDetail.find_first_of(SPACE);

	if(indexLocation != string::npos) {
		string indexString = editDetail.substr(0, indexLocation);
		editIndex          = convertStringToInt(indexString);
		taskNameLocation = editDetail.find_first_not_of(SPACE, ++indexLocation);
		editedTaskName     = editDetail.substr(taskNameLocation);
	} else if(!editDetail.empty()) {
		editIndex = convertStringToInt(editDetail);
		editedTaskName = EMPTY_CONTENT;
	} else {
		throw NO_INDEX_EXCEPTION;
	}
	
	
}

int WWCommandInterpreter::convertStringToInt(string convertString) {
	if(convertString.empty()){
		throw NO_INDEX_EXCEPTION;
	} else {
		return atoi(convertString.c_str());
	}
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWCommandInterpreter.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWConverter.cpp
	 */

#include "WWConverter.h"

using namespace std;

const int    WWConverter::STRING_STARTING_POSITION      = 0;
const int    WWConverter::SINGLE_DIGIT_LIMIT            = 9;
const int	 WWConverter::DIGIT_MIDNIGHT				= 0;
const int	 WWConverter::DIGIT_NOON_HOUR			    = 12;
const int	 WWConverter::DIGIT_NOON_MINUTE				= 0;
const int    WWConverter::DIGIT_MIDNIGHT_TO_MERIDIEM    = 12;
const int    WWConverter::LENGTH_YEAR                   = 4;
const int    WWConverter::LENGTH_MONTH                  = 2;
const int    WWConverter::LENGTH_DAY                    = 2;
const int    WWConverter::LENGTH_HOUR                   = 2;
const int    WWConverter::LENGTH_MINUTE                 = 2;
const string WWConverter::LABEL_MORNING                 = "am";
const string WWConverter::LABEL_NOON                    = "nn";
const string WWConverter::LABEL_AFTERNOON               = "pm";
const string WWConverter::LABEL_MIDNIGHT                = "mn";
const string WWConverter::LABEL_SINGLE_DIGIT_COMPLEMENT = "0";
const string WWConverter::LABEL_COLON                   = ":";
const string WWConverter::LABEL_SPACE                   = " ";


WWConverter::WWConverter() {
}


// Change the format of the taskdate string stored in task 
// to the desired display format on the GUI.
// e.g. from "20131214" to "14 Dec 2013
// It is the client's responsibility to ensure the validity
// and format of the taskDate passed into the function.
void WWConverter::formatDateForDisplay(string& taskDate)
{
	string yearString, monthString, dayString;

	if(taskDate.empty()) {
		return;
	} else {
		yearString  = taskDate.substr(STRING_STARTING_POSITION , LENGTH_YEAR);
		monthString = taskDate.substr(LENGTH_YEAR, LENGTH_MONTH);
		dayString   = taskDate.substr(LENGTH_YEAR + LENGTH_MONTH, LENGTH_DAY);
	}

	int year  = convertStringToInt(yearString);
	int month = convertStringToInt(monthString);
	int day   = convertStringToInt(dayString);

	taskDate = getFormatedDate(day, month, year);
}
// Change the format of the tasktime string stored in task 
// to the desired display format on the GUI.
// e.g. from "1215" to "12:15pm"
// It is the client's responsibility to ensure the validity
// and format of the taskTime passed into the function.
void WWConverter::formatTimeForDisplay(string& taskTime)
{
	string hourString, minuteString;

	if(taskTime.empty()) {
		return;
	} else {
		hourString   = taskTime.substr(STRING_STARTING_POSITION, LENGTH_HOUR);
		minuteString = taskTime.substr(LENGTH_HOUR, LENGTH_MINUTE);
	}

	int hour   = convertStringToInt(hourString);
	int minute = convertStringToInt(minuteString);
	
	taskTime = getFormatedTime(hour, minute);
}


// Convert the integer hour and minute to string format
// Output format is "hhmm" which is a string of size 4.
// It is the client's responsibility to ensure the validity
// of the integer hour and minute passed into the function.
void WWConverter::convertIntTimeToString(int hour, int minute, string& timeString){
	ostringstream oss;

	if(!isSingleDigit(hour) && !isSingleDigit(minute)) {
		oss << hour << minute;
	} else if(isSingleDigit(hour) && !isSingleDigit(minute)) {
		oss << LABEL_SINGLE_DIGIT_COMPLEMENT << hour << minute;
	} else if(!isSingleDigit(hour) && isSingleDigit(minute)) {
		oss << hour << LABEL_SINGLE_DIGIT_COMPLEMENT << minute;
	} else {
		oss << LABEL_SINGLE_DIGIT_COMPLEMENT << hour << LABEL_SINGLE_DIGIT_COMPLEMENT << minute;
	}

	timeString = oss.str();
}

// Convert the integer year, month and day to a string
// Output format is "yyyymmdd" which is a string of size 8
// It is the client's responsibility to ensure the validity
// of the integer day, month and year passed into the function.
void WWConverter::convertIntDateToString(int day, int month, int year, std::string& dateString){

	ostringstream oss;

	if(!isSingleDigit(month) && !isSingleDigit(day)) {
		oss << year << month << day; 
	} else if(isSingleDigit(month) && !isSingleDigit(day)) {
		oss << year << LABEL_SINGLE_DIGIT_COMPLEMENT<< month << day;
	} else if(!isSingleDigit(month) && isSingleDigit(day)) {
		oss << year << month << LABEL_SINGLE_DIGIT_COMPLEMENT << day;
	} else {
		oss << year << LABEL_SINGLE_DIGIT_COMPLEMENT << month << LABEL_SINGLE_DIGIT_COMPLEMENT << day;
	}

	dateString = oss.str();
}


// Extract year, month& day from dateString in the format of "yyyymmdd"
// The clients are responsible for ensuring the validity and format of
// the dateString passed to the function.
void WWConverter::convertDateStringToInt(std::string dateString, int& day, int& month, int& year){
	if(!dateString.empty()) {
		string yearString  = dateString.substr(STRING_STARTING_POSITION, LENGTH_YEAR);
		string monthString = dateString.substr(LENGTH_YEAR, LENGTH_MONTH);
		string dayString   = dateString.substr(LENGTH_YEAR + LENGTH_MONTH, LENGTH_DAY);
		
		year  = convertStringToInt(yearString);
		month = convertStringToInt(monthString);
		day   = convertStringToInt(dayString);
	
	} else {
		return;
	}
}

// Extract integer hour& minute from timeString in the format of "hhmm"
// The clients are responsible for ensuring the validity and format of
// the timeString passed to the function.
void WWConverter::convertTimeStringToInt(std::string timeString, int& hour, int& minute) {
	if(!timeString.empty()) {
		string hourString   = timeString.substr(STRING_STARTING_POSITION, LENGTH_HOUR);
		string minuteString = timeString.substr(LENGTH_HOUR, LENGTH_MINUTE);
		hour   = convertStringToInt(hourString);
		minute = convertStringToInt(minuteString);
	} else {
		return;
	}
}
	
// This method transform integer hour and minute to
// a time string for display.
string WWConverter::getFormatedTime(int hour, int minute) {
	ostringstream oss;
	string        period;

	if(hour < DIGIT_NOON_HOUR) {
		period = LABEL_MORNING;
	}

	if(hour > DIGIT_NOON_HOUR) {
		period = LABEL_AFTERNOON;
	}

	if((hour == DIGIT_NOON_HOUR) && (minute != DIGIT_NOON_MINUTE)) {
		period = LABEL_AFTERNOON;
	}

	if((hour == DIGIT_NOON_HOUR) && (minute == DIGIT_NOON_MINUTE)) {
		period = LABEL_NOON;
	}

	if((hour == DIGIT_MIDNIGHT) && (minute == DIGIT_MIDNIGHT)) {
		period = LABEL_MIDNIGHT;
	}

	if(hour == DIGIT_MIDNIGHT) {
		hour = hour + DIGIT_MIDNIGHT_TO_MERIDIEM;
	}

	if(hour > DIGIT_NOON_HOUR) {
		hour = hour - DIGIT_NOON_HOUR;
	}

	if (hour > SINGLE_DIGIT_LIMIT && minute > SINGLE_DIGIT_LIMIT) {
		oss << hour << LABEL_COLON << minute << period;
	} 
	
	if (hour > SINGLE_DIGIT_LIMIT && minute <= SINGLE_DIGIT_LIMIT) {
		oss << hour << LABEL_COLON << LABEL_SINGLE_DIGIT_COMPLEMENT << minute << period;
	} 
	
	if (hour <= SINGLE_DIGIT_LIMIT && minute > SINGLE_DIGIT_LIMIT) {
		oss << LABEL_SINGLE_DIGIT_COMPLEMENT << hour << LABEL_COLON << minute << period;
	} 
	
	if (hour <= SINGLE_DIGIT_LIMIT && minute <= SINGLE_DIGIT_LIMIT) {
		oss << LABEL_SINGLE_DIGIT_COMPLEMENT << hour << LABEL_COLON << LABEL_SINGLE_DIGIT_COMPLEMENT << minute << period;
	}

	return oss.str();
}

// This method transform integer day, month, and year to
// a date string for display.
string WWConverter::getFormatedDate(int day, int month, int year){
	WWUtilities& monthUtility = WWUtilities::getInstance();

	string monthString = monthUtility.convertMonthFromIntToString(month);

	ostringstream oss;

	if (day > SINGLE_DIGIT_LIMIT) {
		oss << day <<LABEL_SPACE<< monthString <<LABEL_SPACE<< year;
	} else {
		oss << LABEL_SINGLE_DIGIT_COMPLEMENT << day <<LABEL_SPACE<< monthString << LABEL_SPACE << year;
	}
	return oss.str();
}

bool WWConverter::isSingleDigit(int number)
{
	bool isSingleDigit = true;
	if(number > SINGLE_DIGIT_LIMIT) {
		isSingleDigit = false;
	}
	return isSingleDigit;
}

int WWConverter::convertStringToInt(std::string convertString) {
	return atoi(convertString.c_str());
}

	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWConverter.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWDisplayWindow.cpp
	 */

#include <string>
#include <vector>
#include "WWTask.h"
#include "WWDisplayWindow.h"
#include "WWLogger.h"

using namespace std;

const string WWDisplayWindow::EMPTY_CONTENT             = "";
const string WWDisplayWindow::LABEL_NEWLINE             = "\n";
const string WWDisplayWindow::LABEL_FROM                = "From: ";
const string WWDisplayWindow::LABEL_TO                  = "To     : ";
const string WWDisplayWindow::LABEL_SEPARATE_DATETIME   = ", ";
const string WWDisplayWindow::LABEL_DUE                 = "Due  : ";
const string WWDisplayWindow::STATUS_TODAY              = "today";
const string WWDisplayWindow::STATUS_OVERDUE            = "overdue";
const string WWDisplayWindow::STATUS_DONE               = "complete";
const string WWDisplayWindow::STATUS_UNDONE             = "incomplete";
const string WWDisplayWindow::WRONG_TASK_TYPE_EXCEPTION = "Wrong Task Type!";
const string WWDisplayWindow::MAIN_WINDOW_DISPLAY_LOG   = "Main window display generated.";



WWDisplayWindow::WWDisplayWindow() {
}


// This function serves to set the details in the vector<vector<string>> 
// according to the attributes of the tasks stored in taskList
// Display contents of every task are stored in a vector of string
// in a sequence of name, date&time follow by display status;
void WWDisplayWindow::setContent(vector<WWTask> taskList) {
	_displayDetails.clear();
	
	vector<string> taskDetails;	
	
	for(unsigned int i = 0; i < taskList.size(); i++) {
		taskDetails.push_back(taskList[i].getTaskName());

		WWUtilities::TaskType tasktype = taskList[i].getTaskType();
		WWLogger& logger = WWLogger::getInstance();

		switch (tasktype) {
		    case WWUtilities::TaskType::FLOATING: {
				taskDetails.push_back(EMPTY_CONTENT);
				break;
			}
			case WWUtilities::TaskType::TIMED: {
				string formatedOutput;
				try{
					formatedOutput = getOutputForTimedtask(taskList[i].getStartDate(), taskList[i].getStartTime(), taskList[i].getEndDate(), taskList[i].getEndTime());
				} catch (string&) {
					formatedOutput = EMPTY_CONTENT;
				}
				taskDetails.push_back(formatedOutput);
				break;
			}
			case WWUtilities::TaskType::DEADLINE: {
				string formatedOutput;
				string deadlineDate = taskList[i].getStartDate();
				string deadlineTime = taskList[i].getStartTime();
				if(!deadlineTime.empty()) {
					_displayConverter.formatTimeForDisplay(deadlineTime);
					_displayConverter.formatDateForDisplay(deadlineDate);
					formatedOutput = LABEL_DUE + deadlineDate + LABEL_SEPARATE_DATETIME + deadlineTime;
				}
				else {
					_displayConverter.formatDateForDisplay(deadlineDate);
					formatedOutput = LABEL_DUE + deadlineDate;
				}
				taskDetails.push_back(formatedOutput);
				break;
			}
			
			default: {
				taskDetails.push_back(EMPTY_CONTENT);
			}

		}

		string displayStatus = getDisplayStatus(taskList[i]);

		taskDetails.push_back(displayStatus);
		
		_displayDetails.push_back(taskDetails);
		taskDetails.clear();
	}
	WWLogger displayWindowLogger = WWLogger::getInstance();
	displayWindowLogger.addLog(MAIN_WINDOW_DISPLAY_LOG);

}

// Accessor for private distribute _displayDetails
vector<vector<string>>& WWDisplayWindow::getContent() {
	return _displayDetails;
}

// This method combines date& time strings stored in WWTask object
// and return a single string that can be used for display
// It is the client' responsibility to ensure that the 
// date and time information come from a timed task
string WWDisplayWindow::getOutputForTimedtask(string startDate, string startTime, string endDate, string endTime){
	string beginMessage, endMessage;
	if(!startTime.empty()) {
		_displayConverter.formatTimeForDisplay(startTime);
		_displayConverter.formatDateForDisplay(startDate);
		beginMessage = LABEL_FROM + startDate + LABEL_SEPARATE_DATETIME + startTime;
	} else if(!startDate.empty()){
		_displayConverter.formatDateForDisplay(startDate);
		beginMessage = LABEL_FROM + startDate;
	} else {
		throw WRONG_TASK_TYPE_EXCEPTION;
	}

	if(!endTime.empty()) {
		_displayConverter.formatTimeForDisplay(endTime);
		_displayConverter.formatDateForDisplay(endDate);
		endMessage = LABEL_TO + endDate + LABEL_SEPARATE_DATETIME + endTime;
	} else {
		_displayConverter.formatDateForDisplay(endDate);

		endMessage = LABEL_TO + endDate;
	}
	
	return beginMessage + LABEL_NEWLINE + endMessage;
}



// This method determine the display status for color display in GUI
// The output is a string that represents the display status
string WWDisplayWindow::getDisplayStatus(WWTask task){
	string displayStatus;
	if(task.getStatus()) {
		displayStatus = STATUS_DONE;
	} else if(task.checkOverdue()) {
		displayStatus = STATUS_OVERDUE;
	} else if(task.checkToday()) {
		displayStatus = STATUS_TODAY;
	} else {
		displayStatus = STATUS_UNDONE;
	}
	return displayStatus;
}


	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWDisplayWindow.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWLogic.cpp
	 */

#include <string>
#include <vector>

#include "WWLogic.h"

using namespace std;

const int    WWLogic::ERROR_INDEX        = -1;
const string WWLogic::ADD_LOG            = "adding task.";
const string WWLogic::EDIT_LOG           = "editing task.";
const string WWLogic::DELETE_LOG         = "deleting task.";
const string WWLogic::DELETEALL_LOG      = "deleteingall task.";
const string WWLogic::SEARCH_LOG         = "searching task.";
const string WWLogic::DONE_LOG           = "marking done.";
const string WWLogic::UNDONE_LOG         = "marking undone task.";
const string WWLogic::VIEWALL_LOG        = "viewing all task.";
const string WWLogic::VIEWTIMED_LOG      = "viewing timed task.";
const string WWLogic::VIEWFLOATING_LOG   = "viewing floating task.";
const string WWLogic::VIEWDONE_LOG       = "viewing done task.";
const string WWLogic::VIEWUNDONE_LOG     = "viewing undone task.";
const string WWLogic::VIEWDEADLINE_LOG   = "viewing deadline task.";
const string WWLogic::VIEWOVERDUE_LOG    = "viewing overdue task.";
const string WWLogic::VIEWTODAY_LOG      = "viewing today task.";
const string WWLogic::UNDO_LOG           = "undoing operation.";
const string WWLogic::REDO_LOG           = "redoing operation.";
const string WWLogic::REFRESH_LOG        = "refreshing tasklist.";
const string WWLogic::EXIT_LOG           = "Exiting program.";


// retrieve storage infomation upon construction
WWLogic::WWLogic() {
	_executor.openFile();
}

// executes the user command
// _display is adjusted after this function is executed
void WWLogic::runInput(string inputString, WWUtilities::PageType pageType) {
	_parser.parseInput(inputString);
	WWCommand parsedCommand = _parser.retrieveCommand();
	executeCommand(parsedCommand, pageType);
}

// assist UI to retrieve display information after execution of user command
WWDisplay WWLogic::getDisplay() {
	return _display;
}

// adjust the user command based on different command types and 
// interact with functionalities of the executor to execute the program.
void WWLogic::executeCommand(WWCommand parsedCommand, WWUtilities::PageType pageType) {
	WWUtilities::CommandType command = parsedCommand.getCommand();
	
	WWLogger& logger = WWLogger::getInstance();
	
	switch(command) {
		case WWUtilities::CommandType::ADD: {
			WWTask taskToBeAdded;
			_commandInterpreter.interpretAdd(parsedCommand, taskToBeAdded);
			logger.addLog(ADD_LOG);
			_display = _executor.addTask(taskToBeAdded);
			break;
		}

		case WWUtilities::CommandType::DELETE: {
			logger.addLog(DELETE_LOG);
			if(parsedCommand.hasDetail()) {    //check whether user has input an index
				int deleteIndex;
				_commandInterpreter.interpretDelete(parsedCommand, deleteIndex);
				
				_display = _executor.deleteTask(deleteIndex, pageType);
			} else {
				_display = _executor.deleteTask(ERROR_INDEX, pageType);
			}
			
			break;
		}

		case WWUtilities::CommandType::DELETEALL: {
			logger.addLog(DELETEALL_LOG);
			_display = _executor.deleteAll();
			break;
		}								   

		case WWUtilities::CommandType::EDIT: {
			int editIndex;
			WWTask taskToBeEdited;
			
			logger.addLog(EDIT_LOG);
			
			_commandInterpreter.interpretEdit(parsedCommand, editIndex, taskToBeEdited);
			_display = _executor.editTask(editIndex, taskToBeEdited, pageType);
			
			break;
		}

		case WWUtilities::CommandType::DONE: {
			logger.addLog(DONE_LOG);
			
			if(parsedCommand.hasDetail()) {
				int doneIndex;
				_commandInterpreter.interpretDone(parsedCommand, doneIndex);
				_display = _executor.markDone(doneIndex, pageType);
			} else{
				_display = _executor.markDone(ERROR_INDEX, pageType);
			}
			
			break;
			
		}

		case WWUtilities::CommandType::UNDONE: {
			logger.addLog(UNDONE_LOG);
			
			if(parsedCommand.hasDetail()) {
				int undoneIndex;
				_commandInterpreter.interpretUndone(parsedCommand, undoneIndex);
				_display = _executor.markUndone(undoneIndex, pageType);
			} else{
				_display = _executor.markUndone(ERROR_INDEX, pageType);
			}
			
			break;
		}

		case WWUtilities::SEARCH: {
			vector<string> keywordStorage;
			
			logger.addLog(SEARCH_LOG);
			
			_commandInterpreter.interpretSearch(parsedCommand, keywordStorage);
			_display = _executor.searchTask(keywordStorage);
			break;
		}
		
		case WWUtilities::CommandType::UNDO:{
			logger.addLog(UNDO_LOG);
			
			_display = _executor.undo(pageType);
			break;
	    }

		case WWUtilities::CommandType::REDO:{
			logger.addLog(REDO_LOG);
			
			_display = _executor.redo(pageType);
			break;
	    }

		
		case WWUtilities::CommandType::VIEWALL: {
			logger.addLog(VIEWALL_LOG);
			
			_display = _executor.viewAll();
			break;
		}
		
		case WWUtilities::CommandType::VIEWDEADLINE: {
			logger.addLog(VIEWDEADLINE_LOG);
			
			_display = _executor.viewDeadlineTask();
			break;
		}

		case WWUtilities::CommandType::VIEWTIMED: {
			logger.addLog(VIEWTIMED_LOG);
			
			_display = _executor.viewTimedTask();
			break;
		}

		case WWUtilities::CommandType::VIEWFLOATING: {
			logger.addLog(VIEWFLOATING_LOG);
			
			_display = _executor.viewFloatingTask();
			break;
		}

		case WWUtilities::CommandType::VIEWTODAY: {
			logger.addLog(VIEWTODAY_LOG);
			
			_display = _executor.viewToday();
			break;
		}

		case WWUtilities::CommandType::VIEWDONE: {
			logger.addLog(VIEWDONE_LOG);
			
			_display = _executor.viewDone();
			break;
		}

		case WWUtilities::CommandType::VIEWUNDONE: {
			logger.addLog(VIEWUNDONE_LOG);
			
			_display = _executor.viewUndone();
			break;
		}

		case WWUtilities::CommandType::VIEWOVERDUE: {
			logger.addLog(VIEWOVERDUE_LOG);
			
			_display = _executor.viewOverdue();
			break;
		}
		
		case WWUtilities::CommandType::REFRESH: {
			logger.addLog(REFRESH_LOG);
			
			_display = _executor.refresh(pageType);
			break;
		}

		case WWUtilities::CommandType::EXIT: {
			logger.addLog(EXIT_LOG);
			
			exit(0);
		}

		default: {
			_display = _executor.invalidCommand(pageType);
		}
	}
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWLogic.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWCommandInterpreterTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"
#include <vector>

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

const string EMPTY_CONTENT                = "";
const string NON_EMPTY_DATE               = "20140420";
const string NON_EMPTY_TIME               = "2209";
const string NON_EMPTY_TASKNAME           = "test";
const string EDITDETAIL_INDEX_AND_NAME    = "2 test";
const string EDITDETAIL_INDEX_AND_NO_NAME = "2";
const string EDITDETAIL_TASKNAME          = "test";
const int    EDITDETAIL_INDEX             = 2;
const int    EDITDETAIL_INVALID_INDEX     = -1;
const string TEST_INDEX_STRING            = "78";
const string TEST_INDEX_ZERO_STRING       = "0";
const string TEST_INDEX_NEGATIVE_STRING   = "-193";
const int    TEST_INDEX_INT               = 78;
const int    TEST_INDEX_ZERO_INT          = 0;
const int    TEST_INDEX_NEGATIVE_INT      = -193;



namespace WWCommandInterpreterTest
{		
	TEST_CLASS(WWCommandInterpreterTest)
	{
	public:
		
		TEST_METHOD(InterpretAddTest)
		{
			WWCommandInterpreter testInterpreter;
			WWCommand testCommand;
			WWTask testTask;
			std::string expectedDetail, expectedDate1, expectedDate2, expectedTime1, expectedTime2;
			//TC1 all 5 components non-empty
			expectedDetail = NON_EMPTY_TASKNAME;
			expectedDate1  = NON_EMPTY_DATE;
			expectedTime1  = NON_EMPTY_TIME;
			expectedDate2  = NON_EMPTY_DATE;
			expectedTime2  = NON_EMPTY_TIME;
			
			testCommand.setCommand(WWUtilities::CommandType::ADD);
			testCommand.setDetail(expectedDetail);
			testCommand.setDate1(expectedDate1);
			testCommand.setTime1(expectedTime1);
			testCommand.setDate2(expectedDate2);
			testCommand.setTime2(expectedTime2);
			
			testInterpreter.interpretAdd(testCommand, testTask);
			
			Assert::AreEqual(expectedDetail, testTask.getTaskName());
			Assert::AreEqual(expectedDate1, testTask.getStartDate());
			Assert::AreEqual(expectedTime1, testTask.getStartTime());
			Assert::AreEqual(expectedDate2, testTask.getEndDate());
			Assert::AreEqual(expectedTime2, testTask.getEndTime());
			//TC2 task with empty components
			expectedDetail = NON_EMPTY_TASKNAME;
			expectedDate1  = NON_EMPTY_DATE;
			expectedTime1  = EMPTY_CONTENT;
			expectedDate2  = NON_EMPTY_DATE;
			expectedTime2  = EMPTY_CONTENT;
			
			testCommand.setCommand(WWUtilities::CommandType::ADD);
			testCommand.setDetail(expectedDetail);
			testCommand.setDate1(expectedDate1);
			testCommand.setTime1(expectedTime1);
			testCommand.setDate2(expectedDate2);
			testCommand.setTime2(expectedTime2);

			testInterpreter.interpretAdd(testCommand, testTask);

			Assert::AreEqual(expectedDetail, testTask.getTaskName());
			Assert::AreEqual(expectedDate1, testTask.getStartDate());
			Assert::AreEqual(expectedTime1, testTask.getStartTime());
			Assert::AreEqual(expectedDate2,  testTask.getEndDate());
			Assert::AreEqual(expectedTime2, testTask.getEndTime());
		}

		TEST_METHOD(InterpretEditTest)
		{
			WWCommandInterpreter testInterpreter;
			WWCommand testCommand;
			int expectedIndex, actualIndex;
			WWTask testTask;
			std::string expectedDetail, expectedDate1, expectedDate2, expectedTime1, expectedTime2;
			std::string commandDetail;
			testCommand.setCommand(WWUtilities::CommandType::EDIT);
			//TC1 command detail contain both index and taskname
			commandDetail  = EDITDETAIL_INDEX_AND_NAME;
			expectedDetail = EDITDETAIL_TASKNAME;
			expectedIndex  = EDITDETAIL_INDEX;
			expectedDate1  = NON_EMPTY_DATE;
			expectedTime1  = NON_EMPTY_TIME;
			expectedDate2  = NON_EMPTY_DATE;
			expectedTime2  = NON_EMPTY_TIME;
			
			testCommand.setDetail(commandDetail);
		    testCommand.setDate1(expectedDate1);
			testCommand.setTime1(expectedTime1);
			testCommand.setDate2(expectedDate2);
			testCommand.setTime2(expectedTime2);

			testInterpreter.interpretEdit(testCommand, actualIndex, testTask);
	  
			Assert::AreEqual(expectedIndex, actualIndex);
			Assert::AreEqual(expectedDetail, testTask.getTaskName());
			Assert::AreEqual(expectedDate1, testTask.getStartDate());
			Assert::AreEqual(expectedTime1, testTask.getStartTime());
			Assert::AreEqual(expectedDate2,  testTask.getEndDate());
			Assert::AreEqual(expectedTime2, testTask.getEndTime());
			//TC2 command detail contain index and no taskname
			commandDetail = EDITDETAIL_INDEX_AND_NO_NAME;
			expectedDetail = EMPTY_CONTENT;
			expectedIndex = EDITDETAIL_INDEX;
			expectedDate1  = NON_EMPTY_DATE;
			expectedTime1  = NON_EMPTY_TIME;
			expectedDate2  = NON_EMPTY_DATE;
			expectedTime2  = NON_EMPTY_TIME;
			
			testCommand.setDetail(commandDetail);
			testCommand.setDate1(expectedDate1);
			testCommand.setTime1(expectedTime1);
			testCommand.setDate2(expectedDate2);
			testCommand.setTime2(expectedTime2);
			
			testInterpreter.interpretEdit(testCommand, actualIndex, testTask);
	        
			Assert::AreEqual(expectedIndex, actualIndex);
			Assert::AreEqual(expectedDetail, testTask.getTaskName());
			Assert::AreEqual(expectedDate1, testTask.getStartDate());
			Assert::AreEqual(expectedTime1, testTask.getStartTime());
			Assert::AreEqual(expectedDate2,  testTask.getEndDate());
			Assert::AreEqual(expectedTime2, testTask.getEndTime());
			//TC3 command detail contain no index and taskname;
			commandDetail = EMPTY_CONTENT;
			expectedDetail = EMPTY_CONTENT;
			expectedIndex = EDITDETAIL_INVALID_INDEX;
			expectedDate1  = NON_EMPTY_DATE;
			expectedTime1  = NON_EMPTY_TIME;
			expectedDate2  = NON_EMPTY_DATE;
			expectedTime2  = NON_EMPTY_TIME;
			
			testCommand.setDetail(commandDetail);
			testCommand.setDate1(expectedDate1);
			testCommand.setTime1(expectedTime1);
			testCommand.setDate2(expectedDate2);
			testCommand.setTime2(expectedTime2);
			
			testInterpreter.interpretEdit(testCommand, actualIndex, testTask);
	        
			Assert::AreEqual(expectedIndex, actualIndex);
			Assert::AreEqual(expectedDetail, testTask.getTaskName());
			Assert::AreEqual(expectedDate1, testTask.getStartDate());
			Assert::AreEqual(expectedTime1, testTask.getStartTime());
			Assert::AreEqual(expectedDate2,  testTask.getEndDate());
			Assert::AreEqual(expectedTime2, testTask.getEndTime());
		} 
		TEST_METHOD(interpretSearchTest)
		{
			WWCommandInterpreter testInterpreter;
			WWCommand testCommand;
			std::vector<std::string> keywordStorage;
			std::string expectedKeyword, expectedDate1, expectedDate2, expectedTime1, expectedTime2;
			std::string actualKeyword, actualDate1, actualDate2, actualTime1, actualTime2;
			testCommand.setCommand(WWUtilities::CommandType::SEARCH);
			//TC1 command only contains keyword, no date and time
			expectedKeyword = NON_EMPTY_TASKNAME;
			expectedDate1  = EMPTY_CONTENT;
			expectedTime1  = EMPTY_CONTENT;
			expectedDate2  = EMPTY_CONTENT;
			expectedTime2  = EMPTY_CONTENT;
			
			testCommand.setDetail(expectedKeyword);
			testCommand.setDate1(expectedDate1);
			testCommand.setTime1(expectedTime1);
			testCommand.setDate2(expectedDate2);
			testCommand.setTime2(expectedTime2);
			
			testInterpreter.interpretSearch(testCommand, keywordStorage);
	       
			Assert::AreEqual(expectedKeyword, keywordStorage[0]);
			Assert::AreEqual(expectedDate1, keywordStorage[1]);
			Assert::AreEqual(expectedTime1, keywordStorage[2]);
			Assert::AreEqual(expectedDate2, keywordStorage[3]);  
			Assert::AreEqual(expectedTime2, keywordStorage[4]);
			//TC2 command has no keyword but a single date.
			expectedKeyword = EMPTY_CONTENT;
			expectedDate1  = NON_EMPTY_DATE;
			expectedTime1  = EMPTY_CONTENT;
			expectedDate2  = EMPTY_CONTENT;
			expectedTime2  = EMPTY_CONTENT;
			
			testCommand.setDetail(expectedKeyword);
			testCommand.setDate1(expectedDate1);
			testCommand.setTime1(expectedTime1);
			testCommand.setDate2(expectedDate2);
			testCommand.setTime2(expectedTime2);
			
			testInterpreter.interpretSearch(testCommand, keywordStorage);
	        
			Assert::AreEqual(expectedKeyword, keywordStorage[0]);
			Assert::AreEqual(expectedDate1, keywordStorage[1]);
			Assert::AreEqual(expectedTime1, keywordStorage[2]);
			Assert::AreEqual(expectedDate2, keywordStorage[3]);  
			Assert::AreEqual(expectedTime2, keywordStorage[4]);
			//TC3 command has all the keyword and starting and ending dates & times.
			expectedKeyword = NON_EMPTY_TASKNAME;
			expectedDate1  = NON_EMPTY_DATE;
			expectedTime1  = NON_EMPTY_TIME;
			expectedDate2  = NON_EMPTY_DATE;
			expectedTime2  = NON_EMPTY_TIME;
			
			testCommand.setDetail(expectedKeyword);
			
			testCommand.setDate1(expectedDate1);
			testCommand.setTime1(expectedTime1);
			testCommand.setDate2(expectedDate2);
			testCommand.setTime2(expectedTime2);

			testInterpreter.interpretSearch(testCommand, keywordStorage);

	        Assert::AreEqual(expectedKeyword, keywordStorage[0]);
			Assert::AreEqual(expectedDate1, keywordStorage[1]);
			Assert::AreEqual(expectedTime1, keywordStorage[2]);
			Assert::AreEqual(expectedDate2, keywordStorage[3]);  
			Assert::AreEqual(expectedTime2, keywordStorage[4]);
		}

		TEST_METHOD(interpretDeleteTest)
		{
			WWCommandInterpreter testInterpreter;
			WWCommand testCommand;
			int expectedIndex, actualIndex;
			testCommand.setCommand(WWUtilities::CommandType::DELETE);
			//TC1 positive index
			testCommand.setDetail(TEST_INDEX_STRING);
			expectedIndex = TEST_INDEX_INT;
			testInterpreter.interpretDelete(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);

			//TC2 zero index
			testCommand.setDetail(TEST_INDEX_ZERO_STRING);
			expectedIndex = TEST_INDEX_ZERO_INT;
			testInterpreter.interpretDelete(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);
			
			//TC3 negative index
			testCommand.setDetail(TEST_INDEX_NEGATIVE_STRING);
			expectedIndex = TEST_INDEX_NEGATIVE_INT;
			testInterpreter.interpretDelete(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);
		}
		TEST_METHOD(interpretDoneTest)
		{
			WWCommandInterpreter testInterpreter;
			WWCommand testCommand;
			int expectedIndex, actualIndex;
			testCommand.setCommand(WWUtilities::CommandType::DONE);
			//TC1 positive index
			testCommand.setDetail(TEST_INDEX_STRING);
			expectedIndex = TEST_INDEX_INT;
			testInterpreter.interpretDone(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);

			//TC2 zero index
			testCommand.setDetail(TEST_INDEX_ZERO_STRING);
			expectedIndex = TEST_INDEX_ZERO_INT;
			testInterpreter.interpretDone(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);
			
			//TC3 negative index
			testCommand.setDetail(TEST_INDEX_NEGATIVE_STRING);
			expectedIndex = TEST_INDEX_NEGATIVE_INT;
			testInterpreter.interpretDone(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);
		}
		TEST_METHOD(interpretUndoneTest)
		{
			WWCommandInterpreter testInterpreter;
			WWCommand testCommand;
			int expectedIndex, actualIndex;
			testCommand.setCommand(WWUtilities::CommandType::UNDONE);
			//TC1 positive index
			testCommand.setDetail(TEST_INDEX_STRING);
			expectedIndex = TEST_INDEX_INT;
			testInterpreter.interpretUndone(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);

			//TC2 zero index
			testCommand.setDetail(TEST_INDEX_ZERO_STRING);
			expectedIndex = TEST_INDEX_ZERO_INT;
			testInterpreter.interpretUndone(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);
			
			//TC3 negative index
			testCommand.setDetail(TEST_INDEX_NEGATIVE_STRING);
			expectedIndex = TEST_INDEX_NEGATIVE_INT;
			testInterpreter.interpretUndone(testCommand, actualIndex);
			Assert::AreEqual(expectedIndex, actualIndex);
		}
		
		
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWCommandInterpreterTest.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWConverterTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

const int    SINGLE_DIGIT_INT               = 5;
const int    ZERO_INT                       = 0;
const int    DOUBLE_DIGIT_INT               = 12;
const int    FOUR_DIGIT_INT                 = 2014;

const string TEST_TIME_HOUR_ZERO                 = "0012";
const string TEST_TIME_MINUTE_ZERO               = "1200";
const string TEST_TIME_BOTH_ZERO                 = "0000";
const string TEST_TIME_SINGLE_DIGIT_HOUR         = "0512";
const string TEST_TIME_SINGLE_DIGIT_MINUTE       = "1205";
const string TEST_TIME_BOTH_SINGLE_DIGIT         = "0505";
const string TEST_TIME_BOTH_DOUBLE_DIGIT         = "1212";

const string TEST_DATE_MONTH_SINGLE_DIGIT        = "20140512";
const string TEST_DATE_DAY_SINGLE_DIGIT          = "20141205";
const string TEST_DATE_BOTH_DOUBLE_DIGIT         = "20141212";
const string TEST_DATE_BOTH_SINGLE_DIGIT         = "20140505";

const string TEST_DISPLAY_DATE_SINGLE_DIGIT_DAY  = "05 Dec 2014";
const string TEST_DISPLAY_DATE_DOUBLE_DIGIT_DAY  = "12 May 2014";

const string TEST_TIME_CASE_1                    = "0000";
const string TEST_TIME_CASE_2                    = "0025";
const string TEST_TIME_CASE_3                    = "0518";
const string TEST_TIME_CASE_4                    = "1200";
const string TEST_TIME_CASE_5                    = "1213";
const string TEST_TIME_CASE_6                    = "2359";
const string TEST_DISPLAY_TIME_1                 = "12:00mn";
const string TEST_DISPLAY_TIME_2                 = "12:25am";
const string TEST_DISPLAY_TIME_3                 = "05:18am";
const string TEST_DISPLAY_TIME_4                 = "12:00nn";
const string TEST_DISPLAY_TIME_5                 = "12:13pm";
const string TEST_DISPLAY_TIME_6                 = "11:59pm";

namespace WWConverterTest
{		
	TEST_CLASS(WWConverterTest)
	{
	public:
		
		TEST_METHOD(convertIntTimeToStringTest)
		{
			WWConverter testConverter;
			int hour, minute;
			std::string expectedOutput, actualOutput;
			//TC1 hour is 0, minute non-zero
			hour = ZERO_INT;
			minute = DOUBLE_DIGIT_INT;
			expectedOutput = TEST_TIME_HOUR_ZERO;
			testConverter.convertIntTimeToString(hour, minute,actualOutput);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC2 minute is 0, hour non-zero
			hour  = DOUBLE_DIGIT_INT;
			minute = ZERO_INT;
			expectedOutput = TEST_TIME_MINUTE_ZERO;
			testConverter.convertIntTimeToString(hour,minute,actualOutput);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC3 neither hour nor minute is 0
			hour  = DOUBLE_DIGIT_INT;
			minute = DOUBLE_DIGIT_INT;
			expectedOutput = TEST_TIME_BOTH_DOUBLE_DIGIT;
			testConverter.convertIntTimeToString(hour,minute,actualOutput);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC4 both hour and minute are 0
			hour  = ZERO_INT;
			minute = ZERO_INT;
			expectedOutput = TEST_TIME_BOTH_ZERO;
			testConverter.convertIntTimeToString(hour,minute,actualOutput);
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		TEST_METHOD(convertIntDateToStringTest)
		{
			WWConverter testConverter;
			int day, month, year;
			std::string expectedOutput, actualOutput;
			//TC1 single digit day, double digit month
			day = SINGLE_DIGIT_INT; 
			month = DOUBLE_DIGIT_INT;
			year = FOUR_DIGIT_INT;
			expectedOutput = TEST_DATE_DAY_SINGLE_DIGIT;
			testConverter.convertIntDateToString(day, month, year, actualOutput);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC2 single digit month, double digit day
			day = DOUBLE_DIGIT_INT;
			month = SINGLE_DIGIT_INT;
			year = FOUR_DIGIT_INT;
			expectedOutput = TEST_DATE_MONTH_SINGLE_DIGIT;
			testConverter.convertIntDateToString(day, month, year, actualOutput);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC3 both day and month single digit
			day = SINGLE_DIGIT_INT;
			month = SINGLE_DIGIT_INT;
			year = FOUR_DIGIT_INT;
			expectedOutput = TEST_DATE_BOTH_SINGLE_DIGIT;
			testConverter.convertIntDateToString(day, month, year, actualOutput);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC4 neither day nor month is single digit
			day = DOUBLE_DIGIT_INT;
			month = DOUBLE_DIGIT_INT;
			year = FOUR_DIGIT_INT;
			expectedOutput = TEST_DATE_BOTH_DOUBLE_DIGIT;
			testConverter.convertIntDateToString(day, month, year, actualOutput);
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		TEST_METHOD(convertDateStringToIntTest)
		{
			WWConverter testConverter;
			std::string dateString;
			int day, month, year, expectedday, expectedmonth, expectedyear;
			//TC1 single digit month, double digit day
			dateString = TEST_DATE_MONTH_SINGLE_DIGIT;
			expectedday   = DOUBLE_DIGIT_INT;
			expectedmonth = SINGLE_DIGIT_INT;
			expectedyear  = FOUR_DIGIT_INT;
			testConverter.convertDateStringToInt(dateString, day, month, year);
			Assert::AreEqual(day, expectedday);
			Assert::AreEqual(month, expectedmonth);
			Assert::AreEqual(year, expectedyear);
			//TC2 single digit day, double digit month
			dateString = TEST_DATE_DAY_SINGLE_DIGIT;
			expectedday   = SINGLE_DIGIT_INT;
			expectedmonth = DOUBLE_DIGIT_INT;
			expectedyear  = FOUR_DIGIT_INT;
			testConverter.convertDateStringToInt(dateString, day, month, year);
			Assert::AreEqual(day, expectedday);
			Assert::AreEqual(month, expectedmonth);
			Assert::AreEqual(year, expectedyear);
			//TC3 both day and month single digit
			dateString = TEST_DATE_BOTH_SINGLE_DIGIT;
			expectedday   = SINGLE_DIGIT_INT;
			expectedmonth = SINGLE_DIGIT_INT;
			expectedyear  = FOUR_DIGIT_INT;
			testConverter.convertDateStringToInt(dateString, day, month, year);
			Assert::AreEqual(day, expectedday);
			Assert::AreEqual(month, expectedmonth);
			Assert::AreEqual(year, expectedyear);
			//TC4 neither day nor month single digit
			dateString = TEST_DATE_BOTH_DOUBLE_DIGIT;
			expectedday   = DOUBLE_DIGIT_INT;
			expectedmonth = DOUBLE_DIGIT_INT;
			expectedyear  = FOUR_DIGIT_INT;
			testConverter.convertDateStringToInt(dateString, day, month, year);
			Assert::AreEqual(day, expectedday);
			Assert::AreEqual(month, expectedmonth);
			Assert::AreEqual(year, expectedyear);
		}

		TEST_METHOD(convertTimeStringToIntTest)
		{
			WWConverter testConverter;
			std::string timeString;
			int hour, minute, expectedhour, expectedminute;
			//TC1 hour is 0, minute non-zero
			timeString = TEST_TIME_HOUR_ZERO;
			expectedhour   = ZERO_INT;
			expectedminute = DOUBLE_DIGIT_INT;
			testConverter.convertTimeStringToInt(timeString, hour, minute);
			Assert::AreEqual(hour, expectedhour);
			Assert::AreEqual(minute, expectedminute);
			//TC2 minute is zero, hour non-zero
			timeString = TEST_TIME_MINUTE_ZERO;
			expectedhour   = DOUBLE_DIGIT_INT;
			expectedminute = ZERO_INT;
			testConverter.convertTimeStringToInt(timeString, hour, minute);
			Assert::AreEqual(hour, expectedhour);
			Assert::AreEqual(minute, expectedminute);
			//TC3 both hour and minute zero
			timeString = TEST_TIME_BOTH_ZERO;
			expectedhour   = ZERO_INT;
			expectedminute = ZERO_INT;
			testConverter.convertTimeStringToInt(timeString, hour, minute);
			Assert::AreEqual(hour, expectedhour);
			Assert::AreEqual(minute, expectedminute);
			//TC4 single digit hour, double-digit minute
			timeString = TEST_TIME_SINGLE_DIGIT_HOUR;
			expectedhour   = SINGLE_DIGIT_INT;
			expectedminute = DOUBLE_DIGIT_INT;
			testConverter.convertTimeStringToInt(timeString, hour, minute);
			Assert::AreEqual(hour, expectedhour);
			Assert::AreEqual(minute, expectedminute);
			//TC5 single digit minute, double digit hour
			timeString = TEST_TIME_SINGLE_DIGIT_MINUTE;
			expectedhour   = DOUBLE_DIGIT_INT;
			expectedminute = SINGLE_DIGIT_INT;
			testConverter.convertTimeStringToInt(timeString, hour, minute);
			Assert::AreEqual(hour, expectedhour);
			Assert::AreEqual(minute, expectedminute);
			//TC6 both hour and minute single digit
			timeString = TEST_TIME_BOTH_SINGLE_DIGIT;
			expectedhour   = SINGLE_DIGIT_INT;
			expectedminute = SINGLE_DIGIT_INT;
			testConverter.convertTimeStringToInt(timeString, hour, minute);
			Assert::AreEqual(hour, expectedhour);
			Assert::AreEqual(minute, expectedminute);
			//TC7 neither hour nor minute single digit
			timeString = TEST_TIME_BOTH_DOUBLE_DIGIT;
			expectedhour   = DOUBLE_DIGIT_INT;
			expectedminute = DOUBLE_DIGIT_INT;
			testConverter.convertTimeStringToInt(timeString, hour, minute);
			Assert::AreEqual(hour, expectedhour);
			Assert::AreEqual(minute, expectedminute);
			
		}
		TEST_METHOD(formatDateForDisplayTest)
		{
			WWConverter testConverter;
			std::string expectedOutput, actualOutput;
			//TC1 non-single digit day
			actualOutput = TEST_DATE_MONTH_SINGLE_DIGIT;
			testConverter.formatDateForDisplay(actualOutput);
			expectedOutput = TEST_DISPLAY_DATE_DOUBLE_DIGIT_DAY;
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC2 single digit day
			actualOutput = TEST_DATE_DAY_SINGLE_DIGIT;
			testConverter.formatDateForDisplay(actualOutput);
			expectedOutput = TEST_DISPLAY_DATE_SINGLE_DIGIT_DAY;
			Assert::AreEqual(expectedOutput, actualOutput);
		}

		TEST_METHOD(formatTimeForDisplayTest)
		{
			WWConverter testConverter;
			std::string expectedOutput, actualOutput;
			//TC1 midnight
			actualOutput = TEST_TIME_CASE_1;
			testConverter.formatTimeForDisplay(actualOutput);
			expectedOutput = TEST_DISPLAY_TIME_1;
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC2 00:01 - 00:59
			actualOutput = TEST_TIME_CASE_2;
			testConverter.formatTimeForDisplay(actualOutput);
			expectedOutput = TEST_DISPLAY_TIME_2;
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC3 01:00 - 11:59
			actualOutput = TEST_TIME_CASE_3;
			testConverter.formatTimeForDisplay(actualOutput);
			expectedOutput = TEST_DISPLAY_TIME_3;
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC4 noon
			actualOutput = TEST_TIME_CASE_4;
			testConverter.formatTimeForDisplay(actualOutput);
			expectedOutput = TEST_DISPLAY_TIME_4;
			Assert::AreEqual(expectedOutput, actualOutput); 
			//TC5 12:01 - 12:59
			actualOutput = TEST_TIME_CASE_5;
			testConverter.formatTimeForDisplay(actualOutput);
			expectedOutput = TEST_DISPLAY_TIME_5;
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC6 13:00 - 23:59
			actualOutput = TEST_TIME_CASE_6;
			testConverter.formatTimeForDisplay(actualOutput);
			expectedOutput = TEST_DISPLAY_TIME_6;
			Assert::AreEqual(expectedOutput, actualOutput);
			}


			
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWConverterTest.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWDisplayWindowTest.cpp
	 */

#include <vector>
#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;
const string EMPTY_CONTENT = "";

const bool TEST_STATUS_DONE = true;
const bool TEST_STATUS_UNDONE = false;

const string TEST_TIMED_TASK_NAME = "timed";
const string TEST_DEADLINE_TASK_NAME= "deadline";
const string TEST_FLOATING_TASK_NAME = "floating";
const string TEST_START_DATE = "20140215";
const string TEST_END_DATE = "20140420";
const string TEST_START_TIME = "1920";
const string TEST_END_TIME = "2359";

const string DISPLAY_CASE_1_NAME   = "timed";
const string DISPLAY_CASE_1_DATE   = "From: 15 Feb 2014, 07:20pm\nTo     : 20 Apr 2014, 11:59pm";
const string DISPLAY_CASE_1_STATUS = "complete";
const string DISPLAY_CASE_2_NAME   = "timed";
const string DISPLAY_CASE_2_DATE   = "From: 15 Feb 2014\nTo     : 20 Apr 2014";
const string DISPLAY_CASE_2_STATUS = "complete";
const string DISPLAY_CASE_3_NAME   = "deadline";
const string DISPLAY_CASE_3_DATE   = "Due  : 15 Feb 2014, 07:20pm";
const string DISPLAY_CASE_3_STATUS = "complete";
const string DISPLAY_CASE_4_NAME   = "deadline";
const string DISPLAY_CASE_4_DATE   = "Due  : 15 Feb 2014";
const string DISPLAY_CASE_4_STATUS = "complete";
const string DISPLAY_CASE_5_NAME   = "deadline";
const string DISPLAY_CASE_5_DATE   = "Due  : 15 Feb 2014";
const string DISPLAY_CASE_5_STATUS = "overdue";
const string DISPLAY_CASE_6_NAME   = "floating";
const string DISPLAY_CASE_6_DATE   = "";
const string DISPLAY_CASE_6_STATUS = "incomplete";
namespace WWDisplayWindowTest
{
	TEST_CLASS(WWDisplayWindowTest)
	{
	public:
		
		TEST_METHOD(setGetContentTest)
		{
			WWDisplayWindow testDisplayWindow;
			vector<WWTask> testStorage;
			string actualName, actualDate, actualStatus;
			//TC1 when displaying a timed task with both dates and times
			WWTask testTask1;
			testTask1.setTaskName(TEST_TIMED_TASK_NAME);
			testTask1.setStartDate(TEST_START_DATE);
			testTask1.setEndDate(TEST_END_DATE);
			testTask1.setStartTime(TEST_START_TIME);
			testTask1.setEndTime(TEST_END_TIME);
			testTask1.setStatus(TEST_STATUS_DONE);

			testStorage.push_back(testTask1);

			testDisplayWindow.setContent(testStorage);

			actualName = testDisplayWindow.getContent()[0][0];
			actualDate = testDisplayWindow.getContent()[0][1];
			actualStatus = testDisplayWindow.getContent()[0][2];
			Assert::AreEqual(DISPLAY_CASE_1_NAME, actualName);
			Assert::AreEqual(DISPLAY_CASE_1_DATE, actualDate);
			Assert::AreEqual(DISPLAY_CASE_1_STATUS, actualStatus);
			//TC2 when displaying a timed task with only dates
			WWTask testTask2;
			testTask2.setTaskName(TEST_TIMED_TASK_NAME);
			testTask2.setStartDate(TEST_START_DATE);
			testTask2.setEndDate(TEST_END_DATE);
			testTask2.setStatus(TEST_STATUS_DONE);

			testStorage.push_back(testTask2);

			testDisplayWindow.setContent(testStorage);

			actualName = testDisplayWindow.getContent()[1][0];
			actualDate = testDisplayWindow.getContent()[1][1];
			actualStatus = testDisplayWindow.getContent()[1][2];
			Assert::AreEqual(DISPLAY_CASE_2_NAME, actualName);
			Assert::AreEqual(DISPLAY_CASE_2_DATE, actualDate);
			Assert::AreEqual(DISPLAY_CASE_2_STATUS, actualStatus);
			//TC3 when displaying a deadline task with date and time
			WWTask testTask3;
			testTask3.setTaskName(TEST_DEADLINE_TASK_NAME);
			testTask3.setStartDate(TEST_START_DATE);
			testTask3.setStartTime(TEST_START_TIME);
			testTask3.setStatus(TEST_STATUS_DONE);

			testStorage.push_back(testTask3);

			testDisplayWindow.setContent(testStorage);

			actualName = testDisplayWindow.getContent()[2][0];
			actualDate = testDisplayWindow.getContent()[2][1];
			actualStatus = testDisplayWindow.getContent()[2][2];
			Assert::AreEqual(DISPLAY_CASE_3_NAME, actualName);
			Assert::AreEqual(DISPLAY_CASE_3_DATE, actualDate);
			Assert::AreEqual(DISPLAY_CASE_3_STATUS, actualStatus);
			//TC4 when displaying a deadline task with only date
			WWTask testTask4;
			testTask4.setTaskName(TEST_DEADLINE_TASK_NAME);
			testTask4.setStartDate(TEST_START_DATE);
			testTask4.setStatus(TEST_STATUS_DONE);

			testStorage.push_back(testTask4);

			testDisplayWindow.setContent(testStorage);

			actualName = testDisplayWindow.getContent()[3][0];
			actualDate = testDisplayWindow.getContent()[3][1];
			actualStatus = testDisplayWindow.getContent()[3][2];
			Assert::AreEqual(DISPLAY_CASE_4_NAME, actualName);
			Assert::AreEqual(DISPLAY_CASE_4_DATE, actualDate);
			Assert::AreEqual(DISPLAY_CASE_4_STATUS, actualStatus);
			//TC5 when displaying an overdue task
			WWTask testTask5;
			testTask5.setTaskName(TEST_DEADLINE_TASK_NAME);
			testTask5.setStartDate(TEST_START_DATE);
			testTask5.setStatus(TEST_STATUS_UNDONE);

			testStorage.push_back(testTask5);

			testDisplayWindow.setContent(testStorage);

			actualName = testDisplayWindow.getContent()[4][0];
			actualDate = testDisplayWindow.getContent()[4][1];
			actualStatus = testDisplayWindow.getContent()[4][2];
			Assert::AreEqual(DISPLAY_CASE_5_NAME, actualName);
			Assert::AreEqual(DISPLAY_CASE_5_DATE, actualDate);
			Assert::AreEqual(DISPLAY_CASE_5_STATUS, actualStatus);
			//TC6 when displaying a floating task
			WWTask testTask6;
			testTask6.setTaskName(TEST_FLOATING_TASK_NAME);
			testTask6.setStatus(TEST_STATUS_UNDONE);

			testStorage.push_back(testTask6);

			testDisplayWindow.setContent(testStorage);

			actualName = testDisplayWindow.getContent()[5][0];
			actualDate = testDisplayWindow.getContent()[5][1];
			actualStatus = testDisplayWindow.getContent()[5][2];
			Assert::AreEqual(DISPLAY_CASE_6_NAME, actualName);
			Assert::AreEqual(DISPLAY_CASE_6_DATE, actualDate);
			Assert::AreEqual(DISPLAY_CASE_6_STATUS, actualStatus);
		}

	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWDisplayWindowTest.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWUtilitiesTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

const int    TEST_MONTH_INT                   = 5;
const int    TEST_INVALID_MONTH_INT           = 0;
const string TEST_UPPERCASE_MONTH_STRING      = "May";
const string TEST_LOWERCASE_MONTH_STRING      = "may";
const string TEST_INVALID_INPUT_MONTH_STRING  = "uri";
const string TEST_INVALID_MONTH_STRING        = "";

namespace WWUtilitiesTest
{		
	TEST_CLASS(WWUtilitiesTest) 
	{
	public:
		
		TEST_METHOD(convertMonthFromStringToIntTest)
		{
			WWUtilities testMonthUtility = WWUtilities::getInstance();
			std::string monthString;
			int expectedOutput, actualOutput;
			//TC1 valid input month string with uppercases
			monthString = TEST_UPPERCASE_MONTH_STRING;
			expectedOutput = TEST_MONTH_INT;
			actualOutput = testMonthUtility.convertMonthFromStringToInt(monthString);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC2 valid input month string with lowercases
			monthString = TEST_LOWERCASE_MONTH_STRING;
			expectedOutput = TEST_MONTH_INT;
			actualOutput = testMonthUtility.convertMonthFromStringToInt(monthString);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC3 invalid input month string
			monthString = TEST_INVALID_INPUT_MONTH_STRING;
			expectedOutput = TEST_INVALID_MONTH_INT;
			actualOutput = testMonthUtility.convertMonthFromStringToInt(monthString);
			Assert::AreEqual(expectedOutput, actualOutput);
		}
		TEST_METHOD(convertMonthFromIntToStringTest)
		{
			WWUtilities testMonthUtility = WWUtilities::getInstance();
			int monthInt;
			std::string expectedOutput, actualOutput;
			//TC1 test valid month
			monthInt = TEST_MONTH_INT;
			expectedOutput = TEST_UPPERCASE_MONTH_STRING;
			actualOutput = testMonthUtility.convertMonthFromIntToString(monthInt);
			Assert::AreEqual(expectedOutput, actualOutput);
			//TC2 test invalid month
			monthInt = TEST_INVALID_MONTH_INT;
			expectedOutput = TEST_INVALID_MONTH_STRING;
			actualOutput = testMonthUtility.convertMonthFromIntToString(monthInt);
			Assert::AreEqual(expectedOutput, actualOutput);
		}
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWUtilitiesTest.cpp





