//@author: a0101014l



	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWFileStorage.cpp
	 */

// WWFileStorage.cpp

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <ctime>
#include <cassert>
#include "WWTask.h"
#include "WWFileStorage.h"
#include "WWConverter.h"

using namespace std;

const string FILENAME = "WorkWork.txt";

const char PARAMETER_SEPARATOR = ';';

const string EMPTY_PARAMETER = "";

const string DONE_INDICATOR = "true";
const string UNDONE_INDICATOR = "false";

const int TASKNAME_INDEX  = 0;
const int STARTDATE_INDEX = 1;
const int STARTTIME_INDEX = 2;
const int ENDDATE_INDEX   = 3;
const int ENDTIME_INDEX   = 4;
const int STATUS_INDEX    = 5;

const int TOKEN_NUMBER = 6;
const int DATE_LENGTH  = 8;
const int TIME_LENGTH  = 4;

const int TMSTRUCT_PARAMETER      = 0;
const int SYSTEM_MONTH_ADJUSTMENT = 1;
const int SYSTEM_YEAR_ADJUSTMENT  = 1900;

WWFileStorage::WWFileStorage() {
	_isCorruptedFile  = false;
	_isCorruptedToken = false;
}

//read strings of task content from the text file
//break them down to components used to construct a WWTask object
//a corrupted string wont be used to construct a WWTask object
bool WWFileStorage::openFile(vector<WWTask>& fileContent) {
	ifstream readFile(FILENAME.c_str());
	string lineContent;

	while(getline(readFile, lineContent)) {
		vector<string> tokenStorage;
		WWTask newTask;

		tokenizeContent(lineContent, tokenStorage);  //break down a string of task content to tokens

		if(!_isCorruptedToken){
			newTask = createTaskWithTokens(tokenStorage);
			fileContent.push_back(newTask);
		}

		_isCorruptedToken = false;  //each time after checking if a token is corrupted, set _isCorruptedToken to false;
	}

	readFile.close();

	return !_isCorruptedFile;
}

//save the content stored in a WWTask into the text file in the form of a string
void WWFileStorage::saveFile(vector<WWTask>& fileContent) {
	ofstream writeFile(FILENAME.c_str());

	for(unsigned int i = 0; i < fileContent.size(); i++) {
		string lineContent = taskToString(fileContent[i]);
		writeFile << lineContent << endl;
	}

	writeFile.close();
}

//we recognize ";" as the separator of different attributes of a WWTask object
//string will be split into tokens representing WWTask attributes
//tokens are then stored in a vector and to be verified if corrupted, in case the text file is modified
//once tokens are corrupted, the text file is also corrupted
//if token not corrupted, it will be then adjusted according to the correct date and time format, i.e. 20140231 is adjusted to 20140303, 0964 is adjusted to 1004
void WWFileStorage::tokenizeContent(string content, vector<string>& tokenStorage) {
	istringstream iss(content);
	string token;

	while(getline(iss, token, PARAMETER_SEPARATOR)) {
		tokenStorage.push_back(token);
	}

	verifyTokenContent(tokenStorage);

	if(!_isCorruptedToken) {
		adjustTokenContent(tokenStorage);
	} else {
		_isCorruptedFile = true;
	}
}

//token content will be verified if corrupted due to modification of the text file
void WWFileStorage::verifyTokenContent(const vector<string>& tokenStorage) {

	//by right there should be 6 tokens in tokenStorage, including task name, start date, start time, end date, end time and status
	//if the number of tokens in tokenStorage is not 6, token is corrupted
	if(tokenStorage.size() != TOKEN_NUMBER)
		_isCorruptedToken = true;

	//if the number os tokens is correct, length and format of tokens are checked
	if(!_isCorruptedToken) {

		if(!tokenStorage[STARTDATE_INDEX].empty()) {
			if(tokenStorage[STARTDATE_INDEX].size() != DATE_LENGTH) {  //non-empty token of start date must have 8 digit, otherwise corrupted
				_isCorruptedToken = true;
			} else {
				if(!isNumber(tokenStorage[STARTDATE_INDEX])) {  //if this token is 8-digit long but it is not a string of integer, then corrupted
					_isCorruptedToken = true;
				}
			}
		}

		if(!tokenStorage[STARTTIME_INDEX].empty()) {
			if(tokenStorage[STARTDATE_INDEX].empty()) {  //non-empty token of start time only exists when there is non-empty token of start time, otherwise corrupted
				_isCorruptedToken = true;
			} else {
				if(tokenStorage[STARTTIME_INDEX].size() != TIME_LENGTH) {  //this token must have 4 digits, otherwise corrupted
					_isCorruptedToken = true;
				} else {
					if(!isNumber(tokenStorage[STARTTIME_INDEX])) {  //if this token is 8-digit long but it is a string of integer, then corrupted
						_isCorruptedToken = true;
					}
				}
			}
		}

		//similar to checking tokenStorage[STARTDATE_INDEX]
		if(!tokenStorage[ENDDATE_INDEX].empty()) {
			if(tokenStorage[ENDDATE_INDEX].size() != DATE_LENGTH) {
				_isCorruptedToken = true;
			} else {
				if(!isNumber(tokenStorage[ENDDATE_INDEX])) {
					_isCorruptedToken = true;
				}
			}
		}

		//similar to checking tokenStorage[STARTTIME_INDEX]
		if(!tokenStorage[ENDTIME_INDEX].empty()) {
			if(tokenStorage[ENDDATE_INDEX].empty()) {
				_isCorruptedToken = true;
			} else {
				if(tokenStorage[ENDTIME_INDEX].size() != TIME_LENGTH) {
					_isCorruptedToken = true;
				} else {
					if(!isNumber(tokenStorage[ENDTIME_INDEX])) {
						_isCorruptedToken = true;
					}
				}
			}
		}
	}
}

//if token not corrupted, adjust its format
//this is helpful when the user wants to modify the task detail directly in the text file withou running the program
//i.e. a task ends on 28 Feb, and the user wants to extend by 3 days but forgets noly 28 or 29 days in Feb, then this method will help adjust it to 3 Mar or 2 Mar according to that specific year
void WWFileStorage::adjustTokenContent(vector<string>& tokenStorage) {
	string startDate = tokenStorage[STARTDATE_INDEX];
	string startTime = tokenStorage[STARTTIME_INDEX];
	string endDate   = tokenStorage[ENDDATE_INDEX];
	string endTime   = tokenStorage[ENDTIME_INDEX];

	if(!startDate.empty()) {
		adjustDateTime(startDate, startTime);  //adjust format of date and time strings if date string is not empty
	}
	if(!endDate.empty()) {
		adjustDateTime(endDate, endTime);  //adjust format of date and time strings if date string is not empty
	}

	tokenStorage[STARTDATE_INDEX] = startDate;
	tokenStorage[STARTTIME_INDEX] = startTime;
	tokenStorage[ENDDATE_INDEX]   = endDate;
	tokenStorage[ENDTIME_INDEX]   = endTime;

	// If the status is neither "DONE" nor "UNDONE", this method will automatically
	// set it as "UNDONE".
	if(tokenStorage[STATUS_INDEX] != DONE_INDICATOR && tokenStorage[STATUS_INDEX] != UNDONE_INDICATOR) {
		tokenStorage[STATUS_INDEX] = UNDONE_INDICATOR;
	}
}

//adjust date and time string to correct format
//i.e. 20140231 is adjusted to 20140303, 0964 is adjusted to 1004
//strings already have correct format will not be adjusted
//i.e 20140415, 0819 will not be adjusted
void WWFileStorage::adjustDateTime(string &contentDate, string &contentTime) {
	int min = 0, hr = 0, day = 0, mon = 0, year = 0;
	WWConverter converter;
	struct tm tmStruct;
	time_t timeInfo;

	string date = contentDate;
	converter.convertDateStringToInt(date, day, mon, year);

	assert(!date.empty());  //date must not be empty

	//retrieving parameters needed to construct a tm object
	tmStruct.tm_mday  = day;
	tmStruct.tm_mon   = mon - SYSTEM_MONTH_ADJUSTMENT;  //range for tm_mon is 0-11
	tmStruct.tm_year  = year - SYSTEM_YEAR_ADJUSTMENT;  //range for tm_year is from 1900
	
	string time = contentTime;
	if(!time.empty()) {
		converter.convertTimeStringToInt(time, hr, min);
	}

	//if time string is not empty, then tm_min and tm_hour are retrieved from that
	//otherwise they are still zero
	tmStruct.tm_min   = min;
	tmStruct.tm_hour  = hr;
	
	//parameters needed to construct a tm object, but not used by our program are set to zero
	tmStruct.tm_isdst = TMSTRUCT_PARAMETER;
	tmStruct.tm_sec   = TMSTRUCT_PARAMETER;
	tmStruct.tm_wday  = TMSTRUCT_PARAMETER;
	tmStruct.tm_yday  = TMSTRUCT_PARAMETER;

	//adjust the tm object to correct format
	timeInfo = mktime(&tmStruct);
	localtime_s(&tmStruct, &timeInfo);

	//get back parameters needed by our program
	int resultYear = tmStruct.tm_year + SYSTEM_YEAR_ADJUSTMENT;
	int resultMon  = tmStruct.tm_mon + SYSTEM_MONTH_ADJUSTMENT;
    int resultDay  = tmStruct.tm_mday;
	int resultHr   = tmStruct.tm_hour;
    int resultMin  = tmStruct.tm_min;

	string resultDate, resultTime;
	 
	converter.convertIntDateToString(resultDay, resultMon, resultYear, resultDate);
	converter.convertIntTimeToString(resultHr, resultMin, resultTime);

	contentDate = resultDate;
	if(!time.empty()) {  //if time string is empty, it will not be modified throughout this method
		contentTime = resultTime;
	}
}

//check whether a string purely consists of integers
bool WWFileStorage::isNumber(const string& s) {
    string::const_iterator it = s.begin();

    while (it != s.end() && isdigit(*it)) {
		++it;
	}

    return !s.empty() && it == s.end();
}

//encapsulate details of a WWTask object with corresponding tokens in tokenStorage
WWTask WWFileStorage::createTaskWithTokens(vector<string>& tokenStorage) {
	WWTask newTask;

	if(tokenStorage[TASKNAME_INDEX] != EMPTY_PARAMETER) {
		newTask.setTaskName(tokenStorage[TASKNAME_INDEX]);
	}

	if(tokenStorage[TASKNAME_INDEX] != EMPTY_PARAMETER) {
		newTask.setStartDate(tokenStorage[STARTDATE_INDEX]);
	}

	if(tokenStorage[TASKNAME_INDEX] != EMPTY_PARAMETER) {
		newTask.setStartTime(tokenStorage[STARTTIME_INDEX]);
	}

	if(tokenStorage[TASKNAME_INDEX] != EMPTY_PARAMETER) {
		newTask.setEndDate(tokenStorage[ENDDATE_INDEX]);
	}

	if(tokenStorage[TASKNAME_INDEX] != EMPTY_PARAMETER) {
		newTask.setEndTime(tokenStorage[ENDTIME_INDEX]);
	}

	if(tokenStorage[TASKNAME_INDEX] != EMPTY_PARAMETER) {
		bool taskStatus = stringToBool(tokenStorage[STATUS_INDEX]);
		newTask.setStatus(taskStatus);
	}

	return newTask;
}

//convert the string of "true" or "false" to a bool _isDone of a WWTask object
bool WWFileStorage::stringToBool(string inputString) {
	bool isDoneStatus = false;

	if(inputString == DONE_INDICATOR) {
		isDoneStatus = true;
	}

	return isDoneStatus;
}

//convert a bool _isDone to a string of "true" or "false"
string WWFileStorage::boolToString(bool isDone) {
	string statusString;

	if(isDone) {
		statusString = DONE_INDICATOR;
	} else {
		statusString = UNDONE_INDICATOR;
	}

	return statusString;
}

//convert a WWTask object to a string by separating each attribute by a ";"
//then this string will be written in the text file
string WWFileStorage::taskToString(WWTask inputTask) {
	string statusString = boolToString(inputTask.getStatus());

	ostringstream oss;

	oss << inputTask.getTaskName() << PARAMETER_SEPARATOR
		<< inputTask.getStartDate() << PARAMETER_SEPARATOR  
		<< inputTask.getStartTime() << PARAMETER_SEPARATOR		
		<< inputTask.getEndDate() << PARAMETER_SEPARATOR		
		<< inputTask.getEndTime() << PARAMETER_SEPARATOR
		<< statusString << PARAMETER_SEPARATOR;

	return oss.str();
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWFileStorage.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWHistoryStorage.cpp
	 */

// WWHistoryStorage.cpp

#include "WWHistoryStorage.h"
#include "WWTask.h"
#include "WWUtilities.h"
#include <stack>
#include <string>
#include <vector>

using namespace std;

const int UNDO_MINSIZE = 2;

const string UNDO_EXCEPTION = "undo not available";
const string REDO_EXCEPTION = "redo not available";

WWHistoryStorage::WWHistoryStorage() {
}

//save every important operation by the user to a stack
//meanwhile search result and page type used for the display on GUI are also saved
//this helps the user get back to the corresponding display page where he made an operation
void WWHistoryStorage::saveOper(const vector<WWTask>& taskStorage, const vector<WWTask>& searchResult, WWUtilities::PageType pageType) {
	clearRedoStacks();   //once a new operation is saved, redo will no longer be available unless the user makes further undo cammand

	_undoTaskStorage.push(taskStorage);
	_undoSearchResult.push(searchResult);
	_undoPageType.push(pageType);
}

//user can undo an operation
//taskStorage is modified into the previous state of taskStorage, so are searchResult and pageType
bool WWHistoryStorage::Undo(vector<WWTask>& taskStorage, vector<WWTask>& searchResult, WWUtilities::PageType& pageType) {
	bool undoStatus = false;

	if(!_undoTaskStorage.empty()) {  

		//top of undo stacks is are pushed into redo stacks for use of future redo cammand
		_redoTaskStorage.push(_undoTaskStorage.top());
		_redoSearchResult.push(_undoSearchResult.top());
		_redoPageType.push(_undoPageType.top());

		//once the program starts initially, size of undo stacks is 2
		//only if size of undo stacks is >= 2, undo is available. otherwise, the initial state when program first starts is reached
		if(_undoTaskStorage.size() > UNDO_MINSIZE) {
			_undoTaskStorage.pop();
			_undoSearchResult.pop();
			_undoPageType.pop();

			undoStatus = true;
		}

		taskStorage.clear();
		searchResult.clear();

		//taskStorage is modified into its previous state, which is the top of undo stack. if initial state is reached and undo is not available, taskStorage will stay at initial state
		//similar for searchResult and pageType
		for(unsigned int i=0; i<_undoTaskStorage.top().size(); i++) {
			taskStorage.push_back(_undoTaskStorage.top()[i]);
		}
		for(unsigned int i=0; i<_undoSearchResult.top().size(); i++) {
			searchResult.push_back(_undoSearchResult.top()[i]);
		}
		pageType = _undoPageType.top();
	}

	//if undo not available, redo stacks will pop to get rid of that extra copy of the top of undo stacks
	if(undoStatus == false) {
		_redoTaskStorage.pop();
		_redoSearchResult.pop();
		_redoPageType.pop();
	}

	return undoStatus;
}

//user can undo an operation
//taskStorage is modified into the state of before the last undo, so are searchResult and pageType
bool WWHistoryStorage::Redo(vector<WWTask>& taskStorage, vector<WWTask>& searchResult, WWUtilities::PageType& pageType) {
	bool redoStatus = false;

	//redo is available when redo stacks are not empty
	if(!_redoTaskStorage.empty()) {
		taskStorage.clear();
		searchResult.clear();

		//taskStorage is modified into the state before the last undo, which is the top of redo stack. 
		//similar for searchResult and pageType
		for(unsigned int i=0; i<_redoTaskStorage.top().size(); i++) {
			taskStorage.push_back(_redoTaskStorage.top()[i]);
		}	
		for(unsigned int i=0; i < _redoSearchResult.top().size(); i++) {
			searchResult.push_back(_redoSearchResult.top()[i]);
		}
		pageType = _redoPageType.top();

		//top of redo stacks is pushed into undo stacks for further undo command
		_undoTaskStorage.push(_redoTaskStorage.top());
		_undoSearchResult.push(_redoSearchResult.top());
		_undoPageType.push(_redoPageType.top());

		_redoTaskStorage.pop();
		_redoSearchResult.pop();
		_redoPageType.pop();

		redoStatus = true;
	}

	//if redo not available, taskStorage, searchResult and pageType are not modified

	return redoStatus;
}

//clear all redo stacks
void WWHistoryStorage::clearRedoStacks() {
	while(!_redoTaskStorage.empty()) {
		_redoTaskStorage.pop();
		_redoSearchResult.pop();
		_redoPageType.pop();
	}
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWHistoryStorage.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWStorage.cpp
	 */

// WWstorage.cpp

#include "WWStorage.h"
#include "WWTask.h"
#include "WWFileStorage.h"
#include "WWHistoryStorage.h"
#include "WWUtilities.h"
#include "WWLogger.h"
#include <vector>

using namespace std;

const string SAVEOPER_LOG    = "user operation saved";
const string SAVEFILE_LOG    = "text file saved";
const string OPENSUCCESS_LOG = "text file opened successfully";
const string CORRUPTFILE_LOG = "text file corrupted";
const string UNDOSUCCESS_LOG = "undo successful";
const string UNDOFAIL_LOG    = "undo not available";
const string REDOSUCCESS_LOG = "redo successful";
const string REDOFAIL_LOG    = "redo not available";

WWStorage::WWStorage() {
}

void WWStorage::saveOper(const vector<WWTask>& taskStorage, const vector<WWTask>& searchResult, WWUtilities::PageType pageType) {
	_hisStore.saveOper(taskStorage, searchResult, pageType);

	//logging user operation
	WWLogger &log = WWLogger::getInstance();
	log.addLog(SAVEOPER_LOG);
	log.saveLog();
}

void WWStorage::saveFile(vector<WWTask>& fileContent) {
    _fileStore.saveFile(fileContent);

	//logging text file saving
	WWLogger &log = WWLogger::getInstance();
	log.addLog(SAVEFILE_LOG);
	log.saveLog();
}

bool WWStorage::openFile(vector<WWTask>& fileContent, vector<WWTask>& searchResult) {

	bool isOpenFileSuccess = _fileStore.openFile(fileContent);

	if(isOpenFileSuccess) {
		_hisStore.saveOper(fileContent, searchResult, WWUtilities::PAGEALL);

		//logging successful text file opening
		WWLogger &log = WWLogger::getInstance();
		log.addLog(OPENSUCCESS_LOG);
		log.saveLog();
	} else {
		//logging corrupted text file
		WWLogger &log = WWLogger::getInstance();
		log.addLog(CORRUPTFILE_LOG);
		log.saveLog();
	}

	return isOpenFileSuccess;
}

bool WWStorage::undo(vector<WWTask>& taskStorage, vector<WWTask>& searchResult, WWUtilities::PageType& pageType) {

	return _hisStore.Undo(taskStorage, searchResult, pageType);
}

bool WWStorage::redo(vector<WWTask>& taskStorage, vector<WWTask>& searchResult, WWUtilities::PageType& pageType) {

	return _hisStore.Redo(taskStorage, searchResult, pageType);
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWStorage.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWTask.cpp
	 */

// WWTask.cpp

#include <string>
#include <cassert>
#include "WWTask.h"
#include "WWTaskTime.h"
#include "WWUtilities.h"

using namespace std;

WWTask::WWTask() {
	_isDone = false;
	_isOverdue = false;
	_isToday = false;
}

void WWTask::setTaskName(string inputTaskName) {
	_taskName = inputTaskName;
}

void WWTask::setStartDate(string inputDate) {
	_startDate = inputDate;
}

void WWTask::setStartTime(string inputTime) {
	_startTime = inputTime;
}

void WWTask::setEndDate(string inputDate) {
	_endDate = inputDate;
}

void WWTask::setEndTime(string inputTime) {
	_endTime = inputTime;
}

void WWTask::setStatus(bool inputStatus) {
	_isDone = inputStatus;
}
	
bool WWTask::hasTaskName() {
	return (!_taskName.empty());
}

bool WWTask::hasStartDate() {
	return (!_startDate.empty());
}

bool WWTask::hasStartTime() {
	return (!_startTime.empty());
}

bool WWTask::hasEndDate() {
	return (!_endDate.empty());
}

bool WWTask::hasEndTime() {
	return (!_endTime.empty());
}

string WWTask::getTaskName() {
	return _taskName;
}

string WWTask::getStartDate() {
	return _startDate;
}

string WWTask::getStartTime() {
	return _startTime;
}

string WWTask::getEndDate() {
	return _endDate;
}

string WWTask::getEndTime() {
	return _endTime;
}

bool WWTask::getStatus() {
	return _isDone;
}

bool WWTask::checkOverdue() {
	refresh();
	return _isOverdue;
}

bool WWTask::checkToday() {
	refresh();
	return _isToday;
}

WWUtilities::TaskType WWTask::getTaskType() {
	refresh();
	return _taskType;
}

//refresh is used to update _taskType, _isOverdue and _isToday which are determined by other date and time fields
//these three attributes are not set by users, but only updated with private methods
void WWTask::refresh() {
	updateTaskType();

	if(_taskType == WWUtilities::TIMED) {
		rearrangeDateTime();
	}

	if(_taskType != WWUtilities::FLOATING) {
		_isOverdue = _taskTime.isOverdue(_startDate, _startTime);
		_isToday = _taskTime.isToday(_startDate);
	}
}

//update _taskType attribute of a WWTask object, depending on the date and time attributes it has
//i.e. a WWTask object without a start date and an end date will be classified as a FLOATING task
void WWTask::updateTaskType() {
	if(!hasStartDate() && !hasStartTime() && !hasEndDate() && !hasEndTime()) {
		_taskType = WWUtilities:: FLOATING;
	}

	if(hasStartDate() && !hasEndDate()) {
		_taskType = WWUtilities:: DEADLINE;   //we store the deadline date in _startDate, deadline time in _startTime
	}

	if(hasStartDate() && hasEndDate()) {
		_taskType = WWUtilities:: TIMED;
	}
}

//make sure that the end date of a TIMED task is always later than its start date
//if a TIMED task starts and ends on the same day, the end time should always be later than the start time
void WWTask::rearrangeDateTime() {
	int startDateInt = stringToInt(_startDate);
	int endDateInt = stringToInt(_endDate);

	if(startDateInt > endDateInt) {
		string temp;
		
		temp       = _startDate;
		_startDate = _endDate;
		_endDate   = temp;

		if(!_endTime.empty()) {
			temp       = _startTime;
			_startTime = _endTime;
			_endTime   = temp;
		}
	} 
	
	if(startDateInt == endDateInt) {
		int startTimeInt = stringToInt(_startTime);
		int endTimeInt   = stringToInt(_endTime);

		if(startTimeInt > endTimeInt) {
			string temp;
		
			temp       = _startTime;
			_startTime = _endTime;
			_endTime   = temp;
		}
	}

	startDateInt = stringToInt(_startDate);
	endDateInt   = stringToInt(_endDate);

	assert(startDateInt <= endDateInt);  //_startDate must be earlier or equal to _endDate after this rearrange method
}

int WWTask::stringToInt(string inputString) {
	return atoi(inputString.c_str());
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWTask.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWTaskTime.cpp
	 */

// WWTaskTime.cpp

#include "WWTaskTime.h"
#include "WWUtilities.h"
#include "WWConverter.h"
#include <string>
#include <cassert>

using namespace std;

WWTaskTime::WWTaskTime() {
}

//we define overdue tasks as follows
//a FLOATING task will never be overdue
//a DEADLINE task is overdue when its deadline is earlier than the current system date(time)
//a TIMED task is overdue when its start date(time) is earlier than the current system time
//if there is no start time for a TIMED task and its start date is today, it is not overdue
bool WWTaskTime::isOverdue(string startDate, string startTime) {
	string curDate;
	string curTime;
	WWConverter converter;

	assert(!startDate.empty());  //startDate must not be empty

	WWUtilities& Time = WWUtilities::getInstance();  //retrieving system date and time

	// extract the components needed from system date and time
	int curMin  = Time.getCurrentMinute();
	int curHr   = Time.getCurrentHour();
	int curDay  = Time.getCurrentDay();
	int curMon  = Time.getCurrentMonth();
	int curYear = Time.getCurrentYear();

	converter.convertIntDateToString(curDay, curMon, curYear, curDate);
	converter.convertIntTimeToString(curHr, curMin, curTime);

	//convert integer string to integer for easier comparison
	int curDateInt = atoi(curDate.c_str());
	int curTimeInt = atoi(curTime.c_str());

	int startDateInt = atoi(startDate.c_str());
	int startTimeInt = atoi(startTime.c_str());

	_overdue = false;
	if(startDateInt < curDateInt) {
		_overdue = true;
	} 
	if((startDateInt == curDateInt) && (!startTime.empty()) && (startTimeInt < curTimeInt)) {
		_overdue = true;
	}

	return _overdue;
}

//we define today tasks as follows
//a FLOATING task is not a today task
//a DEADLINE task is a today task if its deadline date is current system date
//a TIMED task is a today task if its start date is current system date
bool WWTaskTime::isToday(string startDate) {
	string curDate;
	WWConverter converter;

	assert(!startDate.empty());  //startDate must not be empty

	WWUtilities& Time = WWUtilities::getInstance();  //retrieving system date and time

	// extract the components needed from system date and time
	int curMin  = Time.getCurrentMinute();
	int curHr   = Time.getCurrentHour();
	int curDay  = Time.getCurrentDay();
	int curMon  = Time.getCurrentMonth();
	int curYear = Time.getCurrentYear();

	converter.convertIntDateToString(curDay, curMon, curYear, curDate);

	//convert integer string to integer for easier comparison
	int curDateInt   = atoi(curDate.c_str());
	int startDateInt = atoi(startDate.c_str());

	_today = (startDateInt == curDateInt); 

	return _today;
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWTaskTime.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWTaskTest.cpp
	 */

// WWTaskTest.cpp

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

const string TASK_NAME       = "taskName";
const string START_DATE      = "19911105";
const string START_TIME      = "0636";
const string END_DATE        = "20140411";
const string END_TIME        = "2103";
const string EMPTY_PARAMETER = "";

namespace UnitTest
{
	TEST_CLASS(WWTaskTest)
	{
	public:
		TEST_METHOD(setGetTaskNameTest)
		{
			WWTask task;

			task.setTaskName(TASK_NAME);
			Assert::AreEqual(task.getTaskName(), TASK_NAME);
		}

		TEST_METHOD(setGetDateTest)
		{
			WWTask task;

			task.setStartDate(START_DATE);
			Assert::AreEqual(task.getStartDate(), START_DATE);

			task.setEndDate(END_DATE);
			Assert::AreEqual(task.getEndDate(), END_DATE);			
		}

		TEST_METHOD(setGetTimeTest)
		{
			WWTask task;

			task.setStartTime(START_TIME);
			Assert::AreEqual(task.getStartTime(), START_TIME);

			task.setEndTime(END_DATE);
			Assert::AreEqual(task.getEndTime(), END_DATE);
		}

		TEST_METHOD(setGetStatusTest)
		{
			WWTask task;

			task.setStatus(true);
			Assert::IsTrue(task.getStatus());

			task.setStatus(false);
			Assert::IsFalse(task.getStatus());
		}

		//test using non-empty parameters and empty parameters
		TEST_METHOD(hasAttributeTest)
		{
			WWTask task;

			task.setTaskName(TASK_NAME);
			task.setStartDate(START_DATE);
			task.setStartTime(START_TIME);
			task.setEndDate(END_DATE);
			task.setEndTime(END_DATE);

			//non-empty parameters will return a bool of true
			Assert::IsTrue(task.hasTaskName());
			Assert::IsTrue(task.hasStartDate());
			Assert::IsTrue(task.hasStartTime());
			Assert::IsTrue(task.hasEndDate());
			Assert::IsTrue(task.hasEndTime());
						
			task.setTaskName(EMPTY_PARAMETER);
			task.setStartDate(EMPTY_PARAMETER);
			task.setStartTime(EMPTY_PARAMETER);
			task.setEndDate(EMPTY_PARAMETER);
			task.setEndTime(EMPTY_PARAMETER);

			//empty parameters will return a bool of false
			Assert::IsFalse(task.hasTaskName());
			Assert::IsFalse(task.hasStartDate());
			Assert::IsFalse(task.hasStartTime());
			Assert::IsFalse(task.hasEndDate());
			Assert::IsFalse(task.hasEndTime());
		}
		
		TEST_METHOD(checkTaskType)
		{
			WWTask task;

			task.setTaskName(TASK_NAME);
			task.setStartDate(START_DATE);
			task.setStartTime(START_TIME);
			task.setEndDate(END_DATE);
			task.setEndTime(END_DATE);
			
			WWUtilities::TaskType timed = WWUtilities::TIMED;

			//if start date, end date, start time, end time are not empty, task is a timed task
			Assert::IsTrue(timed == task.getTaskType());

			task.setStartTime(EMPTY_PARAMETER);
			task.setEndTime(EMPTY_PARAMETER);

			//if only start date and end date are not empty, task is still a timed task
			Assert::IsTrue(timed == task.getTaskType());

			task.setStartDate(EMPTY_PARAMETER);
			task.setStartTime(EMPTY_PARAMETER);
			task.setEndDate(EMPTY_PARAMETER);
			task.setEndTime(EMPTY_PARAMETER);

			WWUtilities::TaskType floating = WWUtilities::FLOATING;

			//if both start date and end date are empty(meaning start time and end time are also empty, checked by parser)
			//task is a floating task
			Assert::IsTrue(floating == task.getTaskType());

			task.setStartDate(START_DATE);

			WWUtilities::TaskType deadline = WWUtilities::DEADLINE;

			//if a task only has a start date, it is a deadline task
			Assert::IsTrue(deadline == task.getTaskType());

			task.setStartTime(START_TIME);

			//if a task only has start date and start time, it is still deadline task
			Assert::IsTrue(deadline == task.getTaskType());
		}
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWTaskTest.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWTaskTimeTest.cpp
	 */

// WWTaskTimeTest.cpp

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

const string PAST_DATE     = "20140411";
const string PAST_TIME     = "0001";
const string FUTURE_DATE   = "20240411";
const string FUTURE_TIME   = "2359";

namespace WorkWorkTest
{
	TEST_CLASS(WWTaskTimeTest)
	{
	public:
		
		TEST_METHOD(checkOverdue) 
		{
			WWTaskTime taskTime;
			
			Assert::IsTrue(taskTime.isOverdue(PAST_DATE, PAST_TIME));
			Assert::IsTrue(taskTime.isOverdue(PAST_DATE, FUTURE_TIME));
			Assert::IsFalse(taskTime.isOverdue(FUTURE_DATE, PAST_TIME));
			Assert::IsFalse(taskTime.isOverdue(FUTURE_DATE, FUTURE_TIME));
		}
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkTest\WWTaskTimeTest.cpp





