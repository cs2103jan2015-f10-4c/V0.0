//@author: a0105476e



	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\AddExecutor.cpp
	 */


//**********************************************************
//					  Author: AI YUE
//
//					File: AddExecutor.cpp
//**********************************************************

#include <vector>
#include "WWTask.h"
#include "WWDisplay.h"
#include "WWUtilities.h"
#include "TaskSorter.h"
#include "AddExecutor.h"

AddExecutor::AddExecutor(void){
}


void AddExecutor::addTask(std::vector<WWTask>& taskStorage, WWTask newTask, WWDisplay& display) {
	bool addStatus = false;
	std::string taskName;
	TaskSorter& taskSorter = TaskSorter::getInstance();

	if(newTask.hasTaskName()) {
		taskStorage.push_back(newTask);
		taskName = newTask.getTaskName();
		addStatus = true;
	}

	//auto sort the taskList after added in the new task
	taskSorter.sortTask(taskStorage);

	//pageType in display will be set to PAGEALL
	display.setMainDisplay(taskStorage, WWUtilities::PAGEALL);
	display.setSystemResponse(WWUtilities::ADD, taskName, addStatus);
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\AddExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\DeleteExecutor.cpp
	 */


//*************************************************************************
//					          Author: AI YUE
//
//					      File: DeleteExecutor.cpp
//*************************************************************************

#include <vector>
#include "WWTask.h"
#include "WWDisplay.h"
#include "WWStorage.h"
#include "WWUtilities.h"
#include "TaskSorter.h"
#include "DeleteExecutor.h"

DeleteExecutor::DeleteExecutor(void){
}

void DeleteExecutor::deleteTask(std::vector<WWTask>& taskStorage, unsigned int index, WWUtilities::PageType pageType, WWDisplay& display){
	bool deleteStatus = false;
	string taskName;
	 
	//check whether the index is valid
	if(index >= 0 && index < taskStorage.size()){
		taskName = taskStorage[index].getTaskName();
		taskStorage.erase(taskStorage.begin() + index);

		deleteStatus = true;
	}

	//pageType in display will stay in the original page
	display.setMainDisplay(taskStorage, pageType);
	display.setSystemResponse(WWUtilities::DELETE, taskName, deleteStatus);
}

	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\DeleteExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\EditExecutor.cpp
	 */


//**************************************************************
//					  Author: AI YUE
//
//					File: EditExecutor.cpp
//**************************************************************

#include <vector>
#include "WWTask.h"
#include "WWDisplay.h"
#include "WWUtilities.h"
#include "TaskSorter.h"
#include "EditExecutor.h"

EditExecutor::EditExecutor(void){
}

void EditExecutor::editTask(std::vector<WWTask>& taskStorage, unsigned int index, WWTask newTask, WWUtilities::PageType pageType, WWDisplay& display){
	bool editStatus = false;
	std::string taskName;
	TaskSorter taskSorter = TaskSorter::getInstance();

	if((!taskStorage.empty()) && (index >= 0) && (index < taskStorage.size())) {

		//if newTask has taskName, overwrite the taskname using the taskName in newTask
		if(newTask.hasTaskName()){                                       
			taskStorage[index].setTaskName(newTask.getTaskName());		
		}

		//if newTask has startDate, overwrite the startDate using the startDate of newTask
		if(newTask.hasStartDate()){                                    
			taskStorage[index].setStartDate(newTask.getStartDate());	
		}

		//if newTask has startTime, overwrite the startTime using the startTime of newTask
		if(newTask.hasStartTime()){
			taskStorage[index].setStartTime(newTask.getStartTime());	
		}

		//if newTask has endDate, overwrite the endDate using the endDate of newTask
		if(newTask.hasEndDate()){
			taskStorage[index].setEndDate(newTask.getEndDate());		
		}

		//if newTask has endTime, overwrite the endTime using the endTime of newTask
		if(newTask.hasEndTime()){
			taskStorage[index].setEndTime(newTask.getEndTime());		
		}

		editStatus = true;

		taskName = taskStorage[index].getTaskName();
	}

	//sort the taskStorage after editing
	taskSorter.sortTask(taskStorage);

	display.setMainDisplay(taskStorage, pageType);
	display.setSystemResponse(WWUtilities::EDIT, taskName, editStatus);
}

	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\EditExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\SearchExecutor.cpp
	 */


//*******************************************************************
//					  Author: AI YUE
//
//					File: SearchExecutor.cpp
//*******************************************************************

#include <string>
#include <algorithm>
#include <ctype.h>
#include "WWTask.h"
#include "WWDisplay.h"
#include "WWUtilities.h"
#include "TaskSorter.h"
#include "SearchExecutor.h"

const int DATE_MULTIPLIER  = 10000;    //for create a long long int in this formate yyyymmddhhmm
const int LARGEST_TIME_INT = 2359;	   //the largest time integer

SearchExecutor::SearchExecutor(void){
}

//search keyword only
void SearchExecutor::searchTask(std::vector<WWTask> taskStorage, std::string keyword, WWDisplay& display){
	_taskList.clear();
	_searchResult.clear();

	//keep a copy of taskStorage into taskList
	_taskList = taskStorage;         
	TaskSorter taskSorter = TaskSorter::getInstance();

	//convert all the task name and search keyword to upper cases to do case insensitive search
	std::transform(keyword.begin(), keyword.end(), keyword.begin(), toupper);

	std::string curTaskName;

	for(unsigned int i = 0; i < _taskList.size(); i++){
		curTaskName = _taskList[i].getTaskName();

		//convert task name to upper cases to do case insensitive search
		std::transform(curTaskName.begin(), curTaskName.end(), curTaskName.begin(), toupper);

		//if the task name contains the keyword, remove the task from the _taskList and put it into the _searchResult
		if(curTaskName.find(keyword) != std::string::npos){                
			_searchResult.push_back(_taskList[i]);
			_taskList.erase(_taskList.begin() + i);
			i--;
		}
	}

	taskSorter.sortTask(_searchResult);

	display.setMainDisplay(_searchResult, WWUtilities::PAGESEARCH);
	display.setSystemResponseSearch(_searchResult.size());
}

// search keyword and time period
void SearchExecutor::searchTask(std::vector<WWTask> taskStorage, std::string keyword, long long startTime, long long endTime, WWDisplay& display){
	_taskList.clear();
	_searchResult.clear();

	//keep a copy of taskStorage into taskList
	_taskList = taskStorage;          
	TaskSorter taskSorter = TaskSorter::getInstance();

	//convert all the task name and search keyword to upper cases to do case insensitive search
	std::transform(keyword.begin(), keyword.end(), keyword.begin(), toupper);

	std::string curTaskName;
	long long curStartTime;
	long long curEndTime;

	for(unsigned int i = 0; i < _taskList.size(); i++){
		curTaskName = _taskList[i].getTaskName();

		//convert the curTaskName to upper cases to do case insensitive search
		std::transform(curTaskName.begin(), curTaskName.end(), curTaskName.begin(), toupper);

		//we find the tasks whos names contain the keyword first
		//if find the keyword, check whether the task time is inside the time period
		if(curTaskName.find(keyword) != std::string::npos){  

			//for deadline task, task is considered within the period as long as the deadline is within the period
			if(_taskList[i].getTaskType() == WWUtilities::DEADLINE){
				
				//timp period of a deadline task with time and date will be considered as both start time and end time
				// are same at the due time
				//time period of a deadline task with only date will be considered as from that date 0000 - 2359
				if(_taskList[i].hasStartTime()){
					curStartTime = (long long)stoi(_taskList[i].getStartDate(), nullptr) * DATE_MULTIPLIER + stoi(_taskList[i].getStartTime());
					curEndTime = curStartTime;				
				} else {
					curStartTime = (long long)stoi(_taskList[i].getStartDate(), nullptr) * DATE_MULTIPLIER;
					curEndTime = (long long)stoi(_taskList[i].getStartDate(), nullptr) * DATE_MULTIPLIER + LARGEST_TIME_INT;
				}

				//if the task satisfies the search criterion, remove the task from the _taskList and put it into the _searchResult
				if(!((curStartTime > endTime)||(curEndTime < startTime))){
					_searchResult.push_back(_taskList[i]);
					_taskList.erase(_taskList.begin() + i);
					i--;
				}
			} else if(_taskList[i].getTaskType() == WWUtilities::TIMED){
				// for timed task, task is considered within the period as long as there is overlap

				// if the start time has only date, the time will be set as 0000
				if(_taskList[i].hasStartTime()){
					curStartTime = (long long)stoi(_taskList[i].getStartDate(), nullptr) * DATE_MULTIPLIER + stoi(_taskList[i].getStartTime());
				} else {
					curStartTime = (long long)stoi(_taskList[i].getStartDate(), nullptr) * DATE_MULTIPLIER;
				}

				// if the end time has only date, the time will be set as 2359
				if(_taskList[i].hasEndTime()){
					curEndTime = (long long)stoi(_taskList[i].getEndDate(), nullptr) * DATE_MULTIPLIER + stoi(_taskList[i].getEndTime());
				} else {
					curEndTime = (long long)stoi(_taskList[i].getEndDate(), nullptr) * DATE_MULTIPLIER + LARGEST_TIME_INT;
				}

				if(!((curStartTime > endTime)||(curEndTime < startTime))){
					_searchResult.push_back(_taskList[i]);
					_taskList.erase(_taskList.begin() + i);
					i--;
				}
			}
		}
	}

	taskSorter.sortTask(_searchResult);

	display.setMainDisplay(_searchResult, WWUtilities::PAGESEARCH);
	display.setSystemResponseSearch(_searchResult.size());
}

void SearchExecutor::getSearchResult(std::vector<WWTask>& searchResult){
	searchResult.clear();
	for(unsigned int i = 0; i < _searchResult.size(); i++){
		searchResult.push_back(_searchResult[i]);
	}
}

void SearchExecutor::getTaskStorage(std::vector<WWTask> resultList, std::vector<WWTask>& taskStorage){
	taskStorage.clear();

	for(unsigned int i = 0; i < _taskList.size(); i++){
		taskStorage.push_back(_taskList[i]);
	}

	for(unsigned int i = 0; i < resultList.size(); i++){
		taskStorage.push_back(resultList[i]);
	}

	//sort the taskStorage after merge
	TaskSorter taskSorter = TaskSorter::getInstance();
	taskSorter.sortTask(taskStorage);
}


	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\SearchExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\StatusExecutor.cpp
	 */


//*****************************************************************
//					  Author: AI YUE
//
//					File: StatusExecutor.cpp
//*****************************************************************

#include <vector>
#include "WWDisplay.h"
#include "WWTask.h"
#include "WWUtilities.h"
#include "TaskSorter.h"
#include "StatusExecutor.h"

StatusExecutor::StatusExecutor(void){
}

void StatusExecutor::markDone(std::vector<WWTask>& taskStorage, unsigned int index, WWUtilities::PageType pageType, WWDisplay& display){
	bool markStatus = false;
	std::string taskName;
	TaskSorter taskSorter = TaskSorter::getInstance();

	if((!taskStorage.empty()) && (index >= 0) && (index < taskStorage.size())) {
		taskName = taskStorage[index].getTaskName();
		if(!taskStorage[index].getStatus()) {
			taskStorage[index].setStatus(true);
			markStatus = true;
		}	
	}
	
	taskSorter.sortTask(taskStorage);

	display.setMainDisplay(taskStorage, pageType);
	display.setSystemResponse(WWUtilities::DONE, taskName, markStatus);
};

void StatusExecutor::markUndone(std::vector<WWTask>& taskStorage, unsigned int index, WWUtilities::PageType pageType, WWDisplay& display){
	bool markStatus = false;
	std::string taskName;
	TaskSorter taskSorter = TaskSorter::getInstance();

	if((!taskStorage.empty()) && (index >= 0) && (index < taskStorage.size())) {
		taskName = taskStorage[index].getTaskName();
		if(taskStorage[index].getStatus()) {
			taskStorage[index].setStatus(false);
			markStatus = true;
		}	
	}
	
	taskSorter.sortTask(taskStorage);

	display.setMainDisplay(taskStorage, pageType);
	display.setSystemResponse(WWUtilities::UNDONE, taskName, markStatus);
};
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\StatusExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\TaskSorter.cpp
	 */


//**************************************************************
//					  Author: AI YUE
//
//					File: TaskSorter.cpp
//**************************************************************

#include <algorithm>
#include "TaskSorter.h"

const int MAX_TIME_STRING = 13;		//for yyyymmddhhmm

TaskSorter::TaskSorter(void){
}

//the compare2Task is the compare method used by stable_sort algorithm
bool compare2Task(WWTask task_1, WWTask task_2){

	//done tasks sorted after undone tasks
	if((task_1.getStatus()) && (!task_2.getStatus())){                          
		return false;
	} else if ((!task_1.getStatus()) && (task_2.getStatus())){
		return true;
	} else if ((task_1.getStatus()) && (task_2.getStatus())){
		return false;
	} else if((!task_1.getStatus()) && (!task_2.getStatus())){

		//for undone tasks
		//floating tasks sorted after timed and deadline tasks
		if((task_1.getTaskType() == WWUtilities::FLOATING) && (task_2.getTaskType() != WWUtilities::FLOATING)){                //floating sorted after timed
			return false;															
		} else if ((task_1.getTaskType() != WWUtilities::FLOATING) && (task_2.getTaskType() == WWUtilities::FLOATING)){
			return true;
		} else if ((task_1.getTaskType() == WWUtilities::FLOATING) && (task_2.getTaskType() == WWUtilities::FLOATING)){
			return false;
		} else if((task_1.getTaskType() != WWUtilities::FLOATING) && (task_2.getTaskType() != WWUtilities::FLOATING)){
			
			//for timed and deadline tasks
			//they are sorted by time, where the start time a timed task is used
			char taskTime1[MAX_TIME_STRING];
			char taskTime2[MAX_TIME_STRING];

			sprintf_s(taskTime1, (task_1.getStartDate() + task_1.getStartTime()).c_str());
			sprintf_s(taskTime2, (task_2.getStartDate() + task_2.getStartTime()).c_str());

			int i = 0;
			while(taskTime1[i] != '\0'){
				while(taskTime2[i] != '\0'){
					if(taskTime1[i] < taskTime2[i]){
						return true;
					} else if(taskTime1[i] > taskTime2[i]){
						return false;
					}
					i++;
				}
				return false;
			}
			return false;
		}
	}
	return false;
}

void TaskSorter::sortTask(std::vector<WWTask>& taskList){
	stable_sort(taskList.begin(), taskList.end(), compare2Task);
}

	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\TaskSorter.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testAddExecutor.cpp
	 */


//**************************************************************
//			    Unit Test: AddExecutor Class
//					  Author: AI YUE
//
//			      File: testAddExecutor.cpp
//
// testAddExecutor tests 2 cases: 1. add task with task name
//                                2. add task without task name
//**************************************************************

#include <vector>
#include "stdafx.h"
#include "CppUnitTest.h"
#include "AddExecutor.h"
#include "WWTask.h"
#include "WWDisplay.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ExecutorUnitTest{
	TEST_CLASS(testAddExecutor){
	public:
		//*****************************************************************
		//        Positive test: test add task with task name
		//
		// 1. the task should be successfully added into the task vector
		// 2. pageType inside display should be set as PAGEALL
		// 3. systemResponse inside display should be set as add successful
		//   system response
		//*****************************************************************
		TEST_METHOD(test_addTask_with_taskname){
			AddExecutor addExecutor;
			WWTask testTask;
			WWDisplay display;
			std::vector<WWTask> taskList;

			std::string expectedTaskName;
			std::string actualTaskName;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			int expectedPageType;
			int actualPageType;

			//Arrange
			taskList.clear();
			testTask.setTaskName("test task");
			expectedTaskName = "test task";
			expectedSystemResponse = "test task created";
			expectedPageType = WWUtilities::PAGEALL;

			//Act
			addExecutor.addTask(taskList, testTask, display);
			actualTaskName = taskList[0].getTaskName();
			actualSystemResponse = display.getSystemResponse();
			actualPageType = display.getPageIndex();

			//Assert
			Assert::AreEqual((int)taskList.size(), 1);			//after add task, taskList size should be 1
			Assert::AreEqual(expectedTaskName, actualTaskName);
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
		}

	    //*****************************************************************
		//        Negative test: test add task without task name
		//
		// 1. the task will not be added into the task vector
		// 2. pageType inside display should be set as PAGEALL
		// 3. systemResponse inside display should be set as add failed
		//   system response
		//*****************************************************************
		TEST_METHOD(test_addTask_without_taskname){
			AddExecutor addExecutor;
			WWTask testTask;
			WWDisplay display;
			std::vector<WWTask> taskList;

			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			int expectedPageType;
			int actualPageType;

			//Arrange
			taskList.clear();
			testTask.setTaskName("");
			expectedSystemResponse = "Please input task name";
			expectedPageType = WWUtilities::PAGEALL;

			//Act
			addExecutor.addTask(taskList, testTask, display);
			actualSystemResponse = display.getSystemResponse();
			actualPageType = display.getPageIndex();

			//Assert
			Assert::AreEqual((int)taskList.size(), 0);			//task won't be added into the task vector, taskList size should remain 0
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
		}
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testAddExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testDeleteExecutor.cpp
	 */


//**************************************************************
//			    Unit Test: DeleteExecutor Class
//					  Author: AI YUE
//
//			      File: testDeleteExecutor.cpp
//
// testAddExecutor tests 2 cases: 1. delete a valid index
//                                2. delete an invalid index
//**************************************************************

#include <vector>
#include "stdafx.h"
#include "CppUnitTest.h"
#include "DeleteExecutor.h"
#include "WWDisplay.h"
#include "WWTask.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ExecutorUnitTest{
	TEST_CLASS(testDeleteExecutor){
	public:

		//********************************************************************
		//        Positive test: test delete valid index
		//
		// 1. the task should be successfully deleted from the task vector
		// 2. pageType inside display should remain same
		// 3. systemResponse inside display should be set as delete successful
		//   system response
		//********************************************************************
		TEST_METHOD(test_delete_valid_index){
			DeleteExecutor deleteExecutor;
			WWTask testTask;
			WWDisplay display;
			WWUtilities::PageType pageType = WWUtilities::PAGEALL;
			std::vector<WWTask> taskList;

			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			int expectedPageType;
			int actualPageType;

			//Arrange
			testTask.setTaskName("test task");
			taskList.push_back(testTask);
			expectedSystemResponse = "test task deleted";
			expectedPageType = pageType;

			//Act
			deleteExecutor.deleteTask(taskList, 0, pageType, display);
			actualSystemResponse = display.getSystemResponse();
			actualPageType = display.getPageIndex();

			//Assert
			Assert::AreEqual((int)taskList.size(), 0);			//after delete task, taskList size should be 0
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
		}

	    //*****************************************************************
		//        Negative test: test delete invalid index
		//
		// 1. the task will not be deleted from the task vector
		// 2. pageType inside display should remain unchanged
		// 3. systemResponse inside display should be set as delete failed
		//   system response
		//*****************************************************************
		TEST_METHOD(test_addTask_with_taskname){
			DeleteExecutor deleteExecutor;
			WWTask testTask;
			WWDisplay display;
			std::vector<WWTask> taskList;
			WWUtilities::PageType pageType = WWUtilities::PAGEALL;

			std::string expectedTaskName;
			std::string actualTaskName;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			int expectedPageType;
			int actualPageType;

			//Arrange
			taskList.clear();
			testTask.setTaskName("test task");
			taskList.push_back(testTask);
			expectedTaskName = "test task";
			expectedSystemResponse = "Index not found";
			expectedPageType = pageType;

			//Act
			deleteExecutor.deleteTask(taskList, 2, pageType, display);
			actualTaskName = taskList[0].getTaskName();
			actualSystemResponse = display.getSystemResponse();
			actualPageType = display.getPageIndex();

			//Assert
			Assert::AreEqual((int)taskList.size(), 1);			//the task will not be deleted, taskList size remains 1
			Assert::AreEqual(expectedTaskName, actualTaskName);
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
		}
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testDeleteExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testEditExecutor.cpp
	 */


//**************************************************************
//			    Unit Test: EditExecutor Class
//					  Author: AI YUE
//
//			      File: testEditExecutor.cpp
//
// testAddExecutor tests 2 cases: 1. edit task name
//                                2. edit invalid index
//**************************************************************

#include <vector>
#include "stdafx.h"
#include "CppUnitTest.h"
#include "EditExecutor.h"
#include "WWDisplay.h"
#include "WWTask.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ExecutorUnitTest{
	TEST_CLASS(testEditExecutor){
	public:
		//*****************************************************************
		//        Positive test: test edit task name
		//
		// 1. the taskname should be changed
		// 2. pageType inside display should be remain unchanged
		// 3. systemResponse inside display should be set as edit successful
		//   system response
		//*****************************************************************
		TEST_METHOD(test_edit_task_name){
			EditExecutor editExecutor;
			WWTask testTask;
			WWTask newTask;
			WWDisplay display;
			std::vector<WWTask> taskList;
			WWUtilities::PageType pageType = WWUtilities::PAGEALL;

			std::string expectedTaskName;
			std::string actualTaskName;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			int expectedPageType;
			int actualPageType;

			//Arrange
			taskList.clear();
			testTask.setTaskName("test task");
			taskList.push_back(testTask);
			newTask.setTaskName("test task edited");
			expectedTaskName = "test task edited";
			expectedSystemResponse = "test task edited edited";
			expectedPageType = pageType;

			//Act
			editExecutor.editTask(taskList, 0, newTask, pageType, display);
			actualTaskName = taskList[0].getTaskName();
			actualSystemResponse = display.getSystemResponse();
			actualPageType = display.getPageIndex();

			//Assert
			Assert::AreEqual((int)taskList.size(), 1);			//after add task, taskList size should remains 1
			Assert::AreEqual(expectedTaskName, actualTaskName);
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
		}

	    //*****************************************************************
		//        Negative test: test edit invalid index
		//
		// 1. the task will not be edited
		// 2. pageType inside display should remain unchanged
		// 3. systemResponse inside display should be set as edit failed
		//   system response
		//*****************************************************************
		TEST_METHOD(test_edit_invalid_index){
			EditExecutor editExecutor;
			WWTask testTask;
			WWTask newTask;
			WWDisplay display;
			std::vector<WWTask> taskList;
			WWUtilities::PageType pageType = WWUtilities::PAGEALL;

			std::string expectedTaskName;
			std::string actualTaskName;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			int expectedPageType;
			int actualPageType;

			//Arrange
			taskList.clear();
			testTask.setTaskName("test task");
			taskList.push_back(testTask);
			newTask.setTaskName("test task");
			expectedTaskName = "test task";
			expectedSystemResponse = "Index not found";
			expectedPageType = pageType;

			//Act
			editExecutor.editTask(taskList, 10, newTask, pageType, display);
			actualTaskName = taskList[0].getTaskName();
			actualSystemResponse = display.getSystemResponse();
			actualPageType = display.getPageIndex();

			//Assert
			Assert::AreEqual((int)taskList.size(), 1);			//taskList size should remains 1
			Assert::AreEqual(expectedTaskName, actualTaskName);
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
		}

	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testEditExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testExecutor.cpp
	 */


//***************************************************************
//			    Integration Test: WWExecutor
//					  Author: AI YUE
//
//			       File: testExecutor.cpp
//
// 3 functions was tested: 1. addTask
//						   2. searchTask
//						   3. editTask
//***************************************************************

#include "stdafx.h" 
#include "CppUnitTest.h"
#include "WWDisplay.h"
#include "WWExecutor.h"
#include "WWTask.h"
#include "WWUtilities.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace std;

namespace ExecutorUnitTest{		
	TEST_CLASS(testExecutor){
	public:
		//executor add integration test
		TEST_METHOD(Executor_Add_Task_Integration_Test)
		{
			WWExecutor executor;
			WWDisplay display;
			WWTask testTask1;
			WWTask testTask2;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			std::vector<std::string> taskDisplay;
			std::vector<std::vector<std::string>> expectedMainDisplay;
			std::vector<std::vector<std::string>> actualMainDisplay;
			int expectedPageType;
			int actualPageType;

			
			//test add task without type in taskName
			//task will not be added
			//systemResponse should return please input task name
			//return to page all
			display = executor.deleteAll();
			display = executor.addTask(testTask2); //testTask2 is empty without taskname now

			expectedSystemResponse = "Please input task name";
			expectedPageType = WWUtilities::PAGEALL;
			expectedMainDisplay.clear();

			actualMainDisplay = display.getMainDisplay();
			actualPageType = display.getPageIndex();
			actualSystemResponse = display.getSystemResponse();
			
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
			Assert::AreEqual(expectedMainDisplay.size(), actualMainDisplay.size());

			//test add one task
			testTask1.setTaskName("Task1");
			testTask1.setStartDate("20140325");
			testTask1.setStartTime("0800");

			display = executor.addTask(testTask1);
			expectedSystemResponse = "Task1 created";
			taskDisplay.push_back("Task1");	
			taskDisplay.push_back("Due  : 25 Mar 2014, 08:00am");		
			taskDisplay.push_back("overdue");


			expectedMainDisplay.push_back(taskDisplay);
			expectedPageType = WWUtilities::PAGEALL;

			actualMainDisplay = display.getMainDisplay();
			actualPageType = display.getPageIndex();
			actualSystemResponse = display.getSystemResponse();
			
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
			Assert::AreEqual(expectedMainDisplay.size(), actualMainDisplay.size());
			if(!expectedMainDisplay.size()){
				Assert::AreEqual(expectedMainDisplay[0].size(), actualMainDisplay[0].size());
			}
			
			for(unsigned int i = 0; i < expectedMainDisplay.size(); i++){
				for(unsigned int j = 0; j < 3; j++){
					Assert::AreEqual(expectedMainDisplay[i][j], actualMainDisplay[i][j]);
				}
			}

			//test add two tasks
			testTask2.setTaskName("Task2");
			expectedPageType = WWUtilities::PAGEALL;
			taskDisplay.clear();
			taskDisplay.push_back("Task2");
			taskDisplay.push_back("");
			taskDisplay.push_back("incomplete");
			expectedMainDisplay.push_back(taskDisplay);
			expectedSystemResponse = "Task2 created";

			display = executor.addTask(testTask2);

			actualMainDisplay = display.getMainDisplay();
			actualPageType = display.getPageIndex();
			actualSystemResponse = display.getSystemResponse();
			
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
			Assert::AreEqual(expectedMainDisplay.size(), actualMainDisplay.size());
			if(!expectedMainDisplay.size()){
				Assert::AreEqual(expectedMainDisplay[0].size(), actualMainDisplay[0].size());
			}

			for(unsigned int i = 0; i < expectedMainDisplay.size(); i++){
				for(unsigned int j = 0; j < 3; j++){
					Assert::AreEqual(expectedMainDisplay[i][j], actualMainDisplay[i][j]);
				}
			}
		}
		
		//executor search integration test
		TEST_METHOD(Executor_Search_Integration_Test){
			WWExecutor executor;
			WWDisplay display;
			WWTask testTask1;
			WWTask testTask2;
			WWTask testTask3;
			std::vector<std::string> testSearchAttributes;
			std::vector<std::string> taskDisplay;
			std::vector<std::vector<std::string>> expectedMainDisplay;
			std::vector<std::vector<std::string>> actualMainDisplay;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			int expectedPageType;
			int actualPageType;

			testTask1.setTaskName("Task1");
			testTask1.setStartDate("20140404");
			testTask1.setStartTime("0800");
			testTask1.setEndDate("20140405");
			display = executor.addTask(testTask1);
			testTask2.setTaskName("task2");
			testTask2.setStartDate("20140406");
			testTask2.setStartTime("0800");
			display = executor.addTask(testTask2);
			testTask3.setTaskName("3");
			testTask3.setStartDate("20140406");
			testTask3.setStartTime("0900");
			testTask3.setEndDate("20140406");
			testTask3.setEndTime("1900");
			display = executor.addTask(testTask3);

			//test search one keyword "task" only
			//two results should show: Task1 and task2

			//arrange
			testSearchAttributes.push_back("task");
			testSearchAttributes.push_back("");
			testSearchAttributes.push_back("");
			testSearchAttributes.push_back("");
			testSearchAttributes.push_back("");

			expectedSystemResponse = "2 results are found";
			expectedPageType = WWUtilities::PAGESEARCH;

			taskDisplay.clear();
			taskDisplay.push_back("Task1");
			taskDisplay.push_back("From: 04 Apr 2014, 08:00am\nTo     : 05 Apr 2014");
			taskDisplay.push_back("overdue");
			expectedMainDisplay.push_back(taskDisplay);

			taskDisplay.clear();
			taskDisplay.push_back("task2");
			taskDisplay.push_back("Due  : 06 Apr 2014, 08:00am");			
			taskDisplay.push_back("overdue");
			expectedMainDisplay.push_back(taskDisplay);

			//act
			display = executor.searchTask(testSearchAttributes);

			actualMainDisplay = display.getMainDisplay();
			actualPageType = display.getPageIndex();
			actualSystemResponse = display.getSystemResponse();
			
			//assert
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
			Assert::AreEqual(expectedMainDisplay.size(), actualMainDisplay.size());
			if(!expectedMainDisplay.size()){
				Assert::AreEqual(expectedMainDisplay[0].size(), actualMainDisplay[0].size());
			}

			for(unsigned int i = 0; i < expectedMainDisplay.size(); i++){
				for(unsigned int j = 0; j < 3; j++){
					Assert::AreEqual(expectedMainDisplay[i][j], actualMainDisplay[i][j]);
				}
			}

			//test search within a time period from 20140405 - 20140406 without keyword
			//2 results should be found: task2 and 3

			//Arrange
			testSearchAttributes.clear();
			testSearchAttributes.push_back("");
			testSearchAttributes.push_back("20140406");
			testSearchAttributes.push_back("");
			testSearchAttributes.push_back("");
			testSearchAttributes.push_back("");

			expectedSystemResponse = "2 results are found";
			expectedPageType = WWUtilities::PAGESEARCH;
			expectedMainDisplay.clear();

			taskDisplay.clear();
			taskDisplay.push_back("task2");
			taskDisplay.push_back("Due  : 06 Apr 2014, 08:00am");
			taskDisplay.push_back("overdue");
			expectedMainDisplay.push_back(taskDisplay);

			taskDisplay.clear();
			taskDisplay.push_back("3");
			taskDisplay.push_back("From: 06 Apr 2014, 09:00am\nTo     : 06 Apr 2014, 07:00pm");
			taskDisplay.push_back("overdue");
			expectedMainDisplay.push_back(taskDisplay);

			//act
			display = executor.searchTask(testSearchAttributes);

			actualMainDisplay.clear();
			actualMainDisplay = display.getMainDisplay();
			actualPageType = display.getPageIndex();
			actualSystemResponse = display.getSystemResponse();
			
			//assert
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedPageType, actualPageType);
			Assert::AreEqual(expectedMainDisplay.size(), actualMainDisplay.size());
			if(!expectedMainDisplay.size()){
				Assert::AreEqual(expectedMainDisplay[0].size(), actualMainDisplay[0].size());
			}

			for(unsigned int i = 0; i < expectedMainDisplay.size(); i++){
				for(unsigned int j = 0; j < 3; j++){
					Assert::AreEqual(expectedMainDisplay[i][j], actualMainDisplay[i][j]);
				}
			}
		} 

		//executor edit integration test
		TEST_METHOD(Executor_Edit_Integration_Test){
			WWTask testTemp;
			WWTask editTask;
			WWExecutor executor;
			WWDisplay display;
			std::vector<std::vector<std::string>> taskList;
			string expected;
			string actual;

			testTemp.setTaskName("Before Edit");
			testTemp.setStartDate("20140404");
			testTemp.setStartTime("0800");
			testTemp.setEndDate("20140405");
			testTemp.setEndTime("1800");

			display = executor.addTask(testTemp);
			expected = "Before Edit";
			taskList = display.getMainDisplay();
			Assert::AreEqual(expected, taskList[0][0]);

			//test edit name
			editTask.setTaskName("After Edit Name");

			display = executor.editTask(1, editTask, WWUtilities::PAGEALL);
			expected = "After Edit Name";
			taskList = display.getMainDisplay();
			actual = taskList[0][0];

			Assert::AreEqual(expected, actual);
		}
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testSearchExecutor.cpp
	 */


//**************************************************************
//			    Unit Test: SearchExecutor Class
//					  Author: AI YUE
//
//			      File: testSearchExecutor.cpp
//
// testSearchExecutor tests 1 cases: search keyword within time
//									period
//**************************************************************

#include <vector>
#include <string>
#include "stdafx.h"
#include "CppUnitTest.h"
#include "SearchExecutor.h"
#include "WWTask.h"
#include "WWUtilities.h"
#include "WWDisplay.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ExecutorUnitTest
{
	TEST_CLASS(testSearchExecutor)
	{
	public:
		TEST_METHOD(test_search_task_within_time_period)
		{
			SearchExecutor searchExecutor;
			WWDisplay display;
			std::vector<WWTask> taskList;
			std::vector<WWTask> resultList;
			WWTask testTask1, testTask2, testTask3, testTask4;

			std::string expectedSystemResponse;
			std::string actualSystemResponse;
			std::vector<std::string> expectedTaskNames;
			std::vector<std::string> actualTaskNames;

			//arrange
			testTask1.setTaskName("Floating task 1");
			taskList.push_back(testTask1);
			testTask2.setTaskName("Deadline task 1");
			testTask2.setStartDate("20140404");
			taskList.push_back(testTask2);
			testTask3.setTaskName("Timed task 1");
			testTask3.setStartDate("20140403");
			testTask3.setEndDate("20140405");
			testTask3.setEndTime("1800");
			taskList.push_back(testTask3);
			testTask4.setTaskName("Timed task 2");
			testTask4.setStartDate("20140405");
			testTask4.setStartTime("0200");
			testTask4.setEndDate("20140406");
			testTask4.setEndTime("0200");
			taskList.push_back(testTask4);

			expectedSystemResponse = "2 results are found";			
			expectedTaskNames.push_back("Timed task 1");
			expectedTaskNames.push_back("Deadline task 1");

			//act
			searchExecutor.searchTask(taskList, "", 201404040000, 201404042359, display);
			searchExecutor.getSearchResult(resultList);

			actualSystemResponse = display.getSystemResponse();

			//assert
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
			Assert::AreEqual(expectedTaskNames[0], resultList[0].getTaskName());
			Assert::AreEqual(expectedTaskNames[1], resultList[1].getTaskName());
		}

	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testSearchExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testSystemResponse.cpp
	 */


//**************************************************************
//			    Unit Test: SystemResponse Class
//					  Author: AI YUE
//
//			      File: testSystemResponse.cpp
//**************************************************************

#include "stdafx.h"
#include "CppUnitTest.h"
#include "WWSystemResponse.h"
#include "WWUtilities.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ExecutorUnitTest
{
	TEST_CLASS(testSystemResponse)
	{
	public:
		
		TEST_METHOD(TestAddResponse) 
		{
			WWSystemResponse systemResponse;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;

			//positive test, test the case of add successed
			systemResponse.setSystemResponse(WWUtilities::ADD, "taskName", true);
			expectedSystemResponse = "taskName created";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);

			//negative test, test the case of add failed
			systemResponse.setSystemResponse(WWUtilities::ADD, "taskName", false);
			expectedSystemResponse = "Please input task name";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);

			//boundary test, test the case of long taskName
			systemResponse.setSystemResponse(WWUtilities::ADD, "taskName01taskName02taskName03taskName04taskName05taskName06taskName07", true);
			expectedSystemResponse = "taskName01taskName02taskName03taskName04taskName05... created";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);

		}
	
		TEST_METHOD(TestDeleteResponse)
		{
			WWSystemResponse systemResponse;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;

			//positive test, test the case of delete succeed
			systemResponse.setSystemResponse(WWUtilities::DELETE, "taskName", true);
			expectedSystemResponse = "taskName deleted";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);

			//negative test, test the case of delete failed
			systemResponse.setSystemResponse(WWUtilities::DELETE, "taskName", false);
			expectedSystemResponse = "Index not found";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestEditResponse)
		{
			WWSystemResponse systemResponse;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;

			//positive test, test the case of edit successed
			systemResponse.setSystemResponse(WWUtilities::EDIT, "taskName", true);
			expectedSystemResponse = "taskName edited";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);

			//negative test, test the case of edit failed
			systemResponse.setSystemResponse(WWUtilities::EDIT, "taskName", false);
			expectedSystemResponse = "Index not found";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestDoneResponse)
		{
			WWSystemResponse systemResponse;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;

			//positive test, test the case of done successed
			systemResponse.setSystemResponse(WWUtilities::DONE, "taskName", true);
			expectedSystemResponse = "taskName is marked as completed";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);

			//negative test, test the case of done failed
			systemResponse.setSystemResponse(WWUtilities::DONE, "taskName", false);
			expectedSystemResponse = "taskName is already completed";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestUndoneResponse)
		{
			WWSystemResponse systemResponse;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;

			//positive test, test the case of undone successed
			systemResponse.setSystemResponse(WWUtilities::UNDONE, "taskName", true);
			expectedSystemResponse = "taskName is marked as incomplete";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);

			//negative test, test the case of undone failed
			systemResponse.setSystemResponse(WWUtilities::UNDONE, "taskName", false);
			expectedSystemResponse = "taskName is already incomplete";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestInvalidResponse)
		{
			WWSystemResponse systemResponse;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;

			//positive test, test the case of undone successed
			systemResponse.setSystemResponseInvalid();
			expectedSystemResponse = "Invalid command";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestSearchResponse)
		{
			WWSystemResponse systemResponse;
			std::string expectedSystemResponse;
			std::string actualSystemResponse;

			//test the response of search
			systemResponse.setSystemResponseSearch(1);
			expectedSystemResponse = "1 results are found";			
			actualSystemResponse = systemResponse.getSystemResponse();
			Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestViewAllResponse)
		{
			 WWSystemResponse systemResponse;
			 systemResponse.setSystemResponseView(WWUtilities::VIEWALL, 5);
			 std::string expectedSystemResponse = "You have 5 tasks in total";
			 std::string actualSystemResponse = systemResponse.getSystemResponse();
			 Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestViewTodayResponse)
		{
			 WWSystemResponse systemResponse;
			 systemResponse.setSystemResponseView(WWUtilities::VIEWTODAY, 5);
			 std::string expectedSystemResponse = "You have 5 tasks for today";
			 std::string actualSystemResponse = systemResponse.getSystemResponse();
			 Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestViewOverdueResponse)
		{
			 WWSystemResponse systemResponse;
			 systemResponse.setSystemResponseView(WWUtilities::VIEWOVERDUE, 5);
			 std::string expectedSystemResponse = "You have 5 overdue tasks in total";
			 std::string actualSystemResponse = systemResponse.getSystemResponse();
			 Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestViewUndoneResponse)
		{
			 WWSystemResponse systemResponse;
			 systemResponse.setSystemResponseView(WWUtilities::VIEWUNDONE, 5);
			 std::string expectedSystemResponse = "You have 5 incomplete tasks in total";
			 std::string actualSystemResponse = systemResponse.getSystemResponse();
			 Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestViewDoneResponse)
		{
			 WWSystemResponse systemResponse;
			 systemResponse.setSystemResponseView(WWUtilities::VIEWDONE, 5);
			 std::string expectedSystemResponse = "You have 5 completed tasks in total";
			 std::string actualSystemResponse = systemResponse.getSystemResponse();
			 Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestViewFloatingResponse)
		{
			 WWSystemResponse systemResponse;
			 systemResponse.setSystemResponseView(WWUtilities::VIEWFLOATING, 5);
			 std::string expectedSystemResponse = "You have 5 floating tasks in total";
			 std::string actualSystemResponse = systemResponse.getSystemResponse();
			 Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestViewTimedResponse)
		{
			 WWSystemResponse systemResponse;
			 systemResponse.setSystemResponseView(WWUtilities::VIEWTIMED, 5);
			 std::string expectedSystemResponse = "You have 5 timed tasks in total";
			 std::string actualSystemResponse = systemResponse.getSystemResponse();
			 Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}

		TEST_METHOD(TestViewDeadlineResponse)
		{
			 WWSystemResponse systemResponse;
			 systemResponse.setSystemResponseView(WWUtilities::VIEWDEADLINE, 5);
			 std::string expectedSystemResponse = "You have 5 deadline tasks in total";
			 std::string actualSystemResponse = systemResponse.getSystemResponse();
			 Assert::AreEqual(expectedSystemResponse, actualSystemResponse);
		}
	};
} 
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testSystemResponse.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testTaskSorter.cpp
	 */


//**************************************************************
//			    Unit Test: TaskSorter Class
//					  Author: AI YUE
//
//			      File: testTaskSorter.cpp
//**************************************************************

#include "stdafx.h"
#include "CppUnitTest.h"
#include "WWTask.h"
#include "TaskSorter.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace ExecutorUnitTest{
	TEST_CLASS(testTaskSorter){
public:

	TEST_METHOD(test_sort_of_two_timed_task){
		TaskSorter taskSorter = TaskSorter::getInstance();
		std::vector<WWTask> testTaskList;
		WWTask testTemp;
		std::string expectedTaskName1;
		std::string expectedTaskName2;

		//arrange

		//testTaskList[0]: Timed Task 2; 20140404 0800; 20140405 0800; undone
		testTemp.setTaskName("Timed Task 2");
		testTemp.setStartDate("20140404");
		testTemp.setStartTime("0800");
		testTemp.setEndDate("20140405");
		testTemp.setEndTime("0800");
		testTaskList.push_back(testTemp);
		//testTaskList[1]: Timed Task 1; 20140404 0600; 20140405 1800; undone
		testTemp.setTaskName("Timed Task 1");
		testTemp.setStartDate("20140404");
		testTemp.setStartTime("0600");
		testTemp.setEndDate("20140405");
		testTemp.setEndTime("1800");
		testTaskList.push_back(testTemp);

		expectedTaskName1 = "Timed Task 1";
		expectedTaskName2 = "Timed Task 2";

		//act
		taskSorter.sortTask(testTaskList);

		//assert
		Assert::AreEqual(expectedTaskName1, testTaskList[0].getTaskName());
		Assert::AreEqual(expectedTaskName2, testTaskList[1].getTaskName());
	}

	TEST_METHOD(test_sort_of_two_deadline_task){
		TaskSorter taskSorter = TaskSorter::getInstance();
		std::vector<WWTask> testTaskList;
		WWTask testTemp;
		std::string expectedTaskName1;
		std::string expectedTaskName2;

		//arrange

		////testTaskList[0]: Deadline Task 2;				;20140503 1800; undone 
		testTaskList.push_back(testTemp);			
		testTemp.setTaskName("Deadline Task 2");
		testTemp.setStartDate("20140503");
		testTemp.setStartTime("1800");
		testTaskList.push_back(testTemp);			
		//testTaskList[1]: Deadline Task 2;				;20140502 1800; undone
		testTemp.setTaskName("Deadline Task 1");
		testTemp.setStartDate("20140502");
		testTemp.setStartTime("1800");
		testTaskList.push_back(testTemp);	

		expectedTaskName1 = "Deadline Task 1";
		expectedTaskName2 = "Deadline Task 2";

		//act
		taskSorter.sortTask(testTaskList);

		//assert
		Assert::AreEqual(expectedTaskName1, testTaskList[0].getTaskName());
		Assert::AreEqual(expectedTaskName2, testTaskList[1].getTaskName());
	}

	TEST_METHOD(test_sort_of_timed_and_deadline_and_floating_task){
		TaskSorter taskSorter = TaskSorter::getInstance();
		std::vector<WWTask> testTaskList;
		WWTask testTemp;
		std::string expectedTaskName1;
		std::string expectedTaskName2;
		std::string expectedTaskName3;

		//arrange

		//testTaskList[0]: Floating Task;				;				; undone
		testTemp.setTaskName("Floating Task");
		testTemp.setStartDate("");
		testTemp.setStartTime("");
		testTemp.setEndDate("");
		testTemp.setEndTime("");
		testTaskList.push_back(testTemp);
		//testTaskList[1]: Deadline Task;				;20140503 1800; undone 
		testTaskList.push_back(testTemp);			
		testTemp.setTaskName("Deadline Task");
		testTemp.setStartDate("20140503");
		testTemp.setStartTime("1800");
		testTaskList.push_back(testTemp);	
		//testTaskList[2]: Timed Task; 20140404 0800; 20140405 0800; undone
		testTemp.setTaskName("Timed Task 2");
		testTemp.setStartDate("20140404");
		testTemp.setStartTime("0800");
		testTemp.setEndDate("20140405");
		testTemp.setEndTime("0800");
		testTaskList.push_back(testTemp);

		expectedTaskName1 = "Timed Task";
		expectedTaskName2 = "Deadline Task";
		expectedTaskName3 = "Floating Task";

		//act
		taskSorter.sortTask(testTaskList);

		//assert
		Assert::AreEqual(expectedTaskName1, testTaskList[0].getTaskName());
		Assert::AreEqual(expectedTaskName2, testTaskList[1].getTaskName());
		Assert::AreEqual(expectedTaskName3, testTaskList[2].getTaskName());
	}

	TEST_METHOD(test_sort_of_done_and_undone_task){
		TaskSorter taskSorter = TaskSorter::getInstance();
		std::vector<WWTask> testTaskList;
		WWTask testTemp;
		std::string expectedTaskName1;
		std::string expectedTaskName2;

		//arrange
		//testTaskList[0]: Done Timed Task; 20140404 0900; 20140404 1800; done
		testTemp.setTaskName("Done Timed Task");
		testTemp.setStartDate("20140404");
		testTemp.setStartTime("0900");
		testTemp.setEndDate("20140404");
		testTemp.setEndTime("1800");
		testTemp.setStatus("true");
		testTaskList.push_back(testTemp);			
		//testTaskList[1]: Undone Timed Task; 20140404 0600; 20140405 1800; undone
		testTemp.setTaskName("Undone Timed Task");
		testTemp.setStartDate("20140404");
		testTemp.setStartTime("0600");
		testTemp.setEndDate("20140405");
		testTemp.setEndTime("1800");
		testTaskList.push_back(testTemp);


		expectedTaskName1 = "Undone Timed Task";
		expectedTaskName2 = "Done Timed Task";

		//act
		taskSorter.sortTask(testTaskList);

		//assert
		Assert::AreEqual(expectedTaskName1, testTaskList[0].getTaskName());
		Assert::AreEqual(expectedTaskName2, testTaskList[1].getTaskName());
	}
	};
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\testTaskSorter.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWDisplay.cpp
	 */


//***************************************************************
//					  Author: AI YUE
//
//					File: WWDisplay.cpp
//***************************************************************

#include <string>
#include <vector>
#include "WWTask.h"
#include "WWUtilities.h"
#include "WWDisplayWindow.h"
#include "WWSystemResponse.h"
#include "WWDisplayFloating.h"
#include "WWDisplay.h"

using namespace std;

WWDisplay::WWDisplay() {
	_pageIndex = WWUtilities::PAGEALL;
}

void WWDisplay::setMainDisplay(vector<WWTask> taskStorage, WWUtilities::PageType pageType) {
	switch(pageType){
	case WWUtilities::PAGEALL:
		_mainDisplay.setContent(taskStorage);
		setPageIndex(WWUtilities::PAGEALL);
		_numOfItems = taskStorage.size();
		break;
	case WWUtilities::PAGETODAY:
		_mainDisplay.setContent(getTodayTask(taskStorage));
		_numOfItems = getTodayTask(taskStorage).size();
		setPageIndex(WWUtilities::PAGETODAY);
		break;
	case WWUtilities::PAGEOVERDUE:
		_mainDisplay.setContent(getOverdueTask(taskStorage));
		_numOfItems = getOverdueTask(taskStorage).size();
		setPageIndex(WWUtilities::PAGEOVERDUE);
		break;
	case WWUtilities::PAGEDONE:
		_mainDisplay.setContent(getDoneTask(taskStorage));
		_numOfItems = getDoneTask(taskStorage).size();
		setPageIndex(WWUtilities::PAGEDONE);
		break;
	case WWUtilities::PAGEUNDONE:
		_mainDisplay.setContent(getUndoneTask(taskStorage));
		_numOfItems = getUndoneTask(taskStorage).size();
		setPageIndex(WWUtilities::PAGEUNDONE);
		break;
	case WWUtilities::PAGETIMED:
		_mainDisplay.setContent(getTimedTask(taskStorage));
		_numOfItems = getTimedTask(taskStorage).size();
		setPageIndex(WWUtilities::PAGETIMED);
		break;
	case WWUtilities::PAGEDEADLINE:
		_mainDisplay.setContent(getDeadlineTask(taskStorage));
		_numOfItems = getDeadlineTask(taskStorage).size();
		setPageIndex(WWUtilities::PAGEDEADLINE);
		break;
	case WWUtilities::PAGEFLOATING:
		_mainDisplay.setContent(getFloatingTask(taskStorage));
		_numOfItems = getFloatingTask(taskStorage).size();
		setPageIndex(WWUtilities::PAGEFLOATING);
		break;
	case WWUtilities::PAGESEARCH:
		_mainDisplay.setContent(taskStorage);
		_numOfItems = taskStorage.size();
		setPageIndex(WWUtilities::PAGESEARCH);
		break;
	}
	_floatingTask.generateRandomTask(getUndoneFloatingTask(taskStorage));
}

void WWDisplay::setSystemResponseOpenFile(bool openFileStatus) {
	_systemResponse.setSystemResponseOpenFile(openFileStatus);
}

void WWDisplay::setSystemResponse(WWUtilities::CommandType command, string taskName, bool status) {
	_systemResponse.setSystemResponse(command, taskName, status);
}

void WWDisplay::setSystemResponseDeleteAll() {
	_systemResponse.setSystemResponseDeleteAll();
}

void WWDisplay::setSystemResponseUndoRedo(WWUtilities::CommandType command, bool status){
	_systemResponse.setSystemResponseUndoRedo(command, status);
}

void WWDisplay::setSystemResponseSearch(int numResult) {
	_systemResponse.setSystemResponseSearch(numResult);
}

void WWDisplay::setSystemResponseView(WWUtilities::CommandType command) {
	_systemResponse.setSystemResponseView(command, _numOfItems);
}

void WWDisplay::setSystemResponseInvalid() {
	_systemResponse.setSystemResponseInvalid();
}

std::vector<vector<string>>& WWDisplay::getMainDisplay() {
	return _mainDisplay.getContent();
}

std::string WWDisplay::getSystemResponse() {
	return _systemResponse.getSystemResponse();
}

int WWDisplay::getPageIndex(){
	return _pageIndex;
}

std::string WWDisplay::getFloatingTask() {
	return _floatingTask.getFloatingTaskName();
}

void WWDisplay::setPageIndex(WWUtilities::PageType pageType){
	_pageIndex = pageType;
}

std::vector<WWTask> WWDisplay::getFloatingTask(std::vector<WWTask> taskStorage){
	std::vector<WWTask> floatingTaskList;

	for(unsigned int i = 0; i < taskStorage.size(); i++){
		if(taskStorage[i].getTaskType() == WWUtilities::FLOATING){
			floatingTaskList.push_back(taskStorage[i]);
		}
	}

	return floatingTaskList;
}

std::vector<WWTask> WWDisplay::getUndoneFloatingTask(std::vector<WWTask> taskStorage){
	std::vector<WWTask> undoneFloatingTaskList;

	for(unsigned int i = 0; i < taskStorage.size(); i++){
		if(taskStorage[i].getTaskType() == WWUtilities::FLOATING && (!taskStorage[i].getStatus())){
			undoneFloatingTaskList.push_back(taskStorage[i]);
		}
	}

	return undoneFloatingTaskList;
}

std::vector<WWTask> WWDisplay::getTimedTask(std::vector<WWTask> taskStorage){
	vector<WWTask> timedTaskList;

	for(unsigned int i = 0; i < taskStorage.size(); i++) {
		if(taskStorage[i].getTaskType() == WWUtilities::TIMED) {
			timedTaskList.push_back(taskStorage[i]);
		}
	}

	return timedTaskList;
}

std::vector<WWTask> WWDisplay::getDeadlineTask(std::vector<WWTask> taskStorage){
	std::vector<WWTask> deadlineTaskList;

	for(unsigned int i = 0; i < taskStorage.size(); i++) {
		if(taskStorage[i].getTaskType() == WWUtilities::DEADLINE) {
			deadlineTaskList.push_back(taskStorage[i]);
		}
	}

	return deadlineTaskList;
}

std::vector<WWTask> WWDisplay::getTodayTask(std::vector<WWTask> taskStorage){
	std::vector<WWTask> todayTaskList;

	for(unsigned int i = 0; i < taskStorage.size(); i++) {
		if(taskStorage[i].checkToday()){
			todayTaskList.push_back(taskStorage[i]);
		}
	}

	return todayTaskList;
}

std::vector<WWTask> WWDisplay::getOverdueTask(std::vector<WWTask> taskStorage){
	std::vector<WWTask> overdueTaskList;

	for(unsigned int i = 0; i < taskStorage.size(); i++) {
		if(taskStorage[i].checkOverdue()){
			overdueTaskList.push_back(taskStorage[i]);		
		}
	}

	return overdueTaskList;
}

std::vector<WWTask> WWDisplay::getDoneTask(std::vector<WWTask> taskStorage){
	std::vector<WWTask> doneTaskList;

	for(unsigned int i = 0; i < taskStorage.size(); i++) {
		if(taskStorage[i].getStatus()){
			doneTaskList.push_back(taskStorage[i]);
		}
	}

	return doneTaskList;
}

std::vector<WWTask> WWDisplay::getUndoneTask(std::vector<WWTask> taskStorage){
	std::vector<WWTask> undoneTaskList;

	for(unsigned int i = 0; i < taskStorage.size(); i++) {
		if(!taskStorage[i].getStatus()){
			undoneTaskList.push_back(taskStorage[i]);
		}
	}

	return undoneTaskList;
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWDisplay.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWDisplayFloating.cpp
	 */


//***************************************************************
//			      Class WWDisplayFloating
//					  Author: AI YUE
//
//			    File: WWDisplayFloating.cpp
//
// WWDisplayFloating class is used to set display of the random
// floating task
//***************************************************************

#include <vector>
#include <stdlib.h>
#include "WWTask.h"
#include "WWDisplayFloating.h"

const string MSG_EMPTY_FLOATING_TASK = "All floating task done!";

WWDisplayFloating::WWDisplayFloating(){
}

void WWDisplayFloating::generateRandomTask(std::vector<WWTask> floatingTaskList){
	unsigned int size = floatingTaskList.size();

	if(size > 0){
		int randomIndex = rand()%size;
		_randomFloatingTaskName = floatingTaskList[randomIndex].getTaskName();
	} else {
		_randomFloatingTaskName = MSG_EMPTY_FLOATING_TASK;
	}
}

std::string WWDisplayFloating::getFloatingTaskName(){
	return _randomFloatingTaskName;
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWDisplayFloating.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWExecutor.cpp
	 */


//***************************************************************
//			         Class WWExecutor
//					  Author: AI YUE
//
//			       File: WWExecutor.cpp
//
// WWExecutor class is used to execute different commands and get
// proper display for GUI
//***************************************************************

#include <string>
#include <vector>
#include <assert.h>
#include "WWUtilities.h"
#include "WWTask.h"
#include "WWStorage.h"
#include "WWDisplay.h"
#include "WWLogger.h"
#include "AddExecutor.h"
#include "DeleteExecutor.h"
#include "EditExecutor.h"
#include "SearchExecutor.h"
#include "StatusExecutor.h"
#include "TaskSorter.h"
#include "WWExecutor.h"

using namespace std;

const int USER_INDEX_ADJUSTMENT  = 1;
const int INVALID_INDEX			 = -1;
const int DATE_LENGTH			 = 8;
const int TIME_LENGTH			 = 4;
const int DATE_MULTIPLIER        = 10000;
const int LARGEST_TIME_INT       = 2359;

WWExecutor::WWExecutor() {
	_isOpeningDisplay = true;
}

WWDisplay WWExecutor::openFile() {
	bool isNotCorrupted;
	WWLogger logger = WWLogger::getInstance();

	isNotCorrupted = _storage.openFile(_taskStorage, _searchResult);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGEALL);
	_display.setSystemResponseOpenFile(isNotCorrupted);

	//keep a log of the action
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::addTask(WWTask newTask) {
	WWLogger logger = WWLogger::getInstance();

	_addExecutor.addTask(_taskStorage, newTask, _display);

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGEALL);
	_storage.saveFile(_taskStorage);

	//keep a log of the action
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::deleteTask(int taskIndex, WWUtilities::PageType pageType) {
	WWLogger logger = WWLogger::getInstance();

	// for delete on search page, we delete the task from the _searchResult and then get the 
	// _taskStorage from the _searchExecutor
	if(pageType == WWUtilities::PAGESEARCH){
		_deleteExecutor.deleteTask(_searchResult, taskIndex - USER_INDEX_ADJUSTMENT, pageType, _display);
		_searchExecutor.getTaskStorage(_searchResult, _taskStorage);
	} else {
		int actualIndex = determineIndexReference(taskIndex, pageType);
		unsigned int vectorIndex = actualIndex - USER_INDEX_ADJUSTMENT;
		_deleteExecutor.deleteTask(_taskStorage, vectorIndex, pageType,  _display);
	}

	_storage.saveOper(_taskStorage, _searchResult, pageType);
	_storage.saveFile(_taskStorage);

	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::editTask(int taskIndex, WWTask newTask, WWUtilities::PageType pageType) {
	WWLogger logger = WWLogger::getInstance();

	if(pageType == WWUtilities::PAGESEARCH){
		_editExecutor.editTask(_searchResult, taskIndex - USER_INDEX_ADJUSTMENT, newTask, pageType, _display);
		_searchExecutor.getTaskStorage(_searchResult, _taskStorage);
	} else {
		int actualIndex = determineIndexReference(taskIndex, pageType);
		unsigned int vectorIndex = actualIndex - USER_INDEX_ADJUSTMENT;
		_editExecutor.editTask(_taskStorage, vectorIndex, newTask, pageType,  _display);
	}

	_storage.saveOper(_taskStorage, _searchResult, pageType);
	_storage.saveFile(_taskStorage);

	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::markDone(int taskIndex, WWUtilities::PageType pageType) {
	WWLogger logger = WWLogger::getInstance();

	if(pageType == WWUtilities::PAGESEARCH){
		_statusExecutor.markDone(_searchResult, taskIndex- USER_INDEX_ADJUSTMENT, pageType, _display);
		_searchExecutor.getTaskStorage(_searchResult, _taskStorage);
	} else {
		int actualIndex = determineIndexReference(taskIndex, pageType);
		unsigned int vectorIndex = actualIndex - USER_INDEX_ADJUSTMENT;
		_statusExecutor.markDone(_taskStorage, vectorIndex, pageType,  _display);
	}

	_storage.saveOper(_taskStorage, _searchResult, pageType);
	_storage.saveFile(_taskStorage);

	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::markUndone(int taskIndex, WWUtilities::PageType pageType) {
	WWLogger logger = WWLogger::getInstance();

	if(pageType == WWUtilities::PAGESEARCH){
		_statusExecutor.markUndone(_searchResult, taskIndex - USER_INDEX_ADJUSTMENT, pageType, _display);
		_searchExecutor.getTaskStorage(_searchResult, _taskStorage);

	} else {
		int actualIndex = determineIndexReference(taskIndex, pageType);
		unsigned int vectorIndex = actualIndex - USER_INDEX_ADJUSTMENT;
		_statusExecutor.markUndone(_taskStorage, vectorIndex, pageType,  _display);
	}

	_storage.saveOper(_taskStorage, _searchResult, pageType);
	_storage.saveFile(_taskStorage);

	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::searchTask(std::vector<std::string> searchAttribute)  {
	WWLogger logger = WWLogger::getInstance();

	//searching attributes passed in should have 5 items
	assert(searchAttribute.size() == 5);

	std::string keyword = searchAttribute[0];
	std::string startDate = searchAttribute[1];
	std::string startTime = searchAttribute[2];
	std::string endDate = searchAttribute[3];
	std::string endTime = searchAttribute[4];

	long long start, end;

	assert((startDate.length() == DATE_LENGTH) || (startDate.length() == 0));
	assert((startTime.length() == TIME_LENGTH) || (startTime.length() == 0));

	assert((endDate.length() == DATE_LENGTH) || (endDate.length() == 0));
	assert((endTime.length() == TIME_LENGTH) || (endTime.length() == 0));

	if(startDate.empty() && endDate.empty()){
		logger.addLog("search keyword only: " + keyword);
		//search keyword only
		_searchExecutor.searchTask(_taskStorage, keyword, _display);
	} else if(endDate.empty()){
		logger.addLog("search keyword with one time");

		//for search keyword with one time
		//if there is only startDate, it will be considered as search from 0000 - 2359 on that date
		//if there is startDate and startTime, the start and end time will be the same time point
		if(startTime.empty()){
			start = (long long) stoi(startDate, nullptr) * DATE_MULTIPLIER;
			end   = (long long) stoi(startDate, nullptr) * DATE_MULTIPLIER + LARGEST_TIME_INT;
		} else {
			start = (long long) stoi(startDate, nullptr) * DATE_MULTIPLIER + stoi(startTime, nullptr);
			end   = start;
		}

		_searchExecutor.searchTask(_taskStorage, keyword, start, end, _display);
	} else {

		logger.addLog("search keyword within a time period");

		//for search keyword within a time period
		//if start time is empty, set the start time to 0000
		if(startTime.empty()){
			start = (long long) stoi(startDate, nullptr) * DATE_MULTIPLIER;
		} else{
			start = (long long) stoi(startDate, nullptr) * DATE_MULTIPLIER + stoi(startTime, nullptr);
		}

		//if end time is empty, set the end time to 2359
		if(endTime.empty()){
			end = (long long) stoi(endDate, nullptr) * DATE_MULTIPLIER + LARGEST_TIME_INT;
		} else {
			end = (long long) stoi(endDate, nullptr) * DATE_MULTIPLIER + stoi(endTime, nullptr);
		}

		_searchExecutor.searchTask(_taskStorage, keyword, start, end, _display);
	}

	_searchExecutor.getSearchResult(_searchResult);
	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGESEARCH);

	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::redo(WWUtilities::PageType pageType){
	WWLogger logger = WWLogger::getInstance();

	bool status;

	status = _storage.redo(_taskStorage, _searchResult, pageType);
	if(pageType == WWUtilities::PAGESEARCH){
		_display.setMainDisplay(_searchResult, pageType);
	} else {
		_display.setMainDisplay(_taskStorage, pageType);
	}

	_storage.saveFile(_taskStorage);
	_display.setSystemResponseUndoRedo(WWUtilities::REDO, status);

	logger.addLog("redo is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::undo(WWUtilities::PageType pageType){
	WWLogger logger = WWLogger::getInstance();
	bool status;

	status = _storage.undo(_taskStorage, _searchResult, pageType);

	if(pageType == WWUtilities::PAGESEARCH){
		_display.setMainDisplay(_searchResult, pageType);
	} else {
		_display.setMainDisplay(_taskStorage, pageType);
	}

	_storage.saveFile(_taskStorage);
	_display.setSystemResponseUndoRedo(WWUtilities::UNDO, status);

	logger.addLog("undo is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::deleteAll(){
	WWLogger logger = WWLogger::getInstance();

	_taskStorage.clear();
	_searchResult.clear();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGEALL);
	_storage.saveFile(_taskStorage);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGEALL);
	_display.setSystemResponseDeleteAll();

	logger.addLog("delete all is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::refresh(WWUtilities::PageType currentPage){
	if(currentPage == WWUtilities::PAGESEARCH){
		_display.setMainDisplay(_searchResult, currentPage);
	}else{
		_display.setMainDisplay(_taskStorage, currentPage);
	}

	return _display;
}

WWDisplay WWExecutor::viewAll() {
	WWLogger logger = WWLogger::getInstance();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGEALL);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGEALL);
	if(!_isOpeningDisplay) {
		_display.setSystemResponseView(WWUtilities::VIEWALL);
	} else {
		_isOpeningDisplay = false;
	}

	logger.addLog("viewAll is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::viewToday(){
	WWLogger logger = WWLogger::getInstance();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGETODAY);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGETODAY);
	_display.setSystemResponseView(WWUtilities::VIEWTODAY);

	logger.addLog("viewToday is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::viewOverdue(){
	WWLogger logger = WWLogger::getInstance();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGEOVERDUE);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGEOVERDUE);
	_display.setSystemResponseView(WWUtilities::VIEWOVERDUE);

	logger.addLog("viewOverdue is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::viewDone() {
	WWLogger logger = WWLogger::getInstance();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGEDONE);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGEDONE);
	_display.setSystemResponseView(WWUtilities::VIEWDONE);

	logger.addLog("viewDone is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::viewUndone() {
	WWLogger logger = WWLogger::getInstance();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGEUNDONE);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGEUNDONE);
	_display.setSystemResponseView(WWUtilities::VIEWUNDONE);

	logger.addLog("viewUndone is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::viewDeadlineTask() {
	WWLogger logger = WWLogger::getInstance();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGEDEADLINE);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGEDEADLINE);
	_display.setSystemResponseView(WWUtilities::VIEWDEADLINE);

	logger.addLog("viewDeadline is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::viewTimedTask() {
	WWLogger logger = WWLogger::getInstance();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGETIMED);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGETIMED);
	_display.setSystemResponseView(WWUtilities::VIEWTIMED);

	logger.addLog("viewTimed is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::viewFloatingTask() {
	WWLogger logger = WWLogger::getInstance();

	_storage.saveOper(_taskStorage, _searchResult, WWUtilities::PAGEFLOATING);

	_display.setMainDisplay(_taskStorage, WWUtilities::PAGEFLOATING);
	_display.setSystemResponseView(WWUtilities::VIEWFLOATING);

	logger.addLog("viewAll is executed");
	logger.addLog(_display.getSystemResponse());
	logger.saveLog();

	return _display;
}

WWDisplay WWExecutor::viewSearch(){
	WWLogger logger = WWLogger::getInstance();

	_display.setMainDisplay(_searchResult, WWUtilities::PAGESEARCH);

	return _display;
}

WWDisplay WWExecutor::invalidCommand(WWUtilities::PageType pageType) {
	WWLogger logger = WWLogger::getInstance();

	_display.setMainDisplay(_taskStorage, pageType);
	_display.setSystemResponseInvalid();

	return _display;
}

int WWExecutor::determineIndexReference(int index, WWUtilities::PageType pageType){
	WWLogger logger = WWLogger::getInstance();
	int actualIndex = INVALID_INDEX;
	int count = 0;
	unsigned int i = 0;

	logger.addLog("determineIndexReference is executed");

	switch(pageType){
	case WWUtilities::PAGEALL: 
		actualIndex = index;
		break;

	case WWUtilities::PAGEOVERDUE: 
		while(count < index && i < _taskStorage.size()){
			if(_taskStorage[i].checkOverdue()){
				count++;
			}
			i++;
		}
		//check whether the index is in range
		if(i <= _taskStorage.size() && (count == index)){
			actualIndex = i;
		} else {
			actualIndex = INVALID_INDEX;
		}
		break;

	case WWUtilities::PAGETODAY: 
		while(count < index && i < _taskStorage.size()){
			if(_taskStorage[i].checkToday()){
				count++;
			}
			i++;
		}
		if(i <= _taskStorage.size() && (count == index)){
			actualIndex = i;
		} else {
			actualIndex = INVALID_INDEX; 
		}

		break;

	case WWUtilities::PAGEDONE: 
		while(count < index && i < _taskStorage.size()){
			if(_taskStorage[i].getStatus()){
				count++;
			}
			i++;
		}
		if(i <= _taskStorage.size() && (count == index)){
			actualIndex = i;
		} else {
			actualIndex = INVALID_INDEX;
		}
		break;

	case WWUtilities::PAGEUNDONE: 
		while(count < index && i < _taskStorage.size()){
			if(!_taskStorage[i].getStatus()){
				count++;
			}
			i++;
		}
		if(i <= _taskStorage.size() && (count == index)){
			actualIndex = i;
		} else {
			actualIndex = INVALID_INDEX;
		}
		break;

	case WWUtilities::PAGEFLOATING: 
		while(count < index && i < _taskStorage.size()){
			if(_taskStorage[i].getTaskType() == WWUtilities::FLOATING){
				count++;
			}
			i++;
		}
		if(i <= _taskStorage.size() && (count == index)){
			actualIndex = i;
		} else {
			actualIndex = INVALID_INDEX;
		}
		break;

	case WWUtilities::PAGETIMED: 
		while(count < index && i < _taskStorage.size()){
			if(_taskStorage[i].getTaskType() == WWUtilities::TIMED){
				count++;
			}
			i++;
		}
		if(i <= _taskStorage.size() && (count == index)){
			actualIndex = i;
		} else {
			actualIndex = INVALID_INDEX;
		}
		break;

	case WWUtilities::PAGEDEADLINE: 
		while(count < index && i < _taskStorage.size()){
			if(_taskStorage[i].getTaskType() == WWUtilities::DEADLINE){
				count++;
			}
			i++;
		}
		if(i <= _taskStorage.size() && (count == index)){
			actualIndex = i;
		} else {
			actualIndex = INVALID_INDEX;
		}
		break;

	default:
		actualIndex = INVALID_INDEX;
	}

	return actualIndex;
} 

	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWExecutor.cpp





	/**
	 * origin: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWSystemResponse.cpp
	 */


//*************************************************************
//			      Class WWSystemResponse
//					  Author: AI YUE
//
//			    File: WWSystemResponse.cpp
//
// WWSystemResponse class is used to set the system response of 
// different actions
//**************************************************************

#include <string>
#include <iostream>
#include <sstream>
#include <exception>
#include <assert.h>
#include "WWUtilities.h"
#include "WWSystemResponse.h"

using namespace std;

const int MAX			 = 99;
const int TASK_NAME_MAX  = 50;
const int START_POSITION = 0;

const string OPENFILE_SUCCESS_FEEDBACK  = "Welcome to WorkWork!";
const string OPENFILE_FAILURE_FEEDBACK  = "File is corrupted!";
const string ADD_SUCCESS_FEEDBACK		= "%s created";
const string ADD_FAIL_FEEDBACK			= "Please input task name";
const string DELETE_SUCCESS_FEEDBACK	= "%s deleted";
const string EDIT_SUCCESS_FEEDBACK		= "%s edited";
const string DONE_SUCCESS_FEEDBACK		= "%s is marked as completed";
const string DONE_FAIL_FEEDBACK			= "%s is already completed";
const string UNDONE_SUCCESS_FEEDBACK	= "%s is marked as incomplete";
const string UNDONE_FAIL_FEEDBACK		= "%s is already incomplete";
const string SEARCH_FEEDBACK			= "%d results are found";
const string DELETEALL_SUCCESS_FEEDBACK	= "All your tasks are deleted";
const string VIEW_ALL_FEEDBACK			= "You have %d tasks in total";
const string VIEW_TODAY_FEEDBACK		= "You have %d tasks for today";
const string VIEW_OVERDUE_FEEDBACK		= "You have %d overdue tasks in total";
const string VIEW_TIMED_FEEDBACK		= "You have %d timed tasks in total";
const string VIEW_DEADLINE_FEEDBACK		= "You have %d deadline tasks in total";
const string VIEW_FLOATING_FEEDBACK		= "You have %d floating tasks in total";
const string VIEW_UNDONE_FEEDBACK		= "You have %d incomplete tasks in total";
const string VIEW_DONE_FEEDBACK			= "You have %d completed tasks in total";
const string UNDO_SUCCESS_FEEDBACK		= "Undo successful";
const string UNDO_FAIL_FEEDBACK			= "Undo not available";
const string REDO_SUCCESS_FEEDBACK		= "Redo successful";
const string REDO_FAIL_FEEDBACK			= "Redo not available";
const string INDEX_NOT_FOUND_FEEDBACK	= "Index not found";
const string INVALID_COMMAND_FEEDBACK	= "Invalid command";

const string ELLIPSIS_STRING			= "...";

const string INVALID_COMMAND_TYPE       = "Invalid command type. You may used a wrong set systemResponse function.";

WWSystemResponse::WWSystemResponse() {
}

void WWSystemResponse::setSystemResponseOpenFile(bool openFileStatus) {
	char buffer [MAX];

	if(openFileStatus) {
		sprintf_s(buffer, OPENFILE_SUCCESS_FEEDBACK.c_str());
	} else {
		sprintf_s(buffer, OPENFILE_FAILURE_FEEDBACK.c_str());
	}

	_systemResponse = buffer;
}

void WWSystemResponse::setSystemResponse(WWUtilities::CommandType command, string taskName, bool status) {
	char buffer [MAX];

	// we chop the task name to a max of 50 characters
	// if task name is over 50, chop the part exceed 50 characters and add ... behind 
	taskName = chopTaskName(taskName);

	// after chopping, the task name should have a length of at most TASK_NAME_MAX + ELLIPSIS.length()
	assert(taskName.length() <= (unsigned int) TASK_NAME_MAX + ELLIPSIS_STRING.length());

	try{
		switch (command)
		{
		case WWUtilities::ADD:
			if(status) {
				sprintf_s(buffer, ADD_SUCCESS_FEEDBACK.c_str(), taskName.c_str());
			} else {
				sprintf_s(buffer, ADD_FAIL_FEEDBACK.c_str());
			}
			break;
		case WWUtilities::DELETE:
			if(status) {
				sprintf_s(buffer, DELETE_SUCCESS_FEEDBACK.c_str(), taskName.c_str());
			} else {
				sprintf_s(buffer, INDEX_NOT_FOUND_FEEDBACK.c_str());
			}
			break;
		case WWUtilities::EDIT:
			if(status) {
				sprintf_s(buffer, EDIT_SUCCESS_FEEDBACK.c_str(), taskName.c_str());
			} else {
				sprintf_s(buffer, INDEX_NOT_FOUND_FEEDBACK.c_str());
			}
			break;
		case WWUtilities::DONE:
			if(status) {
				sprintf_s(buffer, DONE_SUCCESS_FEEDBACK.c_str(), taskName.c_str());
			} else {
				if(taskName.empty()) {
					sprintf_s(buffer, INDEX_NOT_FOUND_FEEDBACK.c_str());
				} else {
					sprintf_s(buffer, DONE_FAIL_FEEDBACK.c_str(), taskName.c_str());
				}
			}
			break;
		case WWUtilities::UNDONE:
			if(status) {
				sprintf_s(buffer, UNDONE_SUCCESS_FEEDBACK.c_str(), taskName.c_str());
			} else {
				if(taskName.empty()) {
					sprintf_s(buffer, INDEX_NOT_FOUND_FEEDBACK.c_str());
				} else {
					sprintf_s(buffer, UNDONE_FAIL_FEEDBACK.c_str(), taskName.c_str());
				}
			}
			break;
		default:
			// if the command is none of the above, throw an exeception of INVALID_COMMAND_TYPE
			throw INVALID_COMMAND_TYPE;
			break;
		}
		_systemResponse = buffer;
	}
	catch(std::string & exception){
		std::cout << exception << endl;
	}
}

void WWSystemResponse::setSystemResponseDeleteAll() {
	char buffer[MAX];
	sprintf_s(buffer, DELETEALL_SUCCESS_FEEDBACK.c_str());
	_systemResponse = buffer;
}

void WWSystemResponse::setSystemResponseUndoRedo(WWUtilities::CommandType command, bool status){
	try{
		switch (command)
		{
		case WWUtilities::UNDO:
			if(status){
				_systemResponse = UNDO_SUCCESS_FEEDBACK;
			} else {
				_systemResponse = UNDO_FAIL_FEEDBACK;
			}
			break;
		case WWUtilities::REDO:
			if(status){
				_systemResponse = REDO_SUCCESS_FEEDBACK;
			} else {
				_systemResponse = REDO_FAIL_FEEDBACK;
			}
			break;
		default:
			// if the command is none of the above, throw an exeception of INVALID_COMMAND_TYPE
			throw INVALID_COMMAND_TYPE;
			break;
		}
	}
	catch(std::string& exception){
		std::cout << exception << endl;
	}
}

void WWSystemResponse::setSystemResponseSearch(int numResult) {
	char buffer[MAX];
	sprintf_s(buffer, SEARCH_FEEDBACK.c_str(), numResult);
	_systemResponse = buffer;
} 

void WWSystemResponse::setSystemResponseView(WWUtilities::CommandType command, int numResult) {
	char buffer [MAX];

	try{
		switch (command){
		case WWUtilities::VIEWALL:
			sprintf_s(buffer, VIEW_ALL_FEEDBACK.c_str(), numResult);
			break;
		case WWUtilities::VIEWDEADLINE:
			sprintf_s(buffer, VIEW_DEADLINE_FEEDBACK.c_str(), numResult);
			break;
		case WWUtilities::VIEWTIMED:
			sprintf_s(buffer, VIEW_TIMED_FEEDBACK.c_str(), numResult);
			break;
		case WWUtilities::VIEWFLOATING:
			sprintf_s(buffer, VIEW_FLOATING_FEEDBACK.c_str(), numResult);
			break;
		case WWUtilities::VIEWTODAY:
			sprintf_s(buffer, VIEW_TODAY_FEEDBACK.c_str(), numResult);
			break;
		case WWUtilities::VIEWDONE:
			sprintf_s(buffer, VIEW_DONE_FEEDBACK.c_str(), numResult);
			break;
		case WWUtilities::VIEWUNDONE:
			sprintf_s(buffer, VIEW_UNDONE_FEEDBACK.c_str(), numResult);
			break;
		case WWUtilities::VIEWOVERDUE:
			sprintf_s(buffer, VIEW_OVERDUE_FEEDBACK.c_str(), numResult);
			break;
		default:
			// if the command is none of the above, throw an exeception of INVALID_COMMAND_TYPE
			throw INVALID_COMMAND_TYPE;
			break;
		}
		_systemResponse = buffer;
	}
	catch(std::string& exception){
		std::cout << exception << endl;
	}
}

void WWSystemResponse::setSystemResponseInvalid() {
	_systemResponse = INVALID_COMMAND_FEEDBACK;
}

string WWSystemResponse::getSystemResponse() {
	return _systemResponse;
}

string WWSystemResponse::chopTaskName(string taskName){
	if(taskName.length() > TASK_NAME_MAX){
		return taskName.substr(START_POSITION, TASK_NAME_MAX) + ELLIPSIS_STRING;
	} else {
		return taskName;
	}
}
	// End of segment: C:\Users\Junhan\Desktop\cs2103jan2014-t16-1c\WorkWork V0.5\WorkWorkLib\WWSystemResponse.cpp





